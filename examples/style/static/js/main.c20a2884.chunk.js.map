{"version":3,"sources":["../../../../lib/util/shape.ts","../../../lib/types.ts","../../../../../lib/ops/util/conv.ts","../../../../../lib/ops/cpu/basic.ts","../../../../../lib/ops/util/pool.ts","../../../../../lib/ops/cpu/pool.ts","../../../../../lib/ops/cpu/pad.ts","../../../../../lib/tensor/cpu/tensor.ts","../../../../../lib/ops/cpu/matMul.ts","../../../../../lib/ops/cpu/gemm.ts","../../../../../lib/ops/cpu/sum.ts","../../../../../lib/ops/cpu/sumSquare.ts","../../../../../lib/ops/cpu/product.ts","../../../../../lib/ops/cpu/max.ts","../../../../../lib/ops/cpu/min.ts","../../../../../lib/ops/cpu/reduceMean.ts","../../../../../lib/ops/cpu/reduceMeanSquare.ts","../../../../../lib/ops/cpu/conv.ts","../../../../../lib/ops/cpu/averagePool.ts","../../../../../lib/ops/cpu/concat.ts","../../../../../lib/ops/cpu/transpose.ts","../../../../../lib/ops/cpu/repeat.ts","../../../../../lib/ops/cpu/expand.ts","../../../../../lib/ops/cpu/gather.ts","../../../../../lib/ops/cpu/slice.ts","../../../../../lib/ops/cpu/upsample.ts","../../../../../lib/ops/cpu/normalize.ts","../../../../../lib/util/datastructs/dict.ts","../../../../lib/util/math.ts","../../../../../lib/tensor/gpu/memory.ts","../../../../../lib/tensor/gpu/gl.ts","../../../../../lib/tensor/wasm/tensor.ts","../../../../../lib/ops/gpu/operation.ts","../../../../../../lib/ops/gpu/matMul/matmul.ts","../../../../../../lib/ops/gpu/unary/unaryOperation.ts","../../../../../../lib/ops/gpu/unary/exp.ts","../../../../../../lib/ops/gpu/conv/conv.ts","../../../../../../lib/ops/gpu/unary/abs.ts","../../../../../../lib/ops/gpu/binary/binaryOperation.ts","../../../../../../lib/ops/gpu/binary/add.ts","../../../../../../lib/ops/gpu/binary/multiply.ts","../../../../../../lib/ops/gpu/binary/subtract.ts","../../../../../../lib/ops/gpu/binary/divide.ts","../../../../../../lib/ops/gpu/conv/averagePool.ts","../../../../../../lib/ops/gpu/pool/pool.ts","../../../../../../lib/ops/gpu/pool/reduceMean.ts","../../../../../../lib/ops/gpu/pool/reduceMeanSquare.ts","../../../../../../lib/ops/gpu/pool/sumSquare.ts","../../../../../../lib/ops/gpu/pool/sum.ts","../../../../../../lib/ops/gpu/pool/product.ts","../../../../../../lib/ops/gpu/pool/max.ts","../../../../../../lib/ops/gpu/pool/min.ts","../../../../../../lib/ops/gpu/unary/ceil.ts","../../../../../../lib/ops/gpu/unary/clip.ts","../../../../../../lib/ops/gpu/unary/floor.ts","../../../../../../lib/ops/gpu/util/concat.ts","../../../../../../lib/ops/gpu/util/copy.ts","../../../../../../lib/ops/gpu/util/expand.ts","../../../../../../lib/ops/gpu/util/gather.ts","../../../../../../lib/ops/gpu/matMul/gemm.ts","../../../../../../lib/ops/gpu/binary/power.ts","../../../../../../lib/ops/gpu/unary/sqrt.ts","../../../../../../lib/ops/gpu/unary/log.ts","../../../../../../lib/ops/gpu/util/transpose.ts","../../../../../../lib/ops/gpu/util/repeat.ts","../../../../../../lib/ops/gpu/conv/pad.ts","../../../../../../lib/ops/gpu/util/slice.ts","../../../../../../lib/ops/gpu/conv/upsample.ts","../../../../../../lib/ops/gpu/conv/normalize.ts","../../../../../lib/ops/gpu/dispatcher.ts","../../../../../lib/tensor/gpu/tensor.ts","../../../../lib/util/convert.ts","../../../../lib/onnx/node.ts","../../../../lib/onnx/util.ts","../../../../lib/onnx/definitions.ts","../../../../../lib/onnx/nodes/constant.ts","../../../../../lib/onnx/nodes/conv.ts","../../../../../lib/onnx/optimizations/optimization.ts","../../../../../lib/onnx/optimizations/convBatchnorm.ts","../../../../../lib/onnx/optimizations/convRelu.ts","../../../../../lib/onnx/optimizations/convRelu6.ts","../../../../../lib/onnx/optimizations/default.ts","../../../../../../lib/onnx/nodes/binary/binaryNode.ts","../../../../../../lib/onnx/nodes/binary/add.ts","../../../../../lib/onnx/nodes/batchNormalization.ts","../../../../../lib/ops/cpu/cast.ts","../../../../../lib/onnx/nodes/cast.ts","../../../../../../lib/onnx/nodes/unary/unaryNode.ts","../../../../../../lib/onnx/nodes/unary/ceil.ts","../../../../../lib/onnx/nodes/clip.ts","../../../../../lib/onnx/nodes/concat.ts","../../../../../lib/onnx/nodes/constantOfShape.ts","../../../../../../lib/onnx/nodes/binary/div.ts","../../../../../../lib/onnx/nodes/unary/exp.ts","../../../../../lib/onnx/nodes/expand.ts","../../../../../../lib/onnx/nodes/unary/floor.ts","../../../../../lib/onnx/nodes/gather.ts","../../../../../lib/onnx/nodes/gemm.ts","../../../../../lib/onnx/nodes/instanceNormalization.ts","../../../../../lib/onnx/nodes/matMul.ts","../../../../../../lib/onnx/nodes/binary/mul.ts","../../../../../lib/onnx/nodes/pad.ts","../../../../../../lib/onnx/nodes/reduce/reduceNode.ts","../../../../../../lib/onnx/nodes/reduce/reduceMax.ts","../../../../../../lib/onnx/nodes/reduce/reduceMean.ts","../../../../../../lib/onnx/nodes/reduce/reduceSum.ts","../../../../../../lib/onnx/nodes/reduce/reduceSumSquare.ts","../../../../../lib/onnx/nodes/relu.ts","../../../../../lib/onnx/nodes/reshape.ts","../../../../../lib/onnx/nodes/shape.ts","../../../../../lib/onnx/nodes/slice.ts","../../../../../lib/onnx/nodes/softmax.ts","../../../../../../lib/onnx/nodes/binary/sub.ts","../../../../../lib/onnx/nodes/tile.ts","../../../../../lib/onnx/nodes/transpose.ts","../../../../../lib/onnx/nodes/unsqueeze.ts","../../../../../lib/onnx/nodes/upsample.ts","../../../../../lib/onnx/nodes/globalAveragePool.ts","../../../../lib/onnx/resolve.ts","../../../../lib/onnx/model.ts","inference.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["getSize","shape","strides","i","this","_b","resultShape","outputDimSize","inSize","kernel","a","poolResultShape","inputShape","sumShape","ixMap","index","CPUTensor","prototype","k","M","aTranspose","bTranspose","cMMult","cOMult","n","result","ix","indexY","outputShape","incrementIndex","res","primeFactors","num","x","width","height","Operation","BinaryOperation","PoolOperation","ClipOperation","CopyOperation","ExpandOperation","GatherOperation","UpsampleOperation","GPUTensor","gpuConstructor","Dispatcher","WASMTensor","wasmTensor","OnnxNode","ConvNode","nodeTypes","to","arr","loadModel","name","fetch","arrayBuffer","buffer","model","tjs","OnnxModel","noConvertNodes","precision","toGPU","models","imgs","App","props","undefined","scale","gpu","Float32Array","then","console","log","setState","el","document","getElementById","tensor","fromData","slice","cropSize","Math","min","halfSize","floor","widthSliceStart","heightSliceStart","sliced","delete","getImageWidth","state","scaled","upsample","croppedSize","getShape","transposed","transpose","multiplied","multiply","reshaped","reshape","forward","handleResult","showResult","sh","t","copy","getValues","context","getContext","id","createImageData","d","data","length","pos","round","putImageData","ev","img","URL","createObjectURL","target","files","className","htmlFor","onChange","setModel","value","map","type","fileSelected","src","onClick","setImage","alt","max","defaultValue","parseInt","currentTarget","getImageData","React","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c20a2884.chunk.js","sourcesContent":["export function getSize(shape) {\n    if (shape.length === 0) {\n        return 0;\n    }\n    var size = 1;\n    for (var i = 0; i < shape.length; i += 1) {\n        size *= shape[i];\n    }\n    return size;\n}\nexport function computeStrides(shape) {\n    var rank = shape.length;\n    if (rank === 0) {\n        return [];\n    }\n    if (rank === 1) {\n        if (shape[0] === 1) {\n            return [0];\n        }\n        else {\n            return [1];\n        }\n    }\n    var strides = new Array(rank);\n    strides[rank - 1] = 1;\n    if (shape[rank - 1] === 1) {\n        strides[rank - 1] = 0;\n    }\n    var lastStride = 1;\n    for (var i = rank - 2; i >= 0; i -= 1) {\n        lastStride = shape[i + 1] * lastStride;\n        if (shape[i] === 1) {\n            strides[i] = 0;\n        }\n        else {\n            strides[i] = lastStride;\n        }\n    }\n    return strides;\n}\nexport function indexToPos(index, strides, shape) {\n    var ix = 0;\n    for (var i = 0; i < index.length; i += 1) {\n        if (shape) {\n            if (index[i] < 0 || (index[i] >= shape[i] && shape[i] !== 1)) {\n                throw new Error('Invalid index');\n            }\n        }\n        ix += index[i] * strides[i];\n    }\n    return ix;\n}\nexport function posToIndex(pos, strides) {\n    var res = pos;\n    var rank = strides.length;\n    var index = new Array(rank);\n    for (var i = 0; i < index.length; i += 1) {\n        index[i] = Math.floor(res / strides[i]);\n        res %= strides[i];\n    }\n    return index;\n}\nexport function compareShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function checkEquivShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i] && a[i] !== 1 && b[i] !== 1) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function incrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] += 1;\n        if (index[i] >= shape[i]) {\n            index[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function decrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] -= 1;\n        if (index[i] < 0) {\n            index[i] = shape[i] - 1;\n        }\n        else {\n            break;\n        }\n    }\n}\n//# sourceMappingURL=shape.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { compareShapes, getSize } from './util/shape';\nvar Tensor = /** @class */ (function () {\n    function Tensor() {\n    }\n    /**\n     * Compares this tensor to another tensor.\n     *\n     * @param tensor Tensor to compare to\n     * @param epsilon Optional maximum difference between the tensors. If not specified the tensors have to be exactly equal\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2], [1,2,3,4]);\n     * const b = new CPUTensor([2,2], [1.1,2.1,2.9,4.05]);\n     * const c = new CPUTensor([4], [1,2,3,4]);\n     * a.compare(b, 0.5).then(equal => {\n     *  //equal will be true\n     * });\n     *\n     * a.compare(b).then(equal => {\n     *  //equal will be false\n     * });\n     *\n     * a.compare(c).then(equal => {\n     *  //equal will be false since the shapes of the tensors do not match\n     * });\n     * ```\n     */\n    Tensor.prototype.compare = function (tensor, epsilon) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arrA, arrB, i, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!compareShapes(this.getShape(), tensor.getShape())) {\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.getValues()];\n                    case 1:\n                        arrA = _a.sent();\n                        return [4 /*yield*/, tensor.getValues()];\n                    case 2:\n                        arrB = _a.sent();\n                        if (epsilon !== undefined) {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (Math.abs(arrA[i] - arrB[i]) > epsilon) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        else {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (arrA[i] !== arrB[i]) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    Tensor.prototype.getAxes = function (axes) {\n        var ax;\n        var sh = this.getShape();\n        if (axes === undefined) {\n            ax = [];\n            for (var i = 0; i < sh.length; i++) {\n                ax.push(i);\n            }\n        }\n        else if (!(axes instanceof Array)) {\n            ax = [axes];\n        }\n        else {\n            ax = axes;\n        }\n        return ax;\n    };\n    /**\n     * Sums over the specified axis/axes.\n     *\n     * @param axes One or multiple axes to sum over. If not specified this will sum over all axes\n     * @param keepDims Wether the summation axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.sum(); //Will be [21]\n     * a.sum(0); //Will be [5,7,9]\n     * a.sum(1); //Will [6,15]\n     * a.sum(0, true); //Will be [[5,7,9]]\n     * ```\n     */\n    Tensor.prototype.sum = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sum_impl(ax, keepDims);\n    };\n    /**\n     * Sums over the specified axis/axes with the entries of the tensor squared.\n     * This is equal to `a.multiply(a).sum(axes, keepDims)` but faster\n     *\n     * @param axes One or multiple axes to sum over. If not specified this will sum over all axes\n     * @param keepDims Wether the summation axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.sumSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sumSquare_impl(ax, keepDims);\n    };\n    /**\n     * Takes the product over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the product over. If not specified this will be all axes\n     * @param keepDims Wether the product axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.product(); //Will be [720]\n     * a.product(0); //Will be [4,10,18]\n     * a.product(1); //Will [6,120]\n     * a.product(0, true); //Will be [[4,10,18]]\n     * ```\n     */\n    Tensor.prototype.product = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.product_impl(ax, keepDims);\n    };\n    /**\n     * Takes the maximum over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the maximum over. If not specified this will be all axes\n     * @param keepDims Wether the maximum axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.max(); //Will be [6]\n     * a.max(0); //Will be [4,5,6]\n     * a.max(1); //Will [3,6]\n     * a.max(0, true); //Will be [[4,5,6]]\n     * ```\n     */\n    Tensor.prototype.max = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.max_impl(ax, keepDims);\n    };\n    /**\n     * Takes the minimum over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the minimum over. If not specified this will be all axes\n     * @param keepDims Wether the minimum axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.min(); //Will be [1]\n     * a.min(0); //Will be [1,2,3]\n     * a.min(1); //Will [1,4]\n     * a.min(0, true); //Will be [[1,2,3]]\n     * ```\n     */\n    Tensor.prototype.min = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.min_impl(ax, keepDims);\n    };\n    /**\n     * Takes the mean over the specified axis/axes.\n     * This is equal to `a.sum(axes, keepDims).divide(sumSize)` (where sumSize is the number\n     * of entries in the summation axes) but faster.\n     *\n     * @param axes One or multiple axes to take the mean over. If not specified this will take the mean over all axes\n     * @param keepDims Wether the mean axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.reduceMean = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMean_impl(ax, keepDims);\n    };\n    /**\n     * Takes the mean over the specified axis/axes with the entries of the tensor squared.\n     * This is equal to `a.multiply(a).sum(axes, keepDims).divide(sumSize)` (where sumSize is the number\n     * of entries in the summation axes) but faster.\n     *\n     * @param axes One or multiple axes to take the mean over. If not specified this will take the mean over all axes\n     * @param keepDims Wether the mean axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.reduceMeanSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMeanSquare_impl(ax, keepDims);\n    };\n    /**\n     * Convolves this tensor with the specified kernel.\n     *\n     * This tensor should have shape [N,C,D1,D2,...] where D1,D2,... are the spatial dimensions.\n     *\n     * Behaves according to https://github.com/onnx/onnx/blob/master/docs/Operators.md#Conv\n     *\n     * @param kernel Convolution kernel with shape [M,C/G,K1,K2] where G is the group parameter\n     * @param bias Optional bias to add to the result with shape [M]\n     * @param dilations Per axis dilations for the spatial dimension. Defaults to 1 for all axes\n     * @param group Group parameter\n     * @param pads Padding to add to the input for each spatial dimension. Defaults to 0 for all axes\n     * @param strides Convolution stride for each spatial dimension. Defaults to 1 for all axes\n     * @param activation Optional activation to apply. Defaults to the identity (so no activation)\n     */\n    Tensor.prototype.conv = function (kernel, bias, dilations, group, pads, strides, activation) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        dilations = dilations || new Array(dataRank).fill(1);\n        group = group || 1;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        if (activation === undefined) {\n            activation = \"id\";\n        }\n        return this.conv_impl(kernel, dilations, group, pads, strides, bias, activation);\n    };\n    /**\n     * Pads the input according to the padding mode. The input has shape [D1,D2,..]\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * a.pad([1,1,1,1],'constant',5);\n     * //Result will be:\n     * // [[5,5,5,5],\n     * //  [5,1,2,5],\n     * //  [5,3,4,5],\n     * //  [5,5,5,5]]\n     * a.pad([1,1,1,1],'edge');\n     * //Result will be:\n     * // [[1,1,2,2],\n     * //  [1,1,2,2],\n     * //  [3,3,4,4],\n     * //  [3,3,4,4]]\n     *\n     * a.pad([2,2,2,2],'reflect');\n     * //Result will be:\n     * // [[4,3,3,4,4,3],\n     * //  [2,1,1,2,2,1],\n     * //  [2,1,1,2,2,1],\n     * //  [4,3,3,4,4,3],\n     * //  [4,3,3,4,4,3],\n     * //  [2,1,1,2,2,1]]\n     * ```\n     *\n     * @param pads Padding size of each input. Specified as [startpad_D1,startpad_D2,...,startpad_DN,endpad_D1,endpad_D2,...]\n     * @param mode Padding mode. One of 'constant', 'edge', 'reflect'. Defaults to 'constant'\n     * @param value Value for constant padding. Defaults to 0.0\n     */\n    Tensor.prototype.pad = function (pads, mode, value) {\n        if (mode === undefined) {\n            mode = 'constant';\n        }\n        if (value === undefined) {\n            value = 0;\n        }\n        return this.pad_impl(pads, mode, value);\n    };\n    /**\n     * Performs average pooling over the spatial dimensions of this tensor with\n     * shape [N,C,D1,D2,..]\n     * @param kernelShape Size of the average pooling dimension\n     * @param pads Padding of the input specified as [startpad_D1,startpad_D2,...,startpad_DN,endpad_D1,endpad_D2,...]\n     *             Padding value will be 0. Defaults to 0 for all axes\n     * @param strides Stride size of the average pooling kernel. Defaults to 1 for all axes\n     * @param includePad Wether padded values should be included in the average (or masked out). Defaults to false\n     */\n    Tensor.prototype.averagePool = function (kernelShape, pads, strides, includePad) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        includePad = includePad || false;\n        return this.averagePool_impl(kernelShape, pads, strides, includePad);\n    };\n    /**\n     * Reshape the tensor to the specified shape\n     *\n     * At most one value in the shape can be -1, which will be replaced by the inferred size for this dimension.\n     *\n     * @param shape New shape of the tensor\n     * @param copy Wether the tensor values should be copied. Only has an effect on GPU tensors\n     */\n    Tensor.prototype.reshape = function (shape, copy) {\n        var shSize = 1;\n        var negIndex = -1;\n        for (var i = 0; i < shape.length; i++) {\n            if (shape[i] === -1) {\n                negIndex = i;\n            }\n            else {\n                shSize *= shape[i];\n            }\n        }\n        if (copy === undefined) {\n            copy = true;\n        }\n        if (negIndex !== -1) {\n            var currShape = this.getShape();\n            var currSize = getSize(currShape);\n            var _shape = __spreadArrays(shape);\n            _shape[negIndex] = currSize / shSize;\n            return this.reshape_impl(_shape, copy);\n        }\n        return this.reshape_impl(shape, copy);\n    };\n    Tensor.prototype.alignShapes = function (shape1, shape2) {\n        var _a, _b;\n        if (compareShapes(shape1, shape2)) {\n            return [shape1, shape2, shape1];\n        }\n        if (shape1.length < shape2.length) {\n            shape1 = __spreadArrays(shape1);\n            var prepend = shape2.length - shape1.length;\n            (_a = shape1).unshift.apply(_a, new Array(prepend).fill(1));\n        }\n        else if (shape2.length < shape1.length) {\n            shape2 = __spreadArrays(shape2);\n            var prepend = shape1.length - shape2.length;\n            (_b = shape2).unshift.apply(_b, new Array(prepend).fill(1));\n        }\n        var resultShape = new Array(shape1.length).fill(1);\n        for (var i = 0; i < shape1.length; i++) {\n            resultShape[i] = Math.max(shape1[i], shape2[i]);\n        }\n        return [shape1, shape2, resultShape];\n    };\n    /**\n     * Align the shapes of this tensor and the given tensor according to\n     * the broadcasting rules:\n     * https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md\n     *\n     * @param tensor Tensor of which the shapes should be aligned\n     */\n    Tensor.prototype.alignTensor = function (tensor) {\n        var _a, _b;\n        var thisShape = this.getShape();\n        var thatShape = tensor.getShape();\n        if (compareShapes(thisShape, thatShape)) {\n            return [this, tensor, thisShape];\n        }\n        var th = this;\n        if (thisShape.length < thatShape.length) {\n            thisShape = __spreadArrays(thisShape);\n            var prepend = thatShape.length - thisShape.length;\n            (_a = thisShape).unshift.apply(_a, new Array(prepend).fill(1));\n            th = this.reshape(thisShape, false);\n        }\n        else if (thatShape.length < thisShape.length) {\n            thatShape = __spreadArrays(thatShape);\n            var prepend = thisShape.length - thatShape.length;\n            (_b = thatShape).unshift.apply(_b, new Array(prepend).fill(1));\n            tensor = tensor.reshape(thatShape, false);\n        }\n        var resultShape = new Array(thisShape.length).fill(1);\n        for (var i = 0; i < thisShape.length; i++) {\n            resultShape[i] = Math.max(thisShape[i], thatShape[i]);\n        }\n        return [th, tensor, resultShape];\n    };\n    /**\n     * Adds two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * const b = new CPUTensor([2,2],[5,6,7,8]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.add(b);\n     * //Will be\n     * // [[6,8],\n     * //  [10,12]]\n     *\n     * a.add(c);\n     * //Will be\n     * // [[3,4],\n     * //  [5,6]]\n     * ```\n     */\n    Tensor.prototype.add = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.add_impl(th, tens, resultShape);\n    };\n    /**\n     * Subtracts two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[1,2,3,4]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.subtract(b);\n     * //Will be\n     * // [[4,4],\n     * //  [4,4]]\n     *\n     * a.subtract(c);\n     * //Will be\n     * // [[3,4],\n     * //  [5,6]]\n     * ```\n     */\n    Tensor.prototype.subtract = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.subtract_impl(th, tens, resultShape);\n    };\n    /**\n     * Multiplies two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * const b = new CPUTensor([2,2],[5,6,7,8]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.multiply(b);\n     * //Will be\n     * // [[5,12],\n     * //  [21,32]]\n     *\n     * a.multiply(c);\n     * //Will be\n     * // [[2,4]\n     *     [6,8]]\n     * ```\n     */\n    Tensor.prototype.multiply = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.multiply_impl(th, tens, resultShape);\n    };\n    /**\n     * Divides two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[1,2,3,4]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.divide(b);\n     * //Will be\n     * // [[5,3],\n     * //  [2.333,2]]\n     *\n     * a.divide(c);\n     * //Will be\n     * // [[2.5,3],\n     * //  [3.5,4]]\n     * ```\n     */\n    Tensor.prototype.divide = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.divide_impl(th, tens, resultShape);\n    };\n    /**\n     * Takes the positionwise power. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[2,3,2,3]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.power(b);\n     * //Will be\n     * // [[25,216],\n     * //  [49,512]]\n     *\n     * a.power(c);\n     * //Will be\n     * // [[25,36],\n     * //  [49,64]]\n     * ```\n     */\n    Tensor.prototype.power = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.power_impl(th, tens, resultShape);\n    };\n    /**\n     * Transposes the tensor according to the given permutation\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     *\n     * a.transpose();\n     * //Will be\n     * // [[5,7],\n     * //  [6,8]]\n     * ```\n     * @param permutation Permutation for the axes. Default is the reverse axis order\n     */\n    Tensor.prototype.transpose = function (permutation) {\n        if (permutation === undefined) {\n            var shape = this.getShape();\n            var rank = shape.length;\n            permutation = [];\n            for (var i = 0; i < rank; i++) {\n                permutation.push(rank - i - 1);\n            }\n        }\n        return this.transpose_impl(permutation);\n    };\n    /**\n     * Takes the softmax along the given axis\n     * https://en.wikipedia.org/wiki/Softmax_function\n     */\n    Tensor.prototype.softmax = function (axis) {\n        var max = this.max(axis, true);\n        var normalized = this.subtract(max);\n        var exp = normalized.exp();\n        var sum = exp.sum(axis, true);\n        var result = exp.divide(sum);\n        max.delete();\n        normalized.delete();\n        exp.delete();\n        sum.delete();\n        return result;\n    };\n    /**\n     * Calculates the general matrix product.\n     * https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_3\n     *\n     * A and B can have batch dimensions. Their last two dimensions should\n     * correspond to the dimensions for the matrix product\n     *\n     * @param b Second matrix for the matrix product\n     * @param aTranspose If the last two dimensions of a are transposed. Defaults to false\n     * @param bTranspose If the last two dimensions of a are transposed. Defaults to false\n     * @param alpha Alpha parameter. Defaults to 1.0\n     * @param c Optional tensor to add to the result.\n     * @param beta Beta parameter, only used if c is specified. Defaults to 1.0\n     */\n    Tensor.prototype.gemm = function (b, aTranspose, bTranspose, alpha, c, beta) {\n        aTranspose = aTranspose || false;\n        bTranspose = bTranspose || false;\n        alpha = alpha !== undefined ? alpha : 1;\n        beta = beta !== undefined ? beta : 1;\n        if (c !== undefined) {\n            var aShape = this.getShape();\n            var cShape = c.getShape();\n            var aRank = aShape.length;\n            var cRank = cShape.length;\n            cShape = __spreadArrays(new Array(aRank - cRank).fill(1), cShape);\n            c = c.reshape(cShape, false);\n        }\n        return this.gemm_impl(b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    /**\n     * Takes a slice of the tensor along the specified axes.\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     *\n     * a.slice([0],[1],[0]);\n     * //Will be\n     * // [[5,6]]\n     *\n     * a.slice([0],[1],[1]);\n     * //Will be\n     * // [[5],\n     *     [6]]\n     * ```\n     *\n     * @param starts Start of the slice for each axis\n     * @param ends End of the slice for each axis - Exclusive (the end index will not be included in the slice)\n     * @param axes Axes to slice. Defaults to all axes\n     */\n    Tensor.prototype.slice = function (starts, ends, axes) {\n        var shape = this.getShape();\n        var rank = shape.length;\n        if (axes === undefined) {\n            axes = [];\n            for (var i = 0; i < rank; i++) {\n                axes.push(i);\n            }\n        }\n        starts = __spreadArrays(starts);\n        ends = __spreadArrays(ends);\n        for (var i = 0; i < axes.length; i++) {\n            var sh = shape[axes[i]];\n            if (starts[i] < 0) {\n                starts[i] += sh;\n            }\n            else if (starts[i] >= sh) {\n                starts[i] = sh;\n            }\n            if (ends[i] < 0) {\n                ends[i] += sh;\n            }\n            else if (ends[i] >= sh) {\n                ends[i] = sh;\n            }\n        }\n        return this.slice_impl(starts, ends, axes);\n    };\n    return Tensor;\n}());\nexport default Tensor;\n//# sourceMappingURL=types.js.map","export function outputDimSize(inSize, kernel, headPad, tailPad, dilation, stride) {\n    var dkernel = dilation * (kernel - 1) + 1;\n    return Math.floor(((inSize + headPad + tailPad - dkernel) / stride) + 1);\n}\nexport function outputDimsSize(inSizes, kernels, headPads, tailPads, dilations, strides) {\n    var result = [];\n    for (var i = 0; i < inSizes.length; i++) {\n        result.push(outputDimSize(inSizes[i], kernels[i], headPads[i], tailPads[i], dilations[i], strides[i]));\n    }\n    return result;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { checkEquivShapes, incrementIndex } from '../../util/shape';\nexport function positionWiseUnaryOp(a, op) {\n    var result = new CPUTensor(a.shape);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(i, op(a.get(i)));\n    }\n    return result;\n}\nexport function positionWiseBinaryOp(a, b, op, resultShape) {\n    if (!checkEquivShapes(a.shape, b.shape)) {\n        throw new Error('The shapes of the two tensors should be the same for a binary operation');\n    }\n    var result = new CPUTensor(resultShape);\n    var index = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(index, op(a.get(index), b.get(index)));\n        incrementIndex(index, resultShape);\n    }\n    return result;\n}\nexport function exp(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.exp(o1); });\n}\nexport function log(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.log(o1); });\n}\nexport function sqrt(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.sqrt(o1); });\n}\nexport function abs(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.abs(o1); });\n}\nexport function floor(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.floor(o1); });\n}\nexport function ceil(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.ceil(o1); });\n}\nexport function clip(a, min, max) {\n    var f = function (o1) { return o1; };\n    if (min !== undefined && max !== undefined) {\n        f = function (o1) { return Math.min(max, Math.max(min, o1)); };\n    }\n    else if (max !== undefined) {\n        f = function (o1) { return Math.min(max, o1); };\n    }\n    else if (min !== undefined) {\n        f = function (o1) { return Math.max(min, o1); };\n    }\n    return positionWiseUnaryOp(a, f);\n}\nexport function add(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 + o2; }, resultShape);\n}\nexport function subtract(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 - o2; }, resultShape);\n}\nexport function multiply(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 * o2; }, resultShape);\n}\nexport function divide(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 / o2; }, resultShape);\n}\nexport function power(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return Math.pow(o1, o2); }, resultShape);\n}\n//# sourceMappingURL=basic.js.map","export function poolResultShape(inputShape, axes, keepDims) {\n    var resultShape = [];\n    var sumShape = [];\n    var ixMap = [];\n    for (var i = 0; i < inputShape.length; i++) {\n        if (!axes.includes(i)) {\n            resultShape.push(inputShape[i]);\n            ixMap.push(i);\n        }\n        else {\n            if (keepDims) {\n                resultShape.push(1);\n                ixMap.push(i);\n            }\n            sumShape.push(inputShape[i]);\n        }\n    }\n    if (resultShape.length === 0) {\n        resultShape.push(1);\n    }\n    return [resultShape, ixMap];\n}\n//# sourceMappingURL=pool.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex, indexToPos, computeStrides } from '../../util/shape';\nimport { poolResultShape } from '../util/pool';\nexport function pool(a, axes, operation, keepDims, postProcess) {\n    var inputShape = a.getShape();\n    var inputSize = getSize(inputShape);\n    var _a = poolResultShape(inputShape, axes, keepDims), resultShape = _a[0], ixMap = _a[1];\n    var resultSize = getSize(resultShape);\n    var resultStrides = computeStrides(resultShape);\n    var result = new CPUTensor(resultShape);\n    var initialized = new Array(resultSize).fill(false);\n    var index = new Array(inputShape.length).fill(0);\n    var outIndex = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < inputSize; i++) {\n        for (var j = 0; j < ixMap.length; j++) {\n            outIndex[j] = index[ixMap[j]];\n        }\n        var outOffset = indexToPos(outIndex, resultStrides);\n        if (initialized[outOffset]) {\n            result.set(outIndex, operation(a.get(i), result.get(outIndex)));\n        }\n        else {\n            initialized[outOffset] = true;\n            result.set(outIndex, operation(a.get(i)));\n        }\n        incrementIndex(index, inputShape);\n    }\n    if (postProcess) {\n        for (var i = 0; i < result.size; i++) {\n            result.set(i, postProcess(result.get(i)));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=pool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function pad(x, pads, mode, value) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] += pads[i] + pads[i + rank];\n    }\n    var Y = new CPUTensor(resultShape);\n    var ix = new Array(rank).fill(0);\n    var inputIx = new Array(rank).fill(0);\n    for (var i = 0; i < Y.size; i++) {\n        var allInRange = true;\n        for (var j = 0; j < rank; j++) {\n            inputIx[j] = ix[j] - pads[j];\n            if (inputIx[j] < 0 || inputIx[j] >= x.shape[j]) {\n                allInRange = false;\n            }\n        }\n        Y.set(i, getPadValue(x, inputIx, mode, value, allInRange));\n        incrementIndex(ix, resultShape);\n    }\n    return Y;\n}\nfunction getPadValue(x, index, mode, value, allInRange) {\n    if (allInRange) {\n        return x.get(index);\n    }\n    var rank = x.shape.length;\n    if (mode === 'constant') {\n        return value;\n    }\n    else if (mode === 'edge') {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = 0;\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = x.shape[j] - 1;\n            }\n        }\n    }\n    else {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = -index[j];\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = 2 * x.shape[j] - index[j] - 2;\n            }\n        }\n    }\n    return x.get(index);\n}\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { averagePool } from '../../ops/cpu/averagePool';\nimport { abs, add, ceil, clip, divide, exp, floor, log, multiply, power, sqrt, subtract } from '../../ops/cpu/basic';\nimport { concat } from '../../ops/cpu/concat';\nimport { conv } from '../../ops/cpu/conv';\nimport { expand } from '../../ops/cpu/expand';\nimport { gather } from '../../ops/cpu/gather';\nimport { gemm } from '../../ops/cpu/gemm';\nimport { matMul } from '../../ops/cpu/matMul';\nimport { max } from '../../ops/cpu/max';\nimport { min } from '../../ops/cpu/min';\nimport { normalize } from '../../ops/cpu/normalize';\nimport { pad } from '../../ops/cpu/pad';\nimport { product } from '../../ops/cpu/product';\nimport { reduceMean } from '../../ops/cpu/reduceMean';\nimport { reduceMeanSquare } from '../../ops/cpu/reduceMeanSquare';\nimport { repeat } from '../../ops/cpu/repeat';\nimport { slice } from '../../ops/cpu/slice';\nimport { sum } from '../../ops/cpu/sum';\nimport { sumSquare } from '../../ops/cpu/sumSquare';\nimport { transpose } from '../../ops/cpu/transpose';\nimport { upsample } from '../../ops/cpu/upsample';\nimport Tensor from '../../types';\nimport { compareShapes, computeStrides, getSize, indexToPos } from '../../util/shape';\nvar CPUTensor = /** @class */ (function (_super) {\n    __extends(CPUTensor, _super);\n    function CPUTensor(shape, values, type) {\n        var _this = _super.call(this) || this;\n        _this.deleted = false;\n        _this.shape = shape;\n        _this.strides = computeStrides(shape);\n        _this.size = getSize(shape);\n        if (values !== undefined) {\n            if (values instanceof Float32Array || values instanceof Int32Array) {\n                _this.values = values;\n                _this.type = values instanceof Float32Array ? \"float\" : \"int\";\n            }\n            else if (type === \"int\") {\n                _this.values = Int32Array.from(values);\n                _this.type = \"int\";\n            }\n            else if (values === null) {\n                //Prototype tensor that wont hold any data, but can be used for static inference in ONNX models\n                _this.values = null;\n            }\n            else {\n                _this.values = Float32Array.from(values);\n                _this.type = \"float\";\n            }\n        }\n        else {\n            if (type === \"int\") {\n                _this.values = new Int32Array(_this.size);\n                _this.type = \"int\";\n            }\n            else {\n                _this.values = new Float32Array(_this.size);\n                _this.type = \"float\";\n            }\n        }\n        return _this;\n    }\n    CPUTensor.prototype.getValues = function () {\n        return Promise.resolve(this.values);\n    };\n    CPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    CPUTensor.prototype.cpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    CPUTensor.prototype.delete = function () {\n        this.values = undefined;\n        this.deleted = true;\n    };\n    CPUTensor.prototype.copy = function (newShape) {\n        if (newShape === undefined) {\n            newShape = __spreadArrays(this.shape);\n        }\n        var values = new Float32Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            values[i] = this.values[i];\n        }\n        return new CPUTensor(newShape, values);\n    };\n    CPUTensor.prototype.get = function (index) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides, this.shape);\n        }\n        else {\n            pos = index;\n        }\n        return this.values[pos];\n    };\n    CPUTensor.prototype.set = function (index, value) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides);\n        }\n        else {\n            pos = index;\n        }\n        this.values[pos] = value;\n    };\n    CPUTensor.prototype.exp = function () {\n        return exp(this);\n    };\n    CPUTensor.prototype.log = function () {\n        return log(this);\n    };\n    CPUTensor.prototype.sqrt = function () {\n        return sqrt(this);\n    };\n    CPUTensor.prototype.abs = function () {\n        return abs(this);\n    };\n    CPUTensor.prototype.floor = function () {\n        return floor(this);\n    };\n    CPUTensor.prototype.ceil = function () {\n        return ceil(this);\n    };\n    CPUTensor.prototype.clip = function (min, max) {\n        return clip(this, min, max);\n    };\n    CPUTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return add(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only subtract CPU tensor to CPU tensor');\n        }\n        return subtract(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return multiply(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return divide(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only take CPU tensor to power of CPU tensor');\n        }\n        return power(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return matMul(this, tensor);\n    };\n    CPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof CPUTensor && (c === undefined || c instanceof CPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        return gemm(this, b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    CPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return sum(this, axes, keepDims);\n    };\n    CPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return sumSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return product(this, axes, keepDims);\n    };\n    CPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return max(this, axes, keepDims);\n    };\n    CPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return min(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return reduceMean(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return reduceMeanSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias) {\n        if (!(kernel instanceof CPUTensor) || (bias !== undefined && !(bias instanceof CPUTensor))) {\n            throw new Error('Can only do convolution of CPU tensor with CPU tensor');\n        }\n        return conv(this, kernel, dilations, group, pads, strides, bias);\n    };\n    CPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return pad(this, pads, mode, value);\n    };\n    CPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return averagePool(this, kernelShape, pads, strides, includePad);\n    };\n    CPUTensor.prototype.reshape_impl = function (shape, copy) {\n        if (copy) {\n            return this.copy(shape);\n        }\n        else {\n            return new CPUTensor(shape, this.values, this.type);\n        }\n    };\n    CPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only concat CPU tensor to CPU tensor');\n        }\n        return concat(this, tensor, axis);\n    };\n    CPUTensor.prototype.transpose_impl = function (permutation) {\n        return transpose(this, permutation);\n    };\n    CPUTensor.prototype.repeat = function (repeats) {\n        return repeat(this, repeats);\n    };\n    CPUTensor.prototype.expand = function (shape) {\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return expand(this.reshape(_shape, false), resultShape);\n    };\n    CPUTensor.prototype.gather = function (axis, indices) {\n        return gather(this, axis, indices);\n    };\n    CPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return slice(this, starts, ends, axes);\n    };\n    CPUTensor.prototype.upsample = function (scales) {\n        return upsample(this, scales);\n    };\n    CPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof CPUTensor) || !(variance instanceof CPUTensor) || !(scale instanceof CPUTensor) || !(bias instanceof CPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return normalize(this, mean, variance, epsilon, scale, bias);\n    };\n    return CPUTensor;\n}(Tensor));\nexport { CPUTensor };\n//# sourceMappingURL=tensor.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nexport function matMul(a, b) {\n    if (a.shape.length !== 2 || b.shape.length !== 2) {\n        throw new Error('Matmul expects both operands to have rank 2');\n    }\n    if (a.shape[1] !== b.shape[0]) {\n        throw new Error('Matmul expects dimension 1 of operand 1 to equal dimension 0 of operand 2');\n    }\n    var m = a.shape[0];\n    var n = a.shape[1];\n    var o = b.shape[1];\n    var result = new CPUTensor([m, o]);\n    for (var i = 0; i < m; i += 1) {\n        for (var k = 0; k < o; k += 1) {\n            var res = 0;\n            for (var j = 0; j < n; j += 1) {\n                res += a.get([i, j]) * b.get([j, k]);\n            }\n            result.set([i, k], res);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=matMul.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize } from '../../util/shape';\nexport function gemm(a, b, aTranspose, bTranspose, alpha, beta, c) {\n    var rank = a.shape.length;\n    var M = aTranspose ? a.shape[rank - 1] : a.shape[rank - 2];\n    var N = aTranspose ? a.shape[rank - 2] : a.shape[rank - 1];\n    var O = bTranspose ? b.shape[rank - 2] : b.shape[rank - 1];\n    var aBatchMult = M * N;\n    var bBatchMult = N * O;\n    var yBatchMult = M * O;\n    var aNMult = aTranspose ? M : 1;\n    var aMMult = aTranspose ? 1 : N;\n    var bNMult = bTranspose ? 1 : O;\n    var bOMult = bTranspose ? N : 1;\n    var cMMult = 0;\n    var cOMult = 0;\n    var cBatchMult = 0;\n    if (c !== undefined) {\n        cMMult = c.strides[rank - 2];\n        cOMult = c.strides[rank - 1];\n        var cBatchSize = getSize(c.shape.slice(0, rank - 2));\n        if (cBatchSize > 1) {\n            cBatchMult = c.shape[rank - 2] * c.shape[rank - 1];\n            if (cBatchMult === 1) {\n                cBatchMult = 0;\n            }\n        }\n        else {\n            cBatchMult = 0;\n        }\n    }\n    var batchShape = a.shape.slice(0, rank - 2);\n    var batchSize = getSize(batchShape);\n    if (batchSize === 0) {\n        batchSize = 1;\n    }\n    var resultShape = __spreadArrays(batchShape, [M, O]);\n    var Y = new CPUTensor(resultShape);\n    for (var i = 0; i < batchSize; i++) {\n        var aBase = i * aBatchMult;\n        var bBase = i * bBatchMult;\n        var yBase = i * yBatchMult;\n        var cBase = i * cBatchMult;\n        for (var m = 0; m < M; m++) {\n            for (var o = 0; o < O; o++) {\n                var result = 0;\n                for (var n = 0; n < N; n++) {\n                    result += a.get(aBase + m * aMMult + n * aNMult) * b.get(bBase + n * bNMult + o * bOMult);\n                }\n                result = alpha * result;\n                if (c !== undefined) {\n                    result += beta * c.get(cBase + m * cMMult + o * cOMult);\n                }\n                Y.set(yBase + m * O + o, result);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=gemm.js.map","import { pool } from './pool';\nexport function sum(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sum.js.map","import { pool } from './pool';\nexport function sumSquare(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return (a * a) + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sumSquare.js.map","import { pool } from './pool';\nexport function product(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a * (b !== undefined ? b : 1);\n    }, keepDims);\n}\n//# sourceMappingURL=product.js.map","import { pool } from './pool';\nexport function max(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.max(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=max.js.map","import { pool } from './pool';\nexport function min(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.min(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=min.js.map","import { pool } from './pool';\nexport function reduceMean(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMean.js.map","import { pool } from './pool';\nexport function reduceMeanSquare(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return (a * a) + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMeanSquare.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function conv(x, w, dilations, group, pads, strides, bias) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var W = w.shape.slice(2);\n    var M = w.shape[0];\n    var CG = C / group;\n    var kernelSize = getSize(W);\n    var R = outputDimsSize(D, W, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), dilations, strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, M];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    var dataRank = R.length;\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var m = 0; m < M; m++) {\n            if (bias) {\n                var b = bias ? bias.get([m]) : 0;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    Y.set(outputIndices, b);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n            for (var cg = 0; cg < CG; cg++) {\n                var c = (m * CG + cg) % C;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    var result = Y.get(outputIndices);\n                    var kernelIndices = new Array(R.length).fill(0);\n                    kernelIndices.unshift(m, cg);\n                    for (var kIx = 0; kIx < kernelSize; kIx++) {\n                        var inputIx = [n, c];\n                        var skip = false;\n                        for (var axis = 0; axis < dataRank; axis++) {\n                            var stride = strides.length === 0 ? 1 : strides[axis];\n                            var pad = pads.length === 0 ? 0 : pads[axis];\n                            var dilation = dilations.length === 0 ? 1 : dilations[axis];\n                            var ix = outputIndices[axis + 2] * stride - pad + kernelIndices[axis + 2] * dilation;\n                            if (ix < 0 || ix >= D[axis]) {\n                                skip = true;\n                                break;\n                            }\n                            inputIx.push(ix);\n                        }\n                        if (!skip) {\n                            var Wi = w.get(kernelIndices);\n                            var Xi = x.get(inputIx);\n                            result += Wi * Xi;\n                        }\n                        incrementIndex(kernelIndices, w.shape);\n                    }\n                    Y.set(outputIndices, result);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function averagePool(x, kernelShape, pads, strides, includePad) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var dataRank = D.length;\n    var kernelSize = getSize(kernelShape);\n    var R = outputDimsSize(D, kernelShape, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), new Array(dataRank).fill(1), strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, C];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var c = 0; c < C; c++) {\n            var outputIndices = new Array(R.length).fill(0);\n            outputIndices.unshift(n, c);\n            for (var oIx = 0; oIx < outputSize; oIx++) {\n                var result = 0;\n                var kernelIndices = new Array(R.length).fill(0);\n                var count = 0;\n                for (var kIx = 0; kIx < kernelSize; kIx++) {\n                    var inputIx = [n, c];\n                    var skip = false;\n                    for (var axis = 0; axis < dataRank; axis++) {\n                        var stride = strides.length === 0 ? 1 : strides[axis];\n                        var pad = pads.length === 0 ? 0 : pads[axis];\n                        var ix = outputIndices[axis + 2] * stride - pad + kernelIndices[axis];\n                        if (ix < 0 || ix >= D[axis]) {\n                            skip = true;\n                            break;\n                        }\n                        inputIx.push(ix);\n                    }\n                    if (!skip) {\n                        var Xi = x.get(inputIx);\n                        result += Xi;\n                    }\n                    if (!skip || includePad) {\n                        count += 1;\n                    }\n                    incrementIndex(kernelIndices, kernelShape);\n                }\n                result = result / count;\n                Y.set(outputIndices, result);\n                incrementIndex(outputIndices, Y.shape);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=averagePool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nexport function concat(x, y, axis) {\n    var outputShape = __spreadArrays(x.shape);\n    outputShape[axis] += y.shape[axis];\n    var result = new CPUTensor(outputShape);\n    var indexX = 0;\n    var indexY = 0;\n    var ix = 0;\n    var iterXSize = result.strides[axis] * x.shape[axis];\n    var iterYSize = result.strides[axis] * y.shape[axis];\n    var outerIters = result.size / (axis > 0 ? result.strides[axis - 1] : result.size);\n    for (var i = 0; i < outerIters; i++) {\n        for (var j = 0; j < iterXSize; j++) {\n            result.set(ix, x.get(indexX));\n            ix++;\n            indexX++;\n        }\n        for (var j = 0; j < iterYSize; j++) {\n            result.set(ix, y.get(indexY));\n            ix++;\n            indexY++;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=concat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function transpose(x, permutation) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    var reversePerm = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[permutation[i]];\n        reversePerm[permutation[i]] = i;\n    }\n    var result = new CPUTensor(outputShape);\n    var resultStrides = result.strides;\n    var mappedStrides = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        mappedStrides[i] = resultStrides[reversePerm[i]];\n    }\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < x.size; i++) {\n        var outIx = 0;\n        for (var j = 0; j < rank; j++) {\n            outIx += index[j] * mappedStrides[j];\n        }\n        result.set(outIx, x.get(i));\n        incrementIndex(index, x.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=transpose.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function repeat(x, repeats) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[i] * repeats[i];\n    }\n    var result = new CPUTensor(outputShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var inIndex = new Array(rank);\n        for (var j = 0; j < rank; j++) {\n            inIndex[j] = index[j] % x.shape[j];\n        }\n        result.set(i, x.get(inIndex));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=repeat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function expand(x, resultShape) {\n    var rank = x.shape.length;\n    var result = new CPUTensor(resultShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        result.set(i, x.get(index));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=expand.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function gather(x, axis, indices) {\n    var r = x.shape.length;\n    var q = indices.shape.length;\n    var resultRank = r + q - 1;\n    var resultShape = new Array(resultRank);\n    for (var i = 0; i < axis; i++) {\n        resultShape[i] = x.shape[i];\n    }\n    for (var i = 0; i < q; i++) {\n        resultShape[i + axis] = indices.shape[i];\n    }\n    for (var i = axis + 1; i < r; i++) {\n        resultShape[i + q - 1] = x.shape[i];\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(resultRank).fill(0);\n    var gatherIx;\n    var inputIx;\n    for (var i = 0; i < result.size; i++) {\n        gatherIx = outIx.slice(axis, axis + q);\n        var axIx = indices.get(gatherIx);\n        inputIx = __spreadArrays(outIx.slice(0, axis), [axIx], outIx.slice(axis + q));\n        result.set(i, x.get(inputIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=gather.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function slice(x, starts, ends, axis) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var axIx = 0;\n    for (var i = 0; i < rank && axIx < axis.length; i++) {\n        if (i == axis[axIx]) {\n            resultShape[i] = ends[axIx] - starts[axIx];\n            axIx++;\n        }\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx;\n    for (var i = 0; i < result.size; i++) {\n        inIx = __spreadArrays(outIx);\n        for (var j = 0; j < axis.length; j++) {\n            inIx[axis[j]] += starts[j];\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=slice.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function upsample(x, scales) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] = Math.floor(resultShape[i] * scales[i]);\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx = new Array(rank);\n    for (var i = 0; i < result.size; i++) {\n        for (var j = 0; j < rank; j++) {\n            inIx[j] = Math.floor(outIx[j] / scales[j]);\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=upsample.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function normalize(x, mean, variance, epsilon, scale, bias) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var res = (x.get(outIx) - mean.get(outIx)) / Math.sqrt(variance.get(outIx) + epsilon);\n        res = res * scale.get(outIx) + bias.get(outIx);\n        result.set(i, res);\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=normalize.js.map","var Dict = /** @class */ (function () {\n    function Dict(toNumber) {\n        this.toNumber = toNumber;\n        this.dict = {};\n    }\n    Dict.prototype.betweenBoundsFirst = function (query) {\n        if (query.gte !== undefined) {\n            var k = this.toNumber(query.gte);\n            if (this.dict[k] !== undefined && this.dict[k].length > 0) {\n                return [{\n                        key: query.gte, value: this.dict[k][this.dict[k].length - 1]\n                    }];\n            }\n            return [];\n        }\n        else if (query.lte !== undefined) {\n            var k = this.toNumber(query.lte);\n            if (this.dict[k] !== undefined && this.dict[k].length > 0) {\n                return [{\n                        key: query.lte, value: this.dict[k][this.dict[k].length - 1]\n                    }];\n            }\n            return [];\n        }\n        return [];\n    };\n    Dict.prototype.deleteFirst = function (key) {\n        var k = this.toNumber(key);\n        if (this.dict[k] !== undefined) {\n            this.dict[k].pop();\n        }\n    };\n    Dict.prototype.insert = function (key, value) {\n        var k = this.toNumber(key);\n        if (this.dict[k] === undefined) {\n            this.dict[k] = [];\n        }\n        this.dict[k].push(value);\n    };\n    return Dict;\n}());\nexport { Dict };\n//# sourceMappingURL=dict.js.map","export function primeFactors(num) {\n    return primeFactorsCompute(num);\n}\nexport function primeFactorsCompute(inputNum, result, repeat) {\n    if (result === void 0) { result = []; }\n    if (repeat === void 0) { repeat = true; }\n    if (!Number.isInteger(inputNum))\n        return result;\n    var num = Math.abs(inputNum);\n    if (num < 2)\n        return result;\n    var sqrt = Math.sqrt(num);\n    var x = 2;\n    if (num % x) {\n        x = 3;\n        if (num % x) {\n            x = 5;\n            var add = 2;\n            while ((num % x) && (x < sqrt)) {\n                // search numbers: 5, 7, 11, 13, 17, 19, 23...\n                x += add;\n                // add each time: 2, 4, 2, 4, 2, 4, 2...\n                add = 6 - add;\n            }\n        }\n    }\n    x = (x <= sqrt) ? x : num;\n    if (!repeat) {\n        var index = result.indexOf(x);\n        if (index < 0)\n            result.push(x);\n    }\n    else\n        result.push(x);\n    return (x === num) ? result : primeFactorsCompute(num / x, result, repeat);\n}\n//# sourceMappingURL=math.js.map","import { primeFactors } from \"../../util/math\";\nvar GPUMemoryAllocator = /** @class */ (function () {\n    function GPUMemoryAllocator(regl, orderedDictConstructor, maxSizeFactor) {\n        this.trees = {\n            16: orderedDictConstructor(),\n            32: orderedDictConstructor()\n        };\n        this.regl = regl;\n        this.entryId = 0;\n        this.maxSizeFactor = maxSizeFactor || 2;\n    }\n    GPUMemoryAllocator.prototype.allocate = function (size, precision) {\n        var upperBound = size * this.maxSizeFactor;\n        var texSize = Math.ceil(size / 4) * 4;\n        if (texSize < upperBound) {\n            upperBound = texSize;\n        }\n        var results = this.trees[precision].betweenBoundsFirst({ gte: size, lte: upperBound });\n        if (results.length === 0) {\n            var textureSize = Math.ceil(size / 4);\n            var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n            var framebuffer = this.regl.framebuffer({\n                width: width,\n                height: height,\n                depthStencil: false,\n                colorFormat: 'rgba',\n                colorType: precision === 32 ? 'float' : 'half float'\n            });\n            var memoryEntry = {\n                width: width,\n                height: height,\n                size: width * height * 4,\n                frameBuffer: framebuffer,\n                id: this.entryId++,\n                precision: precision\n            };\n            return memoryEntry;\n        }\n        else {\n            var first = results[0];\n            this.trees[precision].deleteFirst(first.key);\n            return first.value;\n        }\n    };\n    GPUMemoryAllocator.prototype.getAllocationDimensions = function (size, precision) {\n        var upperBound = size * this.maxSizeFactor;\n        var texSize = Math.ceil(size / 4) * 4;\n        if (texSize < upperBound) {\n            upperBound = texSize;\n        }\n        var results = this.trees[precision].betweenBoundsFirst({ gte: size, lte: upperBound });\n        if (results.length === 0) {\n            var textureSize = Math.ceil(size / 4);\n            return this.getTextureDims(textureSize);\n        }\n        else {\n            var first = results[0];\n            return {\n                width: first.value.width,\n                height: first.value.height\n            };\n        }\n    };\n    GPUMemoryAllocator.prototype.deallocate = function (entry) {\n        this.trees[entry.precision].insert(entry.size, entry);\n    };\n    GPUMemoryAllocator.prototype.allocateTexture = function (values, precision) {\n        var textureSize = Math.ceil(values.length / 4);\n        var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n        var arraySize = width * height * 4;\n        var vals = new Float32Array(arraySize);\n        for (var i = 0; i < values.length; i++) {\n            vals[i] = values[i];\n        }\n        for (var i = values.length; i < arraySize; i++) {\n            vals[i] = 0;\n        }\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: precision === 32 ? 'float' : 'half float',\n            data: precision === 32 ? vals : Array.from(vals),\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false\n        });\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateOfDimensions = function (width, height, precision) {\n        var arraySize = width * height * 4;\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: precision === 32 ? 'float' : 'half float',\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false\n        });\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateFramebuffer = function (texture, precision) {\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: texture.width,\n            height: texture.height,\n            depthStencil: false\n        });\n        return {\n            width: texture.width,\n            height: texture.height,\n            size: texture.width * texture.height * 4,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision\n        };\n    };\n    GPUMemoryAllocator.prototype.getTextureDims = function (size) {\n        var factors = primeFactors(size);\n        var width = 1;\n        var height = 1;\n        for (var i = 0; i < factors.length; i += 2) {\n            width *= factors[i];\n            if (i + 1 < factors.length) {\n                height *= factors[i + 1];\n            }\n        }\n        return { width: width, height: height };\n    };\n    return GPUMemoryAllocator;\n}());\nexport { GPUMemoryAllocator };\n//# sourceMappingURL=memory.js.map","import REGL from 'regl';\nimport { Dict } from '../../util/datastructs/dict';\nimport { GPUMemoryAllocator } from './memory';\nvar canvas = document.createElement(\"canvas\");\nexport var glContext;\nexport var gl;\nexport var defaultAllocator;\nfunction setup() {\n    glContext = canvas.getContext(\"webgl\", {\n        failIfMajorPerformanceCaveat: false\n    });\n    gl = REGL({\n        gl: glContext,\n        extensions: ['OES_texture_float', 'WEBGL_color_buffer_float', 'OES_texture_half_float']\n    });\n    defaultAllocator = new GPUMemoryAllocator(gl, function () {\n        return new Dict(function (key) { return key; });\n    });\n}\nsetup();\n//# sourceMappingURL=gl.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes } from '../../util/shape';\nvar WASMT;\nexport var wasmLoaded = new Promise(function (resolve, reject) {\n    import('../../wasm/rust_wasm_tensor').then(function (x) {\n        WASMT = x.Tensor;\n        resolve();\n    });\n});\nvar WASMTensor = /** @class */ (function (_super) {\n    __extends(WASMTensor, _super);\n    function WASMTensor(values, shape) {\n        var _this = _super.call(this) || this;\n        if (values instanceof Float32Array) {\n            if (shape === undefined) {\n                throw new Error('Need the shape when creating a Wasm tensor from values');\n            }\n            _this.wasmTensor = WASMT.create(shape, values);\n        }\n        else {\n            _this.wasmTensor = values;\n        }\n        return _this;\n    }\n    WASMTensor.prototype.getValues = function () {\n        return Promise.resolve(this.wasmTensor.get_vals());\n    };\n    WASMTensor.prototype.getShape = function () {\n        return Array.from(this.wasmTensor.get_shape());\n    };\n    WASMTensor.prototype.wasm = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    WASMTensor.prototype.delete = function () {\n        this.wasmTensor.free();\n        this.wasmTensor = undefined;\n    };\n    WASMTensor.prototype.copy = function () {\n        return new WASMTensor(this.wasmTensor.copy());\n    };\n    WASMTensor.prototype.exp = function () {\n        return new WASMTensor(this.wasmTensor.exp());\n    };\n    WASMTensor.prototype.log = function () {\n        return new WASMTensor(this.wasmTensor.log());\n    };\n    WASMTensor.prototype.sqrt = function () {\n        return new WASMTensor(this.wasmTensor.sqrt());\n    };\n    WASMTensor.prototype.abs = function () {\n        return new WASMTensor(this.wasmTensor.abs());\n    };\n    WASMTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.addition(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only subtract WASM tensor from WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.subtraction(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only multiply WASM tensor with WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.multiply(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only divide WASM tensor by WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.divide(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only take WASM tensor to power of WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.power(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.matmul(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof WASMTensor && (c === undefined || c instanceof WASMTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        if (c !== undefined) {\n            return new WASMTensor(this.wasmTensor.gemm_with_c(b.wasmTensor, aTranspose, bTranspose, alpha, c.wasmTensor, beta));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.gemm(b.wasmTensor, aTranspose, bTranspose, alpha));\n        }\n    };\n    WASMTensor.prototype.sum_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.product_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.product(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.max_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.max(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.min_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.min(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias) {\n        if (!(kernel instanceof WASMTensor) || (bias !== undefined && !(bias instanceof WASMTensor))) {\n            throw new Error('Can only do convolution of CPU tensor with CPU tensor');\n        }\n        if (bias !== undefined) {\n            return new WASMTensor(this.wasmTensor.conv_with_bias(kernel.wasmTensor, bias.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides)));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.conv(kernel.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides)));\n        }\n    };\n    WASMTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return new WASMTensor(this.wasmTensor.average_pool(new Uint32Array(kernelShape), new Uint32Array(pads), new Uint32Array(strides), includePad));\n    };\n    WASMTensor.prototype.reshape_impl = function (shape) {\n        var sh = new Uint32Array(shape);\n        return new WASMTensor(this.wasmTensor.reshape(sh), sh);\n    };\n    WASMTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only concat WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.concat(tensor.wasmTensor, axis));\n    };\n    WASMTensor.prototype.transpose_impl = function (permutation) {\n        return new WASMTensor(this.wasmTensor.transpose(new Uint32Array(permutation)));\n    };\n    WASMTensor.prototype.clip = function (min, max) {\n        if (min !== undefined && max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip(min, max));\n        }\n        else if (min !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_min(min));\n        }\n        else if (max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_max(max));\n        }\n        return this.copy();\n    };\n    WASMTensor.prototype.repeat = function (repeats) {\n        return new WASMTensor(this.wasmTensor.repeat(new Uint32Array(repeats)));\n    };\n    WASMTensor.prototype.expand = function (shape) {\n        var thisShape = this.getShape();\n        var _a = this.alignShapes(thisShape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(thisShape, resultShape)) {\n            return this.copy();\n        }\n        var reshaped = this.reshape(_shape, false);\n        return new WASMTensor(reshaped.wasmTensor.expand(new Uint32Array(resultShape)));\n    };\n    WASMTensor.prototype.pad_impl = function (pads, mode, value) {\n        return new WASMTensor(this.wasmTensor.pad(new Uint32Array(pads), WASMTensor.padModeToInt[mode], value));\n    };\n    WASMTensor.prototype.gather = function (axis, indices) {\n        return new WASMTensor(this.wasmTensor.gather(axis, indices.values, new Uint32Array(indices.shape)));\n    };\n    WASMTensor.prototype.floor = function () {\n        return new WASMTensor(this.wasmTensor.floor());\n    };\n    WASMTensor.prototype.ceil = function () {\n        return new WASMTensor(this.wasmTensor.ceil());\n    };\n    WASMTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return new WASMTensor(this.wasmTensor.slice(new Uint32Array(starts), new Uint32Array(ends), new Uint32Array(axes)));\n    };\n    WASMTensor.prototype.upsample = function (scales) {\n        return new WASMTensor(this.wasmTensor.upsample(new Float32Array(scales)));\n    };\n    WASMTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof WASMTensor) || !(variance instanceof WASMTensor) || !(scale instanceof WASMTensor) || !(bias instanceof WASMTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return new WASMTensor(this.wasmTensor.normalize(mean.wasmTensor, variance.wasmTensor, epsilon, scale.wasmTensor, bias.wasmTensor));\n    };\n    WASMTensor.padModeToInt = {\n        'constant': 0,\n        'reflect': 1,\n        'edge': 2\n    };\n    return WASMTensor;\n}(Tensor));\nexport { WASMTensor };\n//# sourceMappingURL=tensor.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defaultAllocator, gl } from \"../../tensor/gpu/gl\";\nimport { computeStrides, getSize } from \"../../util/shape\";\nexport var defaultMaxRank = 10;\nexport var defaultMaxIterations = 10000000;\nvar Operation = /** @class */ (function () {\n    function Operation(tensorConstructor, allocator, maxRank) {\n        this.statics = new Set();\n        this.copyCounter = 0;\n        this.fullyStatic = false;\n        if (allocator === undefined) {\n            allocator = defaultAllocator;\n        }\n        if (maxRank === undefined) {\n            maxRank = defaultMaxRank;\n        }\n        this.allocator = allocator;\n        this.maxRank = maxRank;\n        this.gpuTensorConstructor = tensorConstructor;\n    }\n    Operation.prototype.registerStatics = function (info) {\n        var staticTextures = 0;\n        var staticVars = 0;\n        for (var key in info) {\n            if (key.startsWith('shape')) {\n                var texName = key.slice('shape'.length);\n                this.statics.add(\"shape\" + texName);\n                this.statics.add(\"size\" + texName);\n                this.statics.add(\"rank\" + texName);\n                this.statics.add(\"strides\" + texName);\n                staticTextures++;\n            }\n            else {\n                this.statics.add(key);\n                if (!key.startsWith('width') && !key.startsWith('height')) {\n                    staticVars++;\n                }\n            }\n        }\n        if (staticTextures - 1 === this.getTextureNames().length && staticVars === this.getUniformAttrs().length) {\n            this.fullyStatic = true;\n            this.outputShape = info[\"shapeOutput\"];\n        }\n    };\n    Operation.prototype.getVarModifier = function (name) {\n        return this.statics.has(name) ? '' : 'uniform';\n    };\n    Operation.prototype.pad = function (arr, len) {\n        if (len === void 0) { len = this.maxRank; }\n        while (arr.length < len) {\n            arr.push(-1);\n        }\n        return arr;\n    };\n    Operation.prototype.copyPad = function (arr, len) {\n        if (len === void 0) { len = this.maxRank; }\n        var result = Array.from(arr);\n        while (result.length < len) {\n            result.push(-1);\n        }\n        return result;\n    };\n    Operation.prototype.getVariables = function () {\n        return '';\n    };\n    Operation.prototype.getVariableDeclarations = function (info) {\n        var _this = this;\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        return \"\\n      \" + textures.map(function (x) {\n            return \"\\n        \" + (x === 'Output' ? '' : \"uniform sampler2D \" + x + \";\") + \"\\n        \" + _this.getVarModifier('size' + x) + \" int size\" + x + \";\\n        \" + _this.getVarModifier('width' + x) + \" int width\" + x + \";\\n        \" + _this.getVarModifier('height' + x) + \" int height\" + x + \";\\n        \" + _this.getVarModifier('strides' + x) + \" int strides\" + x + \"[\" + _this.maxRank + \"];\\n        \" + _this.getVarModifier('shape' + x) + \" int shape\" + x + \"[\" + _this.maxRank + \"];\\n        \" + _this.getVarModifier('rank' + x) + \" int rank\" + x + \";\\n        \";\n        }).join('\\n') + \"\\n      varying vec2 uv;\\n\\n      \" + this.getVariables();\n    };\n    Operation.prototype.getVariableInitializations = function (info) {\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        var inits = '';\n        for (var _i = 0, textures_1 = textures; _i < textures_1.length; _i++) {\n            var tex = textures_1[_i];\n            if (\"shape\" + tex in info) {\n                var shape = info[\"shape\" + tex];\n                var strides = computeStrides(shape);\n                var size = getSize(shape);\n                var rank = shape.length;\n                inits += this.getArrayInit(\"shape\" + tex, shape);\n                inits += this.getArrayInit(\"strides\" + tex, strides);\n                inits += \"\\nsize\" + tex + \" = \" + size + \";\";\n                inits += \"\\nrank\" + tex + \" = \" + rank + \";\";\n            }\n        }\n        for (var k in info) {\n            if (!k.startsWith('shape')) {\n                if (Array.isArray(info[k])) {\n                    inits += this.getArrayInit(k, info[k]);\n                }\n                else {\n                    var type = this.getVarType(k);\n                    if (type === \"int\") {\n                        inits += \"\\n\" + k + \" = \" + info[k] + \";\";\n                    }\n                    else {\n                        inits += \"\\n\" + k + \" = \" + info[k].toPrecision(20) + \";\";\n                    }\n                }\n            }\n        }\n        return inits;\n    };\n    Operation.prototype.getVarType = function (name) {\n        var res = this.getUniformAttrs().find(function (x) { return x.name === name; });\n        if (res !== undefined) {\n            return res.type ? res.type : \"int\";\n        }\n        return \"int\";\n    };\n    Operation.prototype.getArrayInit = function (name, values, len, pad) {\n        if (len === undefined) {\n            len = this.maxRank;\n        }\n        var type = this.getVarType(name);\n        if (pad === undefined) {\n            if (type === \"int\") {\n                pad = '-1';\n            }\n            else if (type === \"float\") {\n                pad = '-1.0';\n            }\n        }\n        var res = '';\n        for (var i = 0; i < len; i++) {\n            if (i < values.length) {\n                if (type === \"int\") {\n                    res += \"\\n \" + name + \"[\" + i + \"] = \" + values[i] + \";\";\n                }\n                else if (type === 'float') {\n                    res += \"\\n \" + name + \"[\" + i + \"] = \" + values[i].toPrecision(20) + \";\";\n                }\n            }\n            else {\n                res += \"\\n \" + name + \"[\" + i + \"] = \" + pad + \";\";\n            }\n        }\n        return res;\n    };\n    Operation.prototype.getUtilFunctions = function () {\n        return \"\\n    int fromFloat(float f) {\\n      return int(floor(f+0.5));\\n    }\\n\\n    int coordinateToPos(vec2 coordinate, int textureWidth, int textureHeight) {\\n      int x = (fromFloat(coordinate.x*float(textureWidth*2))-1)/2;\\n      int y = (fromFloat(coordinate.y*float(textureHeight*2))-1)/2;\\n\\n      int pos = x + y*textureWidth;\\n\\n      return pos*4;\\n    }\\n\\n    vec2 posToCoordinate(int pos, int textureWidth, int textureHeight) {\\n      // 4 positions map to the same coordinate\\n      pos = pos/4;\\n\\n      int y = pos/textureWidth;\\n      int x = pos - y*textureWidth;\\n\\n      return vec2(float(x*2+1)/float(textureWidth*2), float(y*2+1)/float(textureHeight*2));\\n    }\\n\\n    int indexToPos(int index[\" + this.maxRank + \"], int strides[\" + this.maxRank + \"]) {\\n      int pos = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (strides[i] == -1) {\\n          break;\\n        }\\n        pos += index[i]*strides[i];\\n      }\\n      return pos;\\n    }\\n\\n    float getValueAtPos(int pos, int textureWidth, int textureHeight, sampler2D tex) {\\n      vec2 coord = posToCoordinate(pos, textureWidth, textureHeight);\\n      int res = pos - (pos/4)*4;\\n      vec4 val = texture2D(tex, coord);\\n      if (res == 0) {\\n        return val.r;\\n      } else if (res == 1) {\\n        return val.g;\\n      } else if (res == 2) {\\n        return val.b;\\n      } else {\\n        return val.a;\\n      }\\n    }\\n\\n    float getValueAt(int index[\" + this.maxRank + \"], int strides[\" + this.maxRank + \"], int textureWidth, int textureHeight, sampler2D tex) {\\n      int pos = indexToPos(index, strides);\\n      return getValueAtPos(pos, textureWidth, textureHeight, tex);\\n    }\";\n    };\n    Operation.prototype.getTextureFunctions = function () {\n        var _this = this;\n        var textures = this.getTextureNames();\n        return textures.map(function (x) {\n            return \"\\n      float _\" + x + \"(int indices[\" + _this.maxRank + \"]) {\\n        return getValueAt(indices, strides\" + x + \", width\" + x + \", height\" + x + \", \" + x + \");\\n      }\\n      \";\n        }).join('\\n');\n    };\n    Operation.prototype.getCompleteFragmentShader = function (info, precision) {\n        var fragShader = this.getFragmentShader(info);\n        var variableDecls = this.getVariableDeclarations(info);\n        var varInits = this.getVariableInitializations(info);\n        var utilFunctions = this.getUtilFunctions();\n        var textureFunctions = this.getTextureFunctions();\n        var result = \"\\n    precision \" + this.precisionString(precision) + \" float;\\n\\n    \" + variableDecls + \"\\n\\n    \" + utilFunctions + \"\\n    \" + textureFunctions + \"\\n\\n    void initVars() {\\n      \" + varInits + \"\\n    }\\n\\n    \" + fragShader;\n        return result;\n    };\n    Operation.prototype.getUniforms = function (info) {\n        var uniformAttrs = [];\n        var defaultUniformAttrs = this.getUniformAttrs();\n        for (var _i = 0, defaultUniformAttrs_1 = defaultUniformAttrs; _i < defaultUniformAttrs_1.length; _i++) {\n            var defaultAttr = defaultUniformAttrs_1[_i];\n            if (info[defaultAttr.name] === undefined) {\n                uniformAttrs.push(defaultAttr);\n            }\n        }\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        for (var _a = 0, textures_2 = textures; _a < textures_2.length; _a++) {\n            var texture = textures_2[_a];\n            uniformAttrs.push({ name: texture });\n            if (info[\"shape\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"size\" + texture });\n                uniformAttrs.push({ name: \"strides\" + texture, length: this.maxRank });\n                uniformAttrs.push({ name: \"shape\" + texture, length: this.maxRank });\n                uniformAttrs.push({ name: \"rank\" + texture });\n            }\n            if (info[\"width\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"width\" + texture });\n            }\n            if (info[\"height\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"height\" + texture });\n            }\n        }\n        var uniforms = {};\n        for (var _b = 0, uniformAttrs_1 = uniformAttrs; _b < uniformAttrs_1.length; _b++) {\n            var uniformAttr = uniformAttrs_1[_b];\n            if (info[uniformAttr.name] === undefined) {\n                if (uniformAttr.length !== undefined) {\n                    for (var i = 0; i < uniformAttr.length; i++) {\n                        var name_1 = uniformAttr.name + \"[\" + i + \"]\";\n                        uniforms[name_1] = gl.prop(name_1);\n                    }\n                }\n                else {\n                    uniforms[uniformAttr.name] = gl.prop(uniformAttr.name);\n                }\n            }\n        }\n        return uniforms;\n    };\n    Operation.prototype.posToIndex = function (strides, result, pos) {\n        var name = pos + \"_\" + this.copyCounter++;\n        return \"\\n    int \" + name + \" = \" + pos + \";\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (\" + strides + \"[i] == -1) {\\n        \" + result + \"[i] = -1;\\n      } else {\\n        if (\" + strides + \"[i] == 0) {\\n          \" + result + \"[i] = 0;\\n        } else {\\n          \" + result + \"[i] = \" + name + \"/\" + strides + \"[i];\\n          \" + name + \" = \" + name + \" - \" + strides + \"[i]*\" + result + \"[i]; // Stupid modulo hack\\n        }\\n      }\\n    }\";\n    };\n    Operation.prototype.initIndex = function (index, rank) {\n        if (rank === undefined) {\n            return \"\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          \" + index + \"[i] = -1;\\n        }\";\n        }\n        else {\n            return \"\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (i < \" + rank + \") {\\n            \" + index + \"[i] = 0;\\n          } else {\\n            \" + index + \"[i] = -1;\\n          }\\n        }\";\n        }\n    };\n    Operation.prototype.incrementIndex = function (index, shape) {\n        return \"\\n    for (int i = \" + this.maxRank + \" - 1; i >= 0; i--) {\\n      if (\" + shape + \"[i] != -1) {\\n        \" + index + \"[i] += 1;\\n        if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n          \" + index + \"[i] = 0;\\n        } else {\\n          break;\\n        }\\n      }\\n    }\\n    \";\n    };\n    Operation.prototype.incrementConditional = function (index, shape, cond) {\n        return \"\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (\" + cond + \"[i] == 1) {\\n        \" + index + \"[i] += 1;\\n        if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n          \" + index + \"[i] = 0;\\n        } else {\\n          break;\\n        }\\n      } else if (\" + cond + \"[i] == -1) {\\n        break;\\n      }\\n    }\\n    \";\n    };\n    Operation.prototype.getDefaultMain = function () {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      int pos = coordinateToPos(uv, widthOutput, heightOutput);\\n\\n      vec4 result = vec4(0,0,0,0);\\n\\n      if (pos < sizeOutput) {\\n        int index[\" + this.maxRank + \"];\\n        \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n        result.r = process(index);\\n\\n        pos += 1;\\n\\n        if (pos < sizeOutput) {\\n          \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n          result.g = process(index);\\n\\n          pos += 1;\\n\\n          if (pos < sizeOutput) {\\n            \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n            result.b = process(index);\\n\\n            pos += 1;\\n\\n            if (pos < sizeOutput) {\\n              \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n              result.a = process(index);\\n            }\\n          }\\n        }\\n      }\\n\\n      gl_FragColor = result;\\n    }\";\n    };\n    Operation.prototype.precisionString = function (precision) {\n        return precision === 32 ? \"highp\" : \"mediump\";\n    };\n    Operation.prototype.getDrawCommand = function (info, precision) {\n        var fragShader = this.getCompleteFragmentShader(info, precision);\n        var uniforms = this.getUniforms(info);\n        var result = gl({\n            frag: fragShader,\n            vert: \"\\n        precision \" + this.precisionString(precision) + \" float;\\n        attribute vec2 position;\\n        varying vec2 uv;\\n        void main() {\\n          uv = 0.5 * (position + 1.0);\\n          gl_Position = vec4(position, 0, 1);\\n        }\",\n            attributes: {\n                position: [-4, -4, 4, -4, 0, 4]\n            },\n            uniforms: uniforms,\n            framebuffer: gl.prop('framebuffer'),\n            depth: {\n                enable: false\n            },\n            count: 3\n        });\n        return result;\n    };\n    Operation.prototype.compile = function (info, precision) {\n        this.registerStatics(info);\n        this.precision = precision;\n        this.drawCommand = this.getDrawCommand(info, precision);\n    };\n    Operation.prototype.compute = function (resultShape, inputTensors, inputs) {\n        if (this.drawCommand === undefined) {\n            this.compile({}, 32);\n        }\n        var resultSize = getSize(resultShape);\n        var result = this.allocator.allocate(resultSize, this.precision);\n        var inputTextures = {};\n        for (var name_2 in inputTensors) {\n            inputTextures[name_2] = inputTensors[name_2].memory.frameBuffer;\n        }\n        if (inputs === undefined) {\n            inputs = {};\n        }\n        if (!this.fullyStatic) {\n            for (var name_3 in inputTensors) {\n                if (!this.statics.has(\"shape\" + name_3)) {\n                    inputs[\"size\" + name_3] = inputTensors[name_3].size;\n                    inputs[\"strides\" + name_3] = this.pad(computeStrides(inputTensors[name_3].shape));\n                    inputs[\"shape\" + name_3] = this.copyPad(inputTensors[name_3].shape);\n                    inputs[\"rank\" + name_3] = inputTensors[name_3].shape.length;\n                }\n                if (!this.statics.has(\"width\" + name_3)) {\n                    inputs[\"width\" + name_3] = inputTensors[name_3].memory.width;\n                }\n                if (!this.statics.has(\"height\" + name_3)) {\n                    inputs[\"height\" + name_3] = inputTensors[name_3].memory.height;\n                }\n            }\n            if (!this.statics.has('shapeOutput')) {\n                inputs['sizeOutput'] = resultSize;\n                inputs['stridesOutput'] = this.pad(computeStrides(resultShape));\n                inputs['shapeOutput'] = this.copyPad(resultShape);\n                inputs['rankOutput'] = resultShape.length;\n            }\n            if (!this.statics.has('widthOutput')) {\n                inputs['widthOutput'] = result.width;\n            }\n            if (!this.statics.has('heightOutput')) {\n                inputs['heightOutput'] = result.height;\n            }\n        }\n        this.drawCommand(__assign(__assign({ framebuffer: result.frameBuffer }, inputTextures), inputs));\n        return this.gpuTensorConstructor(result, resultShape, this.precision);\n    };\n    Operation.prototype.getUniformAttrs = function () {\n        return [];\n    };\n    return Operation;\n}());\nexport { Operation };\n//# sourceMappingURL=operation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar MatMulOperation = /** @class */ (function (_super) {\n    __extends(MatMulOperation, _super);\n    function MatMulOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        _this.maxRank = 2;\n        return _this;\n    }\n    MatMulOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int ix1[\" + this.maxRank + \"];\\n      \" + this.initIndex('ix1') + \"\\n      ix1[0] = index[0];\\n\\n      int ix2[\" + this.maxRank + \"];\\n      \" + this.initIndex('ix2') + \"\\n      ix2[1] = index[1];\\n\\n      int k = shapeA[1];\\n\\n      float res = 0.0;\\n\\n      for (int i = 0; i < \" + this.maxIterations + \"; i++) {\\n        if (i >= k) {\\n          break;\\n        }\\n        ix1[1] = i;\\n        ix2[0] = i;\\n\\n        float v1 = _A(ix1);\\n        float v2 = _B(ix2);\\n        res += v1*v2;\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    MatMulOperation.prototype.getTextureNames = function () {\n        return [\"A\", \"B\"];\n    };\n    MatMulOperation.prototype.calc = function (input) {\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A, B: input.B });\n    };\n    MatMulOperation.prototype.getOutputShape = function (input) {\n        return [input.A.shape[0], input.B.shape[1]];\n    };\n    MatMulOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxIterations = info.shapeA[1];\n        }\n        else if (info.shapeB !== undefined) {\n            this.maxIterations = info.shapeB[0];\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    MatMulOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.A.shape,\n            widthB: input.A.memory.width,\n            heightB: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height\n        };\n    };\n    MatMulOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape;\n    };\n    return MatMulOperation;\n}(Operation));\nexport { MatMulOperation };\n//# sourceMappingURL=matmul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar UnaryOperation = /** @class */ (function (_super) {\n    __extends(UnaryOperation, _super);\n    function UnaryOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    UnaryOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      gl_FragColor = \" + this.operation('texture2D(X, uv)') + \";\\n    }\\n    \";\n    };\n    UnaryOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    UnaryOperation.prototype.calc = function (input) {\n        return this.compute(input.input.shape, { X: input.input });\n    };\n    UnaryOperation.prototype.getOutputShape = function (input) {\n        return input.input.shape;\n    };\n    UnaryOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UnaryOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: this.getOutputShape(input),\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height\n        };\n    };\n    UnaryOperation.prototype.getInputInfoString = function (input) {\n        return \"\" + input.input.shape;\n    };\n    return UnaryOperation;\n}(Operation));\nexport { UnaryOperation };\n//# sourceMappingURL=unaryOperation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar ExpOperation = /** @class */ (function (_super) {\n    __extends(ExpOperation, _super);\n    function ExpOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ExpOperation.prototype.operation = function (input) {\n        return \"exp(\" + input + \")\";\n    };\n    return ExpOperation;\n}(UnaryOperation));\nexport { ExpOperation };\n//# sourceMappingURL=exp.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { getSize } from \"../../../util/shape\";\nimport { outputDimsSize } from \"../../util/conv\";\nimport { Operation } from \"../operation\";\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nvar ConvOperation = /** @class */ (function (_super) {\n    __extends(ConvOperation, _super);\n    function ConvOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    ConvOperation.prototype.updateInputIx = function () {\n        return \"\\n    for (int d = 0; d < \" + (this.maxRank - 2) + \"; d++) {\\n      int stride = strides[d];\\n      int pad = pads[d];\\n      int dilation = dilations[d];\\n      if (stride == -1) {\\n        break;\\n      }\\n\\n      inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d+2]*dilation;\\n      if (inputIx[d+2] < 0 || inputIx[d+2] >= shapeX[d+2]) {\\n        skip = true;\\n        break;\\n      }\\n    }\\n    \";\n    };\n    ConvOperation.prototype.getMainBody = function () {\n        return \"\\n    int n = index[0];\\n    int m = index[1];\\n\\n    int kernelIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('kernelIx') + \"\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (i >= dataRank) {\\n        break;\\n      }\\n      kernelIx[i+2] = 0;\\n    }\\n    kernelIx[0] = m;\\n    int inputIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('inputIx') + \"\\n    inputIx[0] = n;\\n\\n    for (int cg = 0; cg < \" + this.maxIterations + \"; cg++) {\\n      if (cg >= CG) {\\n        break;\\n      }\\n      int c = m * CG + cg;\\n      int d = c/C;\\n      c = c - d*C;\\n      inputIx[1] = c;\\n      kernelIx[1] = cg;\\n      for (int kIx = 0; kIx < \" + this.maxIterations + \"; kIx++) {\\n        if (kIx >= kernelSize) {\\n          break;\\n        }\\n\\n        bool skip = false;\\n\\n        \" + this.updateInputIx() + \"\\n\\n        if (!skip) {\\n          res += _X(inputIx) * _W(kernelIx);\\n        }\\n\\n        \" + this.incrementIndex('kernelIx', 'shapeW') + \"\\n      }\\n    }\\n    \";\n    };\n    ConvOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('CG') + \" int CG;\\n    \" + this.getVarModifier('kernelSize') + \" int kernelSize;\\n    \" + this.getVarModifier('dataRank') + \" int dataRank;\\n    \" + this.getVarModifier('C') + \" int C;\\n    \" + this.getVarModifier('dilations') + \" int dilations[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('strides') + \" int strides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('activation') + \" int activation;\\n    \";\n    };\n    ConvOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n\\n      \" + this.getMainBody() + \"\\n\\n      if (activation == 1) {\\n        res = max(0.0, res);\\n      } else if (activation == 2) {\\n        res = max(0.0, min(res,6.0));\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConvOperation.prototype.getTextureNames = function () {\n        return [\"X\", \"W\"];\n    };\n    ConvOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"CG\" },\n            { name: \"kernelSize\" },\n            { name: \"C\" },\n            { name: \"dataRank\" },\n            { name: \"pads\", length: this.maxRank * 2 },\n            { name: \"strides\", length: this.maxRank },\n            { name: \"dilations\", length: this.maxRank },\n            { name: \"activation\" }\n        ];\n    };\n    ConvOperation.prototype.getActivationFlag = function (activation) {\n        if (activation === \"id\") {\n            return 0;\n        }\n        else if (activation === \"relu\") {\n            return 1;\n        }\n        else if (activation === \"relu6\") {\n            return 2;\n        }\n    };\n    ConvOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X, W: input.W });\n        }\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var CG = input.W.shape[1];\n        var kernelSize = getSize(W);\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X, W: input.W }, {\n            CG: CG, kernelSize: kernelSize, C: C,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            dilations: this.copyPad(input.dilations),\n            activation: this.getActivationFlag(input.activation)\n        });\n    };\n    ConvOperation.prototype.getOutputShape = function (input) {\n        var N = input.X.shape[0];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return outputShape;\n    };\n    ConvOperation.prototype.compile = function (info, precision) {\n        if (info.shapeW !== undefined) {\n            info.CG = info.shapeW[1];\n            info.kernelSize = getSize(info.shapeW.slice(2));\n            info.dataRank = info.shapeW.length - 2;\n            this.maxRank = info.shapeW.length;\n        }\n        if (info.shapeX !== undefined) {\n            info.C = info.shapeX[1];\n            info.dataRank = info.shapeX.length - 2;\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.activation !== undefined && typeof info.activation === \"string\") {\n            info.activation = this.getActivationFlag(info.activation);\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ConvOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var kernelSize = getSize(input.W.shape.slice(2));\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeW: input.W.shape,\n            widthW: input.W.memory.width,\n            heightW: input.W.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            dilations: input.dilations,\n            strides: input.strides,\n            CG: input.W.shape[1],\n            kernelSize: kernelSize,\n            dataRank: D.length,\n            C: C,\n            activation: this.getActivationFlag(input.activation)\n        };\n    };\n    ConvOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.W.shape + \"-\" + input.dilations + \"-\" + input.pads + \"-\" + input.dilations + \"-\" + input.strides + \"-\" + input.activation;\n    };\n    return ConvOperation;\n}(Operation));\nexport { ConvOperation };\nvar ConvBiasOperation = /** @class */ (function (_super) {\n    __extends(ConvBiasOperation, _super);\n    function ConvBiasOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    ConvBiasOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int biasIndex[\" + this.maxRank + \"];\\n      \" + this.initIndex('biasIndex') + \"\\n      biasIndex[0] = index[1];\\n      float res = _B(biasIndex);\\n\\n      \" + this.getMainBody() + \"\\n\\n      if (activation == 1) {\\n        res = max(0.0, res);\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConvBiasOperation.prototype.getTextureNames = function () {\n        return [\"X\", \"W\", \"B\"];\n    };\n    ConvBiasOperation.prototype.calc = function (input) {\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var CG = input.W.shape[1];\n        var kernelSize = getSize(W);\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X, W: input.W, B: input.B }, {\n            CG: CG, kernelSize: kernelSize, C: C,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            dilations: this.copyPad(input.dilations),\n            activation: this.getActivationFlag(input.activation)\n        });\n    };\n    ConvBiasOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { shapeB: input.B.shape, widthB: input.B.memory.width, heightB: input.B.memory.height });\n    };\n    ConvBiasOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.B.shape;\n    };\n    return ConvBiasOperation;\n}(ConvOperation));\nexport { ConvBiasOperation };\n//# sourceMappingURL=conv.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar AbsOperation = /** @class */ (function (_super) {\n    __extends(AbsOperation, _super);\n    function AbsOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    AbsOperation.prototype.operation = function (input) {\n        return \"abs(\" + input + \")\";\n    };\n    return AbsOperation;\n}(UnaryOperation));\nexport { AbsOperation };\n//# sourceMappingURL=abs.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"./../operation\";\nvar BinaryOperation = /** @class */ (function (_super) {\n    __extends(BinaryOperation, _super);\n    function BinaryOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    BinaryOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int[\" + this.maxRank + \"] index) {\\n      return \" + this.getOp('_A(index)', '_B(index)') + \";\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    BinaryOperation.prototype.getOutputShape = function (input) {\n        return input.outputShape;\n    };\n    BinaryOperation.prototype.getTextureNames = function () {\n        return [\"A\", \"B\"];\n    };\n    BinaryOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B });\n    };\n    BinaryOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        if (info.shapeB !== undefined) {\n            this.maxRank = info.shapeB.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    BinaryOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(input.outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.B.shape,\n            widthB: input.B.memory.width,\n            heightB: input.B.memory.height,\n            shapeOutput: input.outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height\n        };\n    };\n    BinaryOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape;\n    };\n    return BinaryOperation;\n}(Operation));\nexport { BinaryOperation };\n//# sourceMappingURL=binaryOperation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from \"./binaryOperation\";\nvar AddOperation = /** @class */ (function (_super) {\n    __extends(AddOperation, _super);\n    function AddOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    AddOperation.prototype.getOp = function (a, b) {\n        return a + \" + \" + b;\n    };\n    return AddOperation;\n}(BinaryOperation));\nexport { AddOperation };\n//# sourceMappingURL=add.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from \"./binaryOperation\";\nvar MultiplyOperation = /** @class */ (function (_super) {\n    __extends(MultiplyOperation, _super);\n    function MultiplyOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    MultiplyOperation.prototype.getOp = function (a, b) {\n        return a + \"*\" + b;\n    };\n    return MultiplyOperation;\n}(BinaryOperation));\nexport { MultiplyOperation };\n//# sourceMappingURL=multiply.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from \"./binaryOperation\";\nvar SubtractOperation = /** @class */ (function (_super) {\n    __extends(SubtractOperation, _super);\n    function SubtractOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SubtractOperation.prototype.getOp = function (a, b) {\n        return a + \" - \" + b;\n    };\n    return SubtractOperation;\n}(BinaryOperation));\nexport { SubtractOperation };\n//# sourceMappingURL=subtract.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from \"./binaryOperation\";\nvar DivideOperation = /** @class */ (function (_super) {\n    __extends(DivideOperation, _super);\n    function DivideOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    DivideOperation.prototype.getOp = function (a, b) {\n        return a + \"/\" + b;\n    };\n    return DivideOperation;\n}(BinaryOperation));\nexport { DivideOperation };\n//# sourceMappingURL=divide.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getSize } from \"../../../util/shape\";\nimport { outputDimsSize } from \"../../util/conv\";\nimport { Operation } from \"../operation\";\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nvar AveragePoolOperation = /** @class */ (function (_super) {\n    __extends(AveragePoolOperation, _super);\n    function AveragePoolOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    AveragePoolOperation.prototype.updateInputIx = function () {\n        return \"\\n    for (int d = 0; d < \" + (this.maxRank - 2) + \"; d++) {\\n      int stride = strides[d];\\n      int pad = pads[d];\\n      if (stride == -1) {\\n        break;\\n      }\\n\\n      inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d];\\n      if (inputIx[d+2] < 0 || inputIx[d+2] >= shapeX[d+2]) {\\n        skip = true;\\n        break;\\n      }\\n    }\\n    \";\n    };\n    AveragePoolOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('kernelSize') + \" int kernelSize;\\n    \" + this.getVarModifier('dataRank') + \" int dataRank;\\n    \" + this.getVarModifier('includePad') + \" int includePad;\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('strides') + \" int strides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('kernelShape') + \" int kernelShape[\" + this.maxRank + \"];\\n    \";\n    };\n    AveragePoolOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n      int count = 0;\\n\\n      int n = index[0];\\n      int c = index[1];\\n\\n      int kernelIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('kernelIx') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i >= dataRank) {\\n          break;\\n        }\\n        kernelIx[i] = 0;\\n      }\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n      inputIx[0] = n;\\n      inputIx[1] = c;\\n\\n      for (int kIx = 0; kIx < \" + this.maxIterations + \"; kIx++) {\\n        if (kIx >= kernelSize) {\\n          break;\\n        }\\n\\n        bool skip = false;\\n\\n        \" + this.updateInputIx() + \"\\n\\n        if (!skip) {\\n          res += _X(inputIx);\\n        }\\n\\n        if (!skip || includePad == 1) {\\n          count += 1;\\n        }\\n\\n        \" + this.incrementIndex('kernelIx', 'kernelShape') + \"\\n      }\\n\\n      res = res / float(count);\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    AveragePoolOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    AveragePoolOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"kernelSize\" },\n            { name: \"dataRank\" },\n            { name: \"includePad\" },\n            { name: \"pads\", length: this.maxRank * 2 },\n            { name: \"strides\", length: this.maxRank },\n            { name: \"kernelShape\", length: this.maxRank }\n        ];\n    };\n    AveragePoolOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var kernelSize = getSize(input.kernelShape);\n        var R = outputDimsSize(D, input.kernelShape, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), new Array(D.length).fill(1), input.strides);\n        var outputShape = [N, C];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X }, {\n            kernelSize: kernelSize,\n            includePad: input.includePad ? 1 : 0,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            kernelShape: this.copyPad(input.kernelShape)\n        });\n    };\n    AveragePoolOperation.prototype.getOutputShape = function (input) {\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var R = outputDimsSize(D, input.kernelShape, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), new Array(D.length).fill(1), input.strides);\n        var outputShape = [N, C];\n        outputShape = outputShape.concat(R);\n        return outputShape;\n    };\n    AveragePoolOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            info.dataRank = info.shapeX.length - 2;\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.includePad === true) {\n            info.includePad = 1;\n        }\n        else if (info.includePad === false) {\n            info.includePad = 0;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    AveragePoolOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var kernelSize = getSize(input.kernelShape);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            kernelShape: input.kernelShape,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            strides: input.strides,\n            kernelSize: kernelSize,\n            dataRank: input.X.shape.length - 2,\n            includePad: input.includePad ? 1 : 0\n        };\n    };\n    AveragePoolOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.kernelShape + \"-\" + input.pads + \"-\" + input.strides + \"-\" + input.includePad;\n    };\n    return AveragePoolOperation;\n}(Operation));\nexport { AveragePoolOperation };\n//# sourceMappingURL=averagePool.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { computeStrides, getSize } from \"../../../util/shape\";\nimport { poolResultShape } from \"../../util/pool\";\nimport { Operation } from \"../operation\";\nvar PoolOperation = /** @class */ (function (_super) {\n    __extends(PoolOperation, _super);\n    function PoolOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    PoolOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('mappedInputStrides') + \" int mappedInputStrides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int sumDims[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int sumSize;\\n    \";\n    };\n    PoolOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n\\n      int inputPos = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (mappedInputStrides[i] == -1 || index[i] == -1) {\\n          break;\\n        }\\n        inputPos += mappedInputStrides[i]*index[i];\\n      }\\n\\n      \" + this.posToIndex('stridesX', 'inputIx', 'inputPos') + \"\\n\\n      float res = 0.0;\\n\\n      for (int i = 0; i < \" + this.maxIterations + \"; i++) {\\n        if (i >= sumSize) {\\n          break;\\n        }\\n        float curr = _X(inputIx);\\n        if (i == 0) {\\n          res = \" + this.init('curr') + \";\\n        } else {\\n          res = \" + this.update('curr', 'res') + \";\\n        }\\n\\n        \" + this.incrementConditional('inputIx', 'shapeX', 'sumDims') + \"\\n      }\\n\\n      \" + this.post('res') + \"\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    PoolOperation.prototype.post = function (res) {\n        return '';\n    };\n    PoolOperation.prototype.init = function (res) {\n        return res;\n    };\n    PoolOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    PoolOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"mappedInputStrides\", length: this.maxRank },\n            { name: \"sumDims\", length: this.maxRank },\n            { name: \"sumSize\" }\n        ];\n    };\n    PoolOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        var inputStrides = computeStrides(input.X.shape);\n        var mappedInputStrides = [];\n        for (var _i = 0, ixMap_1 = ixMap; _i < ixMap_1.length; _i++) {\n            var i = ixMap_1[_i];\n            mappedInputStrides.push(inputStrides[i]);\n        }\n        var sumSize = 1;\n        var sumDims = new Array(input.X.shape.length).fill(0);\n        for (var i = 0; i < input.axes.length; i++) {\n            sumDims[input.axes[i]] = 1;\n            sumSize *= input.X.shape[input.axes[i]];\n        }\n        return this.compute(outputShape, { X: input.X }, {\n            mappedInputStrides: this.pad(mappedInputStrides),\n            sumDims: this.pad(sumDims),\n            sumSize: sumSize\n        });\n    };\n    PoolOperation.prototype.getOutputShape = function (input) {\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        return outputShape;\n    };\n    PoolOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined && info.axes !== undefined && info.keepDims !== undefined) {\n            var _a = poolResultShape(info.shapeX, info.axes, info.keepDims), outputShape = _a[0], ixMap = _a[1];\n            var inputStrides = computeStrides(info.shapeX);\n            var mappedInputStrides = [];\n            for (var _i = 0, ixMap_2 = ixMap; _i < ixMap_2.length; _i++) {\n                var i = ixMap_2[_i];\n                mappedInputStrides.push(inputStrides[i]);\n            }\n            var sumSize = 1;\n            var sumDims = new Array(info.shapeX.length).fill(0);\n            for (var i = 0; i < info.axes.length; i++) {\n                sumDims[info.axes[i]] = 1;\n                sumSize *= info.shapeX[info.axes[i]];\n            }\n            info.sumDims = sumDims;\n            info.shapeOutput = outputShape;\n            info.mappedInputStrides = mappedInputStrides;\n            info.sumSize = sumSize;\n            delete info['keepDims'];\n            delete info['axes'];\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    PoolOperation.prototype.getCompilationInfo = function (input, precision) {\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        var inputStrides = computeStrides(input.X.shape);\n        var mappedInputStrides = [];\n        for (var _i = 0, ixMap_3 = ixMap; _i < ixMap_3.length; _i++) {\n            var i = ixMap_3[_i];\n            mappedInputStrides.push(inputStrides[i]);\n        }\n        var sumSize = 1;\n        var sumDims = new Array(input.X.shape.length).fill(0);\n        for (var i = 0; i < input.axes.length; i++) {\n            sumDims[input.axes[i]] = 1;\n            sumSize *= input.X.shape[input.axes[i]];\n        }\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            mappedInputStrides: mappedInputStrides,\n            sumDims: sumDims,\n            sumSize: sumSize\n        };\n    };\n    PoolOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axes + \"-\" + input.keepDims;\n    };\n    return PoolOperation;\n}(Operation));\nexport { PoolOperation };\n//# sourceMappingURL=pool.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar ReduceMeanOperation = /** @class */ (function (_super) {\n    __extends(ReduceMeanOperation, _super);\n    function ReduceMeanOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReduceMeanOperation.prototype.update = function (a, b) {\n        return a + \" + \" + b;\n    };\n    ReduceMeanOperation.prototype.post = function (res) {\n        return res + \" = \" + res + \"/float(sumSize);\";\n    };\n    return ReduceMeanOperation;\n}(PoolOperation));\nexport { ReduceMeanOperation };\n//# sourceMappingURL=reduceMean.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar ReduceMeanSquareOperation = /** @class */ (function (_super) {\n    __extends(ReduceMeanSquareOperation, _super);\n    function ReduceMeanSquareOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReduceMeanSquareOperation.prototype.update = function (a, b) {\n        return \"(\" + a + \"*\" + a + \") + \" + b;\n    };\n    ReduceMeanSquareOperation.prototype.post = function (res) {\n        return res + \" = \" + res + \"/float(sumSize);\";\n    };\n    ReduceMeanSquareOperation.prototype.init = function (res) {\n        return res + \"*\" + res;\n    };\n    return ReduceMeanSquareOperation;\n}(PoolOperation));\nexport { ReduceMeanSquareOperation };\n//# sourceMappingURL=reduceMeanSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar SumSquareOperation = /** @class */ (function (_super) {\n    __extends(SumSquareOperation, _super);\n    function SumSquareOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SumSquareOperation.prototype.update = function (a, b) {\n        return \"(\" + a + \"*\" + a + \") + \" + b;\n    };\n    SumSquareOperation.prototype.init = function (res) {\n        return res + \"*\" + res;\n    };\n    SumSquareOperation.prototype.compile = function (info, precision) {\n        _super.prototype.compile.call(this, info, 32);\n    };\n    return SumSquareOperation;\n}(PoolOperation));\nexport { SumSquareOperation };\n//# sourceMappingURL=sumSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar SumOperation = /** @class */ (function (_super) {\n    __extends(SumOperation, _super);\n    function SumOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SumOperation.prototype.update = function (a, b) {\n        return a + \" + \" + b;\n    };\n    return SumOperation;\n}(PoolOperation));\nexport { SumOperation };\n//# sourceMappingURL=sum.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar ProductOperation = /** @class */ (function (_super) {\n    __extends(ProductOperation, _super);\n    function ProductOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ProductOperation.prototype.update = function (a, b) {\n        return a + \" * \" + b;\n    };\n    return ProductOperation;\n}(PoolOperation));\nexport { ProductOperation };\n//# sourceMappingURL=product.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar MaxOperation = /** @class */ (function (_super) {\n    __extends(MaxOperation, _super);\n    function MaxOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MaxOperation.prototype.update = function (a, b) {\n        return \"max(\" + a + \", \" + b + \")\";\n    };\n    return MaxOperation;\n}(PoolOperation));\nexport { MaxOperation };\n//# sourceMappingURL=max.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from \"./pool\";\nvar MinOperation = /** @class */ (function (_super) {\n    __extends(MinOperation, _super);\n    function MinOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MinOperation.prototype.update = function (a, b) {\n        return \"min(\" + a + \", \" + b + \")\";\n    };\n    return MinOperation;\n}(PoolOperation));\nexport { MinOperation };\n//# sourceMappingURL=min.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar CeilOperation = /** @class */ (function (_super) {\n    __extends(CeilOperation, _super);\n    function CeilOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    CeilOperation.prototype.operation = function (input) {\n        return \"ceil(\" + input + \")\";\n    };\n    return CeilOperation;\n}(UnaryOperation));\nexport { CeilOperation };\n//# sourceMappingURL=ceil.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { Operation } from \"../operation\";\nvar ClipOperation = /** @class */ (function (_super) {\n    __extends(ClipOperation, _super);\n    function ClipOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ClipOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      vec4 maxVec = vec4(maxVal,maxVal,maxVal,maxVal);\\n      vec4 minVec = vec4(minVal,minVal,minVal,minVal);\\n\\n      vec4 res = texture2D(X, uv);\\n      if (doMin == 1) {\\n        res = max(minVec, res);\\n      }\\n      if (doMax == 1) {\\n        res = min(maxVec, res);\\n      }\\n\\n      gl_FragColor = res;\\n    }\\n    \";\n    };\n    ClipOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    ClipOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('minVal') + \" float minVal;\\n    \" + this.getVarModifier('maxVal') + \" float maxVal;\\n    \" + this.getVarModifier('doMin') + \" int doMin;\\n    \" + this.getVarModifier('doMax') + \" int doMax;\\n    \";\n    };\n    ClipOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"minVal\", type: \"float\" },\n            { name: \"maxVal\", type: \"float\" },\n            { name: \"doMin\" },\n            { name: \"doMax\" }\n        ];\n    };\n    ClipOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.input });\n        }\n        return this.compute(input.input.shape, { X: input.input }, {\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0\n        });\n    };\n    ClipOperation.prototype.getOutputShape = function (input) {\n        return input.input.shape;\n    };\n    ClipOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ClipOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputSize = defaultAllocator.getAllocationDimensions(input.input.size, precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: input.input.shape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0\n        };\n    };\n    ClipOperation.prototype.getInputInfoString = function (input) {\n        return input.input.shape + \"-\" + input.minVal + \"-\" + input.maxVal;\n    };\n    return ClipOperation;\n}(Operation));\nexport { ClipOperation };\n//# sourceMappingURL=clip.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar FloorOperation = /** @class */ (function (_super) {\n    __extends(FloorOperation, _super);\n    function FloorOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    FloorOperation.prototype.operation = function (input) {\n        return \"floor(\" + input + \")\";\n    };\n    return FloorOperation;\n}(UnaryOperation));\nexport { FloorOperation };\n//# sourceMappingURL=floor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar ConcatOperation = /** @class */ (function (_super) {\n    __extends(ConcatOperation, _super);\n    function ConcatOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ConcatOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('axis') + \" int axis;\\n    \";\n    };\n    ConcatOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"axis\" }\n        ];\n    };\n    ConcatOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i == axis) {\\n          if (index[i] >= shapeA[i]) {\\n            index[i] = index[i] - shapeA[i];\\n            res = _B(index);\\n          } else {\\n            res = _A(index);\\n          }\\n          break;\\n        }\\n      }\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConcatOperation.prototype.getTextureNames = function () {\n        return [\"A\", \"B\"];\n    };\n    ConcatOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { A: input.A, B: input.B });\n        }\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A, B: input.B }, { axis: input.axis });\n    };\n    ConcatOperation.prototype.getOutputShape = function (input) {\n        var outputShape = __spreadArrays(input.A.shape);\n        outputShape[input.axis] += input.B.shape[input.axis];\n        return outputShape;\n    };\n    ConcatOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        if (info.shapeB !== undefined) {\n            this.maxRank = info.shapeB.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ConcatOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.B.shape,\n            widthB: input.B.memory.width,\n            heightB: input.B.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            axis: input.axis\n        };\n    };\n    ConcatOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape + \"-\" + input.axis;\n    };\n    return ConcatOperation;\n}(Operation));\nexport { ConcatOperation };\n//# sourceMappingURL=concat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar CopyOperation = /** @class */ (function (_super) {\n    __extends(CopyOperation, _super);\n    function CopyOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    CopyOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      gl_FragColor = texture2D(X, uv);\\n    }\\n    \";\n    };\n    CopyOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    CopyOperation.prototype.calc = function (input) {\n        var shape = this.getOutputShape(input);\n        return this.compute(shape, { X: input.input });\n    };\n    CopyOperation.prototype.getOutputShape = function (input) {\n        var shape = input.outputShape;\n        if (shape === undefined) {\n            shape = input.input.shape;\n        }\n        return shape;\n    };\n    CopyOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    CopyOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height\n        };\n    };\n    CopyOperation.prototype.getInputInfoString = function (input) {\n        return input.input + \"-\" + this.getOutputShape(input);\n    };\n    return CopyOperation;\n}(Operation));\nexport { CopyOperation };\n//# sourceMappingURL=copy.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar ExpandOperation = /** @class */ (function (_super) {\n    __extends(ExpandOperation, _super);\n    function ExpandOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ExpandOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      return _X(index);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ExpandOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    ExpandOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { X: input.input });\n    };\n    ExpandOperation.prototype.getOutputShape = function (input) {\n        return input.outputShape;\n    };\n    ExpandOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ExpandOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height\n        };\n    };\n    ExpandOperation.prototype.getInputInfoString = function (input) {\n        return input.input.shape + \"-\" + input.outputShape;\n    };\n    return ExpandOperation;\n}(Operation));\nexport { ExpandOperation };\n//# sourceMappingURL=expand.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { computeStrides, getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar GatherOperation = /** @class */ (function (_super) {\n    __extends(GatherOperation, _super);\n    function GatherOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.gatherMaxIxSize = 10;\n        return _this;\n    }\n    GatherOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('axis') + \" int axis;\\n    \" + this.getVarModifier('indexValues') + \" int indexValues[\" + this.gatherMaxIxSize + \"];\\n    \" + this.getVarModifier('mappedIndexStrides') + \" int mappedIndexStrides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int mappedInputStrides[\" + this.maxRank + \"];\\n    \";\n    };\n    GatherOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"axis\" },\n            { name: \"indexValues\", length: this.gatherMaxIxSize },\n            { name: \"mappedInputStrides\", length: this.maxRank },\n            { name: \"mappedIndexStrides\", length: this.maxRank }\n        ];\n    };\n    GatherOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputPos = 0;\\n      int indexPos = 0;\\n\\n      int strideAxis = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n        if (i == axis) {\\n          strideAxis = stridesX[i];\\n        }\\n        inputPos += mappedInputStrides[i]*index[i];\\n        indexPos += mappedIndexStrides[i]*index[i];\\n      }\\n\\n      for (int i = 0; i < \" + this.gatherMaxIxSize + \"; i++) {\\n        if (i == indexPos) {\\n          inputPos += indexValues[i]*strideAxis;\\n          break;\\n        }\\n      }\\n\\n      return getValueAtPos(inputPos, widthX, heightX, X);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GatherOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    GatherOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        if (input.indices.size > this.gatherMaxIxSize) {\n            throw new Error(\"Gather on GPU can deal with at most \" + this.gatherMaxIxSize + \" indices, input had \" + input.indices.size);\n        }\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var inputStrides = computeStrides(input.X.shape);\n        var indexStrides = computeStrides(input.indices.shape);\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        var mappedInputStrides = new Array(resultRank).fill(0);\n        var mappedIndexStrides = new Array(resultRank).fill(0);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n            mappedInputStrides[i] = inputStrides[i];\n            mappedIndexStrides[i] = 0;\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n            mappedIndexStrides[i + input.axis] = indexStrides[i];\n            mappedInputStrides[i + input.axis] = 0;\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n            mappedInputStrides[i + q - 1] = inputStrides[i];\n            mappedIndexStrides[i + q - 1] = 0;\n        }\n        return this.compute(resultShape, { X: input.X }, {\n            axis: input.axis,\n            indexValues: this.pad(Array.from(input.indices.values), this.gatherMaxIxSize),\n            mappedInputStrides: this.pad(mappedInputStrides),\n            mappedIndexStrides: this.pad(mappedIndexStrides)\n        });\n    };\n    GatherOperation.prototype.getOutputShape = function (input) {\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n        }\n        return resultShape;\n    };\n    GatherOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n            if (info.indices !== undefined && info.axis !== undefined) {\n                var r = info.shapeX.length;\n                var q = info.indices.shape.length;\n                var inputStrides = computeStrides(info.shapeX);\n                var indexStrides = computeStrides(info.indices.shape);\n                var resultRank = r + q - 1;\n                var resultShape = new Array(resultRank);\n                var mappedInputStrides = new Array(resultRank).fill(0);\n                var mappedIndexStrides = new Array(resultRank).fill(0);\n                for (var i = 0; i < info.axis; i++) {\n                    resultShape[i] = info.shapeX[i];\n                    mappedInputStrides[i] = inputStrides[i];\n                    mappedIndexStrides[i] = 0;\n                }\n                for (var i = 0; i < q; i++) {\n                    resultShape[i + info.axis] = info.indices.shape[i];\n                    mappedIndexStrides[i + info.axis] = indexStrides[i];\n                    mappedInputStrides[i + info.axis] = 0;\n                }\n                for (var i = info.axis + 1; i < r; i++) {\n                    resultShape[i + q - 1] = info.shapeX[i];\n                    mappedInputStrides[i + q - 1] = inputStrides[i];\n                    mappedIndexStrides[i + q - 1] = 0;\n                }\n                info.mappedIndexStrides = mappedIndexStrides;\n                info.mappedInputStrides = mappedInputStrides;\n                info.indexValues = Array.from(info.indices.values);\n                delete info['indices'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    GatherOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var inputStrides = computeStrides(input.X.shape);\n        var indexStrides = computeStrides(input.indices.shape);\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        var mappedInputStrides = new Array(resultRank).fill(0);\n        var mappedIndexStrides = new Array(resultRank).fill(0);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n            mappedInputStrides[i] = inputStrides[i];\n            mappedIndexStrides[i] = 0;\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n            mappedIndexStrides[i + input.axis] = indexStrides[i];\n            mappedInputStrides[i + input.axis] = 0;\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n            mappedInputStrides[i + q - 1] = inputStrides[i];\n            mappedIndexStrides[i + q - 1] = 0;\n        }\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            axis: input.axis,\n            indexValues: Array.from(input.indices.values),\n            mappedIndexStrides: mappedIndexStrides,\n            mappedInputStrides: mappedInputStrides\n        };\n    };\n    GatherOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axis + \"-\" + Array.from(input.indices.values) + \"-\" + input.indices.shape;\n    };\n    return GatherOperation;\n}(Operation));\nexport { GatherOperation };\n//# sourceMappingURL=gather.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nvar GemmOperation = /** @class */ (function (_super) {\n    __extends(GemmOperation, _super);\n    function GemmOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    GemmOperation.prototype.getMainBody = function () {\n        return \"\\n      int ixA[\" + this.maxRank + \"];\\n      \" + this.initIndex('ixA') + \"\\n      int ixB[\" + this.maxRank + \"];\\n      \" + this.initIndex('ixA') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i >= rank - 2) {\\n          break;\\n        }\\n        ixA[i] = index[i];\\n        ixB[i] = index[i];\\n      }\\n\\n      int m = 0;\\n      int o = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i == rank-2) {\\n          m = index[i];\\n          o = index[i+1];\\n\\n          if (aTranspose == 0) {\\n            ixA[i] = m;\\n          } else {\\n            ixA[i+1] = m;\\n          }\\n\\n          if (bTranspose == 0) {\\n            ixB[i+1] = o;\\n          } else {\\n            ixB[i] = o;\\n          }\\n\\n          break;\\n        }\\n      }\\n\\n      float res = 0.0;\\n\\n      for (int n = 0; n < \" + this.maxIterations + \"; n++) {\\n        if (n >= N) {\\n          break;\\n        }\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (i == rank-2) {\\n            if (aTranspose == 0) {\\n              ixA[i+1] = n;\\n            } else {\\n              ixA[i] = n;\\n            }\\n\\n            if (bTranspose == 0) {\\n              ixB[i] = n;\\n            } else {\\n              ixB[i+1] = n;\\n            }\\n\\n            break;\\n          }\\n        }\\n        res += _A(ixA) * _B(ixB);\\n      }\\n\\n      res = res*alpha;\\n    \";\n    };\n    GemmOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('M') + \" int M;\\n    \" + this.getVarModifier('N') + \" int N;\\n    \" + this.getVarModifier('O') + \" int O;\\n    \" + this.getVarModifier('rank') + \" int rank;\\n    \" + this.getVarModifier('aTranspose') + \" int aTranspose;\\n    \" + this.getVarModifier('bTranspose') + \" int bTranspose;\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \" + this.getVarModifier('beta') + \" float beta;\\n    \";\n    };\n    GemmOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      \" + this.getMainBody() + \"\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GemmOperation.prototype.getTextureNames = function () {\n        return [\"A\", \"B\"];\n    };\n    GemmOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"M\" },\n            { name: \"N\" },\n            { name: \"O\" },\n            { name: \"rank\" },\n            { name: \"aTranspose\" },\n            { name: \"bTranspose\" },\n            { name: \"alpha\", type: \"float\" },\n            { name: \"beta\", type: \"float\" }\n        ];\n    };\n    GemmOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { A: input.a, B: input.b });\n        }\n        var rank = input.a.shape.length;\n        var M = input.aTranspose ? input.a.shape[rank - 1] : input.a.shape[rank - 2];\n        var N = input.aTranspose ? input.a.shape[rank - 2] : input.a.shape[rank - 1];\n        var O = input.bTranspose ? input.b.shape[rank - 2] : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        var uniforms = {\n            M: M, N: N, O: O, rank: rank,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta\n        };\n        return this.compute(resultShape, { A: input.a, B: input.b }, uniforms);\n    };\n    GemmOperation.prototype.getOutputShape = function (input) {\n        var rank = input.a.shape.length;\n        var M = input.aTranspose ? input.a.shape[rank - 1] : input.a.shape[rank - 2];\n        var O = input.bTranspose ? input.b.shape[rank - 2] : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        return resultShape;\n    };\n    GemmOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            var rank = info.shapeA.length;\n            info.rank = rank;\n            this.maxRank = rank;\n            if (info.aTranspose !== undefined) {\n                var M = info.aTranspose ? info.shapeA[rank - 1] : info.shapeA[rank - 2];\n                var N = info.aTranspose ? info.shapeA[rank - 2] : info.shapeA[rank - 1];\n                info.M = M;\n                info.N = N;\n                info.aTranspose = info.aTranspose ? 1 : 0;\n            }\n        }\n        if (info.shapeB !== undefined && info.bTranspose !== undefined) {\n            var rank = info.shapeB.length;\n            var O = info.bTranspose ? info.shapeB[rank - 2] : info.shapeB[rank - 1];\n            info.O = O;\n            info.bTranspose = info.bTranspose ? 1 : 0;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    GemmOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.a.shape.length;\n        var M = input.aTranspose ? input.a.shape[rank - 1] : input.a.shape[rank - 2];\n        var N = input.aTranspose ? input.a.shape[rank - 2] : input.a.shape[rank - 1];\n        var O = input.bTranspose ? input.b.shape[rank - 2] : input.b.shape[rank - 1];\n        var info = {\n            shapeA: input.a.shape,\n            widthA: input.a.memory.width,\n            heightA: input.a.memory.height,\n            shapeB: input.b.shape,\n            widthB: input.b.memory.width,\n            heightB: input.b.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            M: M, N: N, O: O,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta,\n            rank: rank\n        };\n        return info;\n    };\n    GemmOperation.prototype.getInputInfoString = function (input) {\n        //TODO: Check precision of alpha and beta\n        return input.a.shape + \"-\" + input.b.shape + \"-\" + input.aTranspose + \"-\" + input.bTranspose + \"-\" + input.alpha + \"-\" + input.beta;\n    };\n    return GemmOperation;\n}(Operation));\nexport { GemmOperation };\nvar GemmCOperation = /** @class */ (function (_super) {\n    __extends(GemmCOperation, _super);\n    function GemmCOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GemmCOperation.prototype.getTextureNames = function () {\n        return [\"A\", \"B\", \"C\"];\n    };\n    GemmCOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      \" + this.getMainBody() + \"\\n\\n      res += beta*_C(index);\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GemmCOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { A: input.a, B: input.b, C: input.c });\n        }\n        var rank = input.a.shape.length;\n        var M = input.aTranspose ? input.a.shape[rank - 1] : input.a.shape[rank - 2];\n        var N = input.aTranspose ? input.a.shape[rank - 2] : input.a.shape[rank - 1];\n        var O = input.bTranspose ? input.b.shape[rank - 2] : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        var uniforms = {\n            M: M, N: N, O: O, rank: rank,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta\n        };\n        return this.compute(resultShape, { A: input.a, B: input.b, C: input.c }, uniforms);\n    };\n    GemmCOperation.prototype.getCompilationInfo = function (input, precision) {\n        var inf = _super.prototype.getCompilationInfo.call(this, input, precision);\n        var info = __assign(__assign({}, inf), { shapeC: input.c.shape, widthC: input.c.memory.width, heightC: input.c.memory.height });\n        return info;\n    };\n    GemmCOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.c.shape;\n    };\n    return GemmCOperation;\n}(GemmOperation));\nexport { GemmCOperation };\n//# sourceMappingURL=gemm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from \"./binaryOperation\";\nvar PowerOperation = /** @class */ (function (_super) {\n    __extends(PowerOperation, _super);\n    function PowerOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    PowerOperation.prototype.getOp = function (a, b) {\n        return \"pow(\" + a + \", \" + b + \")\";\n    };\n    return PowerOperation;\n}(BinaryOperation));\nexport { PowerOperation };\n//# sourceMappingURL=power.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar SqrtOperation = /** @class */ (function (_super) {\n    __extends(SqrtOperation, _super);\n    function SqrtOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SqrtOperation.prototype.operation = function (input) {\n        return \"sqrt(\" + input + \")\";\n    };\n    return SqrtOperation;\n}(UnaryOperation));\nexport { SqrtOperation };\n//# sourceMappingURL=sqrt.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from \"./unaryOperation\";\nvar LogOperation = /** @class */ (function (_super) {\n    __extends(LogOperation, _super);\n    function LogOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    LogOperation.prototype.operation = function (input) {\n        return \"log(\" + input + \")\";\n    };\n    return LogOperation;\n}(UnaryOperation));\nexport { LogOperation };\n//# sourceMappingURL=log.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { computeStrides, getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar TransposeOperation = /** @class */ (function (_super) {\n    __extends(TransposeOperation, _super);\n    function TransposeOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    TransposeOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('mappedStrides') + \" int mappedStrides[\" + this.maxRank + \"];\\n    \";\n    };\n    TransposeOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"mappedStrides\", length: this.maxRank }\n        ];\n    };\n    TransposeOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      return getValueAt(index, mappedStrides, widthA, heightA, A);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    TransposeOperation.prototype.getTextureNames = function () {\n        return [\"A\"];\n    };\n    TransposeOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { A: input.A });\n        }\n        var rank = input.A.shape.length;\n        var outputShape = this.getOutputShape(input);\n        var inputStrides = computeStrides(input.A.shape);\n        var mappedStrides = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            mappedStrides[i] = inputStrides[input.permutation[i]];\n        }\n        return this.compute(outputShape, { A: input.A }, { mappedStrides: this.pad(mappedStrides) });\n    };\n    TransposeOperation.prototype.getOutputShape = function (input) {\n        var rank = input.A.shape.length;\n        var outputShape = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            outputShape[i] = input.A.shape[input.permutation[i]];\n        }\n        return outputShape;\n    };\n    TransposeOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n            if (info.permutation !== undefined) {\n                var rank = info.shapeA.length;\n                var inputStrides = computeStrides(info.shapeA);\n                var mappedStrides = new Array(rank);\n                for (var i = 0; i < rank; i++) {\n                    mappedStrides[i] = inputStrides[info.permutation[i]];\n                }\n                info.mappedStrides = mappedStrides;\n                delete info['permutation'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    TransposeOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.A.shape.length;\n        var inputStrides = computeStrides(input.A.shape);\n        var mappedStrides = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            mappedStrides[i] = inputStrides[input.permutation[i]];\n        }\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            mappedStrides: mappedStrides\n        };\n    };\n    TransposeOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.permutation;\n    };\n    return TransposeOperation;\n}(Operation));\nexport { TransposeOperation };\n//# sourceMappingURL=transpose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar RepeatOperation = /** @class */ (function (_super) {\n    __extends(RepeatOperation, _super);\n    function RepeatOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    RepeatOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('repeats') + \" int repeats[\" + this.maxRank + \"];\\n    \";\n    };\n    RepeatOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"repeats\", length: this.maxRank }\n        ];\n    };\n    RepeatOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIndex[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIndex') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (repeats[i] == -1) {\\n          break;\\n        }\\n        int d = index[i] / shapeA[i];\\n        inIndex[i] = index[i] - d*shapeA[i];\\n      }\\n\\n      return _A(inIndex);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    RepeatOperation.prototype.getOutputShape = function (input) {\n        var rank = input.A.shape.length;\n        var outputShape = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            outputShape[i] = input.A.shape[i] * input.repeats[i];\n        }\n        return outputShape;\n    };\n    RepeatOperation.prototype.getTextureNames = function () {\n        return [\"A\"];\n    };\n    RepeatOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { A: input.A });\n        }\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A }, { repeats: this.copyPad(input.repeats) });\n    };\n    RepeatOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    RepeatOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            repeats: input.repeats\n        };\n    };\n    RepeatOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.repeats;\n    };\n    return RepeatOperation;\n}(Operation));\nexport { RepeatOperation };\n//# sourceMappingURL=repeat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar PadOperation = /** @class */ (function (_super) {\n    __extends(PadOperation, _super);\n    function PadOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    PadOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n      if (mode == 0) {\\n        float res = value;\\n\\n        int outOfBounds = 0;\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0 || inputIx[i] >= shapeX[i]) {\\n            outOfBounds = 1;\\n            break;\\n          }\\n        }\\n\\n        if (outOfBounds == 0) {\\n          res = _X(inputIx);\\n        }\\n\\n        return res;\\n      } else if (mode == 1) {\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0) {\\n            inputIx[i] = -inputIx[i];\\n          } else if (inputIx[i] >= shapeX[i]) {\\n            inputIx[i] = 2*shapeX[i] - inputIx[i] - 2;\\n          }\\n        }\\n\\n        return _X(inputIx);\\n      } else {\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0) {\\n            inputIx[i] = 0;\\n          } else if (inputIx[i] >= shapeX[i]) {\\n            inputIx[i] = shapeX[i] - 1;\\n          }\\n        }\\n\\n        return _X(inputIx);\\n      }\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    PadOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    PadOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank * 2 + \"];\\n    \" + this.getVarModifier('value') + \" float value;\\n    \" + this.getVarModifier('mode') + \" int mode;\\n    \";\n    };\n    PadOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"value\", type: \"float\" },\n            { name: \"pads\", length: this.maxRank * 2 },\n            { name: \"mode\" }\n        ];\n    };\n    PadOperation.prototype.getModeFlag = function (mode) {\n        return mode === \"constant\" ? 0 : mode === \"reflect\" ? 1 : 2;\n    };\n    PadOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.input });\n        }\n        var resultShape = this.getOutputShape(input);\n        return this.compute(resultShape, { X: input.input }, {\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            value: input.value,\n            mode: this.getModeFlag(input.mode)\n        });\n    };\n    PadOperation.prototype.getOutputShape = function (input) {\n        var rank = input.input.shape.length;\n        var resultShape = __spreadArrays(input.input.shape);\n        for (var i = 0; i < rank; i++) {\n            resultShape[i] += input.pads[i] + input.pads[i + rank];\n        }\n        return resultShape;\n    };\n    PadOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.mode !== undefined && typeof info.mode === 'string') {\n            info.mode = this.getModeFlag(info.mode);\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    PadOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            mode: this.getModeFlag(input.mode),\n            value: input.value\n        };\n    };\n    PadOperation.prototype.getInputInfoString = function (input) {\n        //TODO: Format value with enough precision?\n        return input.input.shape + \"-\" + input.pads + \"-\" + input.mode + \"-\" + input.value;\n    };\n    return PadOperation;\n}(Operation));\nexport { PadOperation };\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar SliceOperation = /** @class */ (function (_super) {\n    __extends(SliceOperation, _super);\n    function SliceOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SliceOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIx') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n\\n        inIx[i] = index[i] + offsets[i];\\n      }\\n\\n      return _X(inIx);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    SliceOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    SliceOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('offsets') + \" int offsets[\" + this.maxRank + \"];\\n    \";\n    };\n    SliceOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"offsets\", length: this.maxRank }\n        ];\n    };\n    SliceOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var offsets = new Array(rank).fill(0);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i == input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                offsets[i] = input.starts[axIx];\n                axIx++;\n            }\n        }\n        return this.compute(resultShape, { X: input.X }, {\n            offsets: this.pad(offsets)\n        });\n    };\n    SliceOperation.prototype.getOutputShape = function (input) {\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i == input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                axIx++;\n            }\n        }\n        return resultShape;\n    };\n    SliceOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n            if (info.axes !== undefined && info.starts !== undefined && info.starts !== undefined) {\n                var rank = info.shapeX.length;\n                var offsets = new Array(rank).fill(0);\n                var axIx = 0;\n                for (var i = 0; i < rank && axIx < info.axes.length; i++) {\n                    if (i == info.axes[axIx]) {\n                        offsets[i] = info.starts[axIx];\n                        axIx++;\n                    }\n                }\n                info.offsets = offsets;\n                delete info['starts'];\n                delete info['ends'];\n                delete info['axes'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    SliceOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var offsets = new Array(rank).fill(0);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i == input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                offsets[i] = input.starts[axIx];\n                axIx++;\n            }\n        }\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            offsets: offsets\n        };\n    };\n    SliceOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axes + \"-\" + input.starts + \"-\" + input.ends;\n    };\n    return SliceOperation;\n}(Operation));\nexport { SliceOperation };\n//# sourceMappingURL=slice.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar UpsampleOperation = /** @class */ (function (_super) {\n    __extends(UpsampleOperation, _super);\n    function UpsampleOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    UpsampleOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIx') + \"\\n\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n\\n        inIx[i] = int(floor(float(index[i]) / scales[i]));\\n      }\\n\\n      return _X(inIx);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    UpsampleOperation.prototype.getTextureNames = function () {\n        return [\"X\"];\n    };\n    UpsampleOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('scales') + \" float scales[\" + this.maxRank + \"];\\n    \";\n    };\n    UpsampleOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"scales\", length: this.maxRank, type: \"float\" }\n        ];\n    };\n    UpsampleOperation.prototype.calc = function (input) {\n        if (this.fullyStatic) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var resultShape = this.getOutputShape(input);\n        return this.compute(resultShape, { X: input.X }, {\n            scales: this.copyPad(input.scales)\n        });\n    };\n    UpsampleOperation.prototype.getOutputShape = function (input) {\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        for (var i = 0; i < rank; i++) {\n            resultShape[i] = Math.floor(resultShape[i] * input.scales[i]);\n        }\n        return resultShape;\n    };\n    UpsampleOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UpsampleOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            scales: input.scales\n        };\n    };\n    UpsampleOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.scales;\n    };\n    return UpsampleOperation;\n}(Operation));\nexport { UpsampleOperation };\n//# sourceMappingURL=upsample.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from \"../../../tensor/gpu/gl\";\nimport { getSize } from \"../../../util/shape\";\nimport { Operation } from \"../operation\";\nvar NormalizeOperation = /** @class */ (function (_super) {\n    __extends(NormalizeOperation, _super);\n    function NormalizeOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    NormalizeOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('epsilon') + \" float epsilon;\\n    \";\n    };\n    NormalizeOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: \"epsilon\", type: \"float\" }\n        ];\n    };\n    NormalizeOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int[\" + this.maxRank + \"] index) {\\n      float result = _X(index) - _Mean(index);\\n      result = result / sqrt(_Variance(index) + epsilon);\\n      result = result * _Scale(index) + _Bias(index);\\n      return result;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    NormalizeOperation.prototype.getOutputShape = function (input) {\n        return input.X.shape;\n    };\n    NormalizeOperation.prototype.getTextureNames = function () {\n        return [\"X\", \"Mean\", \"Variance\", \"Scale\", \"Bias\"];\n    };\n    NormalizeOperation.prototype.calc = function (input) {\n        return this.compute(input.X.shape, {\n            X: input.X,\n            Mean: input.Mean,\n            Variance: input.Variance,\n            Scale: input.Scale,\n            Bias: input.Bias\n        }, { epsilon: input.epsilon });\n    };\n    NormalizeOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    NormalizeOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeBias: input.Bias.shape,\n            widthBias: input.Bias.memory.width,\n            heightBias: input.Bias.memory.height,\n            shapeMean: input.Mean.shape,\n            widthMean: input.Mean.memory.width,\n            heightMean: input.Mean.memory.height,\n            shapeScale: input.Scale.shape,\n            widthScale: input.Scale.memory.width,\n            heightScale: input.Scale.memory.height,\n            shapeVariance: input.Variance.shape,\n            widthVariance: input.Variance.memory.width,\n            heightVariance: input.Variance.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            epsilon: input.epsilon\n        };\n    };\n    NormalizeOperation.prototype.getInputInfoString = function (input) {\n        // TODO: Format epsilon with enough precision?\n        return input.X.shape + \"-\" + input.Mean.shape + \"-\" + input.Variance.shape + \"-\" + input.Scale.shape + \"-\" + input.Bias.shape + \"-\" + input.epsilon;\n    };\n    return NormalizeOperation;\n}(Operation));\nexport { NormalizeOperation };\n//# sourceMappingURL=normalize.js.map","var Dispatcher = /** @class */ (function () {\n    function Dispatcher(getOp, minCallsToCompile) {\n        if (minCallsToCompile === void 0) { minCallsToCompile = 2; }\n        this.getOp = getOp;\n        this.minCallsToCompile = minCallsToCompile;\n        this.opDict = {};\n    }\n    Dispatcher.prototype.getDefault = function (precision) {\n        var str = \"default-\" + precision;\n        if (this.opDict[str] === undefined) {\n            var op = this.getOp();\n            op.compile({}, precision);\n            this.opDict[str] = {\n                infoString: str,\n                numCalls: 0,\n                operation: op\n            };\n        }\n        return this.opDict[str];\n    };\n    Dispatcher.prototype.calc = function (input, precision) {\n        var defaultOp = this.getDefault(precision);\n        var compileInfoString = defaultOp.operation.getInputInfoString(input);\n        if (this.opDict[compileInfoString] === undefined) {\n            this.opDict[compileInfoString] = {\n                infoString: compileInfoString,\n                numCalls: 0\n            };\n        }\n        var opInfo = this.opDict[compileInfoString];\n        opInfo.numCalls++;\n        if (opInfo.numCalls === this.minCallsToCompile) {\n            opInfo.operation = this.getOp();\n            var compileInfo = defaultOp.operation.getCompilationInfo(input, precision);\n            opInfo.operation.compile(compileInfo, precision);\n        }\n        if (opInfo.numCalls >= this.minCallsToCompile) {\n            return opInfo.operation.calc(input);\n        }\n        else {\n            defaultOp.numCalls++;\n            return defaultOp.operation.calc(input);\n        }\n    };\n    return Dispatcher;\n}());\nexport { Dispatcher };\n//# sourceMappingURL=dispatcher.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes, getSize } from '../../util/shape';\nimport { MatMulOperation } from '../../ops/gpu/matMul/matmul';\nimport { defaultAllocator, gl } from './gl';\nimport { ExpOperation } from '../../ops/gpu/unary/exp';\nimport { ConvBiasOperation, ConvOperation } from '../../ops/gpu/conv/conv';\nimport { AbsOperation } from '../../ops/gpu/unary/abs';\nimport { AddOperation } from '../../ops/gpu/binary/add';\nimport { MultiplyOperation } from '../../ops/gpu/binary/multiply';\nimport { SubtractOperation } from '../../ops/gpu/binary/subtract';\nimport { DivideOperation } from '../../ops/gpu/binary/divide';\nimport { AveragePoolOperation } from '../../ops/gpu/conv/averagePool';\nimport { ReduceMeanOperation } from '../../ops/gpu/pool/reduceMean';\nimport { ReduceMeanSquareOperation } from '../../ops/gpu/pool/reduceMeanSquare';\nimport { SumSquareOperation } from '../../ops/gpu/pool/sumSquare';\nimport { SumOperation } from '../../ops/gpu/pool/sum';\nimport { ProductOperation } from '../../ops/gpu/pool/product';\nimport { MaxOperation } from '../../ops/gpu/pool/max';\nimport { MinOperation } from '../../ops/gpu/pool/min';\nimport { CeilOperation } from '../../ops/gpu/unary/ceil';\nimport { ClipOperation } from '../../ops/gpu/unary/clip';\nimport { FloorOperation } from '../../ops/gpu/unary/floor';\nimport { ConcatOperation } from '../../ops/gpu/util/concat';\nimport { CopyOperation } from '../../ops/gpu/util/copy';\nimport { ExpandOperation } from '../../ops/gpu/util/expand';\nimport { GatherOperation } from '../../ops/gpu/util/gather';\nimport { GemmCOperation, GemmOperation } from '../../ops/gpu/matMul/gemm';\nimport { PowerOperation } from '../../ops/gpu/binary/power';\nimport { SqrtOperation } from '../../ops/gpu/unary/sqrt';\nimport { LogOperation } from '../../ops/gpu/unary/log';\nimport { TransposeOperation } from '../../ops/gpu/util/transpose';\nimport { RepeatOperation } from '../../ops/gpu/util/repeat';\nimport { PadOperation } from '../../ops/gpu/conv/pad';\nimport { SliceOperation } from '../../ops/gpu/util/slice';\nimport { UpsampleOperation } from '../../ops/gpu/conv/upsample';\nimport { NormalizeOperation } from '../../ops/gpu/conv/normalize';\nimport { Dispatcher } from '../../ops/gpu/dispatcher';\nvar GPUTensor = /** @class */ (function (_super) {\n    __extends(GPUTensor, _super);\n    function GPUTensor(values, shape, precision) {\n        var _this = _super.call(this) || this;\n        _this.shape = shape;\n        _this.precision = precision;\n        _this.deleted = false;\n        _this.size = getSize(shape);\n        if (values instanceof Float32Array) {\n            _this.memory = defaultAllocator.allocateTexture(values, precision);\n        }\n        else {\n            _this.memory = values;\n        }\n        return _this;\n    }\n    GPUTensor.fromData = function (data, precision) {\n        var texture = gl.texture({\n            data: data,\n            format: \"rgba\",\n            type: precision === 32 ? \"float\" : \"half float\"\n        });\n        var memory = defaultAllocator.allocateFramebuffer(texture, precision);\n        var width = texture.width;\n        var height = texture.height;\n        return new GPUTensor(memory, [height, width, 4], precision);\n    };\n    GPUTensor.prototype.getValues = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            gl({ framebuffer: _this.memory.frameBuffer })(function () {\n                var result = new Float32Array(_this.memory.size);\n                result = gl.read(result);\n                resolve(result.subarray(0, _this.size));\n            });\n        });\n    };\n    GPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    GPUTensor.prototype.gpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    GPUTensor.prototype.delete = function () {\n        this.deleted = true;\n        defaultAllocator.deallocate(this.memory);\n        this.memory = undefined;\n    };\n    GPUTensor.prototype.copy = function (precision) {\n        return defaultCopyD.calc({ input: this }, precision ? precision : this.precision);\n    };\n    GPUTensor.prototype.exp = function () {\n        return defaultExpD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.log = function () {\n        return defaultLogD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.sqrt = function () {\n        return defaultSqrtD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.abs = function () {\n        return defaultAbsD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.floor = function () {\n        return defaultFloorD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.ceil = function () {\n        return defaultCeilD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only add GPU tensor to GPU tensor');\n        }\n        return defaultAddD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only subtract GPU tensor from GPU tensor');\n        }\n        return defaultSubtractD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only multiply GPU tensor with GPU tensor');\n        }\n        return defaultMultiplyD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only divide GPU tensor by GPU tensor');\n        }\n        return defaultDivideD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only take GPU tensor to power of GPU tensor');\n        }\n        return defaultPowerD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only matrix multiply GPU tensor to GPU tensor');\n        }\n        return defaultMatMulD.calc({ A: this, B: tensor }, this.precision);\n    };\n    GPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof GPUTensor && (c === undefined || c instanceof GPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        if (c === undefined) {\n            return defaultGemmD.calc({ a: this, b: b, aTranspose: aTranspose, bTranspose: bTranspose, alpha: alpha, beta: beta }, this.precision);\n        }\n        else {\n            return defaultGemmCD.calc({ a: this, b: b, c: c, aTranspose: aTranspose, bTranspose: bTranspose, alpha: alpha, beta: beta }, this.precision);\n        }\n    };\n    GPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return defaultSumD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return defaultSumSquareD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return defaultMeanD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return defaultMeanSquareD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return defaultProductD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return defaultMaxD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return defaultMinD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias, activation) {\n        if (!(kernel instanceof GPUTensor) || (bias !== undefined && !(bias instanceof GPUTensor))) {\n            throw new Error('Can only do convolution of GPU tensor with GPU tensor');\n        }\n        if (bias === undefined) {\n            return defaultConvD.calc({\n                X: this,\n                W: kernel,\n                pads: pads, dilations: dilations, strides: strides,\n                activation: activation\n            }, this.precision);\n        }\n        else {\n            return defaultConvBiasD.calc({\n                X: this,\n                W: kernel,\n                B: bias,\n                pads: pads, dilations: dilations, strides: strides,\n                activation: activation\n            }, this.precision);\n        }\n    };\n    GPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return defaultAveragePoolD.calc({\n            X: this,\n            includePad: includePad,\n            kernelShape: kernelShape,\n            pads: pads,\n            strides: strides\n        }, this.precision);\n    };\n    GPUTensor.prototype.reshape_impl = function (shape, _copy) {\n        if (_copy) {\n            return defaultCopyD.calc({ input: this, outputShape: shape }, this.precision);\n        }\n        else {\n            return new GPUTensor(this.memory, shape, this.precision);\n        }\n    };\n    GPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only concat GPU tensor to GPU tensor');\n        }\n        return defaultConcatD.calc({ A: this, B: tensor, axis: axis }, this.precision);\n    };\n    GPUTensor.prototype.transpose_impl = function (permutation) {\n        return defaultTransposeD.calc({ A: this, permutation: permutation }, this.precision);\n    };\n    GPUTensor.prototype.clip = function (min, max) {\n        return defaultClipD.calc({ input: this, minVal: min, maxVal: max }, this.precision);\n    };\n    GPUTensor.prototype.repeat = function (repeats) {\n        return defaultRepeatD.calc({ A: this, repeats: repeats }, this.precision);\n    };\n    GPUTensor.prototype.expand = function (shape) {\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return defaultExpandD.calc({ input: this.reshape(_shape, false), outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return defaultPadD.calc({ input: this, pads: pads, mode: mode, value: value }, this.precision);\n    };\n    GPUTensor.prototype.gather = function (axis, indices) {\n        return defaultGatherD.calc({ X: this, axis: axis, indices: indices }, this.precision);\n    };\n    GPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return defaultSliceD.calc({ X: this, starts: starts, ends: ends, axes: axes }, this.precision);\n    };\n    GPUTensor.prototype.upsample = function (scales) {\n        return defaultUpsampleD.calc({ X: this, scales: scales }, this.precision);\n    };\n    GPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof GPUTensor) || !(variance instanceof GPUTensor) || !(scale instanceof GPUTensor) || !(bias instanceof GPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return defaultNormalizeD.calc({\n            X: this,\n            Mean: mean,\n            Variance: variance,\n            Scale: scale,\n            Bias: bias,\n            epsilon: epsilon\n        }, this.precision);\n    };\n    return GPUTensor;\n}(Tensor));\nexport { GPUTensor };\nexport var gpuConstructor = function (a, b, precision) { return new GPUTensor(a, b, precision); };\nvar defaultMatMulD = new Dispatcher(function () { return new MatMulOperation(gpuConstructor); });\n//const defaultMatMul = new MatMulOperation(gpuConstructor);\nvar defaultGemmD = new Dispatcher(function () { return new GemmOperation(gpuConstructor); });\n//const defaultGemm = new GemmOperation(gpuConstructor);\nvar defaultGemmCD = new Dispatcher(function () { return new GemmCOperation(gpuConstructor); });\n//const defaultGemmC = new GemmCOperation(gpuConstructor);\n//Unary operations\nvar defaultExpD = new Dispatcher(function () { return new ExpOperation(gpuConstructor); });\n//const defaultExp = new ExpOperation(gpuConstructor);\nvar defaultAbsD = new Dispatcher(function () { return new AbsOperation(gpuConstructor); });\n//const defaultAbs = new AbsOperation(gpuConstructor);\nvar defaultCeilD = new Dispatcher(function () { return new CeilOperation(gpuConstructor); });\n//const defaultCeil = new CeilOperation(gpuConstructor);\nvar defaultFloorD = new Dispatcher(function () { return new FloorOperation(gpuConstructor); });\n//const defaultFloor = new FloorOperation(gpuConstructor);\nvar defaultClipD = new Dispatcher(function () { return new ClipOperation(gpuConstructor); });\n//const defaultClip = new ClipOperation(gpuConstructor);\nvar defaultSqrtD = new Dispatcher(function () { return new SqrtOperation(gpuConstructor); });\n//const defaultSqrt = new SqrtOperation(gpuConstructor);\nvar defaultLogD = new Dispatcher(function () { return new LogOperation(gpuConstructor); });\n//const defaultLog = new LogOperation(gpuConstructor);\n//Convolutions\nvar defaultConvD = new Dispatcher(function () { return new ConvOperation(gpuConstructor); });\n//const defaultConv = new ConvOperation(gpuConstructor);\nvar defaultAveragePoolD = new Dispatcher(function () { return new AveragePoolOperation(gpuConstructor); });\n//const defaultAveragePool = new AveragePoolOperation(gpuConstructor);\nvar defaultConvBiasD = new Dispatcher(function () { return new ConvBiasOperation(gpuConstructor); });\n//const defaultConvBias = new ConvBiasOperation(gpuConstructor);\nvar defaultPadD = new Dispatcher(function () { return new PadOperation(gpuConstructor); });\n//const defaultPad = new PadOperation(gpuConstructor);\nvar defaultUpsampleD = new Dispatcher(function () { return new UpsampleOperation(gpuConstructor); });\n//const defaultUpsample = new UpsampleOperation(gpuConstructor);\n//Binary operations\nvar defaultAddD = new Dispatcher(function () { return new AddOperation(gpuConstructor); });\n//const defaultAdd = new AddOperation(gpuConstructor);\nvar defaultSubtractD = new Dispatcher(function () { return new SubtractOperation(gpuConstructor); });\n//const defaultSubtract = new SubtractOperation(gpuConstructor);\nvar defaultMultiplyD = new Dispatcher(function () { return new MultiplyOperation(gpuConstructor); });\n//const defaultMultiply = new MultiplyOperation(gpuConstructor);\nvar defaultDivideD = new Dispatcher(function () { return new DivideOperation(gpuConstructor); });\n//const defaultDivide = new DivideOperation(gpuConstructor);\nvar defaultPowerD = new Dispatcher(function () { return new PowerOperation(gpuConstructor); });\n//const defaultPower = new PowerOperation(gpuConstructor);\n//Reductions\nvar defaultMeanD = new Dispatcher(function () { return new ReduceMeanOperation(gpuConstructor); });\n//const defaultMean = new ReduceMeanOperation(gpuConstructor);\nvar defaultMeanSquareD = new Dispatcher(function () { return new ReduceMeanSquareOperation(gpuConstructor); });\n//const defaultMeanSquare = new ReduceMeanSquareOperation(gpuConstructor);\nvar defaultSumSquareD = new Dispatcher(function () { return new SumSquareOperation(gpuConstructor); });\n//const defaultSumSquare = new SumSquareOperation(gpuConstructor);\nvar defaultSumD = new Dispatcher(function () { return new SumOperation(gpuConstructor); });\n//const defaultSum = new SumOperation(gpuConstructor);\nvar defaultProductD = new Dispatcher(function () { return new ProductOperation(gpuConstructor); });\n//const defaultProduct = new ProductOperation(gpuConstructor);\nvar defaultMaxD = new Dispatcher(function () { return new MaxOperation(gpuConstructor); });\n//const defaultMax = new MaxOperation(gpuConstructor);\nvar defaultMinD = new Dispatcher(function () { return new MinOperation(gpuConstructor); });\n//const defaultMin = new MinOperation(gpuConstructor);\n//Util\nvar defaultConcatD = new Dispatcher(function () { return new ConcatOperation(gpuConstructor); });\n//const defaultConcat = new ConcatOperation(gpuConstructor);\nvar defaultCopyD = new Dispatcher(function () { return new CopyOperation(gpuConstructor); });\n//const defaultCopy = new CopyOperation(gpuConstructor);\nvar defaultExpandD = new Dispatcher(function () { return new ExpandOperation(gpuConstructor); });\n//const defaultExpand = new ExpandOperation(gpuConstructor);\nvar defaultGatherD = new Dispatcher(function () { return new GatherOperation(gpuConstructor); });\n//const defaultGather = new GatherOperation(gpuConstructor);\nvar defaultTransposeD = new Dispatcher(function () { return new TransposeOperation(gpuConstructor); });\n//const defaultTranspose = new TransposeOperation(gpuConstructor);\nvar defaultRepeatD = new Dispatcher(function () { return new RepeatOperation(gpuConstructor); });\n//const defaultRepeat = new RepeatOperation(gpuConstructor);\nvar defaultSliceD = new Dispatcher(function () { return new SliceOperation(gpuConstructor); });\n//const defaultSlice = new SliceOperation(gpuConstructor);\nvar defaultNormalizeD = new Dispatcher(function () { return new NormalizeOperation(gpuConstructor); });\n//const defaultNormalize = new NormalizeOperation(gpuConstructor);\n//# sourceMappingURL=tensor.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../tensor/cpu/tensor\";\nimport { GPUTensor } from \"../tensor/gpu/tensor\";\nimport { WASMTensor } from \"../tensor/wasm/tensor\";\nexport function toCPU(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof CPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    return [2 /*return*/, new CPUTensor(tensor.getShape(), values)];\n            }\n        });\n    });\n}\nexport function toWASM(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof WASMTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new WASMTensor(values, new Uint32Array(tensor.getShape()))];\n            }\n        });\n    });\n}\nexport function toGPU(tensor, precision) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof GPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new GPUTensor(values, tensor.getShape(), precision)];\n            }\n        });\n    });\n}\n//# sourceMappingURL=convert.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Long from \"long\";\nvar OnnxNode = /** @class */ (function () {\n    function OnnxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        this.attributes = {};\n        for (var i = 0; i < attributes.length; i++) {\n            this.attributes[attributes[i].name] = attributes[i];\n        }\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.onnxVersion = onnxVersion;\n        this.variableInputs = 0;\n        for (var i = 0; i < this.inputs.length; i++) {\n            if (constants[this.inputs[i]] === undefined) {\n                this.variableInputs++;\n            }\n        }\n    }\n    OnnxNode.prototype.initialize = function (resolveConstant) { };\n    OnnxNode.prototype.getAttribute = function (name) {\n        return this.attributes[name];\n    };\n    OnnxNode.prototype.getAttributeString = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var str = attr.s;\n            if (str !== undefined) {\n                return new TextDecoder(\"utf-8\").decode(str);\n            }\n            return undefined;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInts = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = this.attributes[name].ints;\n            for (var i = 0; i < result.length; i++) {\n                if (Long.isLong(result[i])) {\n                    result[i] = result[i].toNumber();\n                }\n            }\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInt = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.i;\n            if (Long.isLong(result)) {\n                result = result.toNumber();\n            }\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeFloat = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.f;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeTensor = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.t;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    OnnxNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    OnnxNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    return OnnxNode;\n}());\nexport { OnnxNode };\n//# sourceMappingURL=node.js.map","import { CPUTensor } from \"../tensor/cpu/tensor\";\nimport { TENSOR_FLOAT, TENSOR_INT64 } from './definitions';\nimport Long from 'long';\nimport { getSize } from '../util/shape';\nexport function createTensor(tensorProto) {\n    if (tensorProto.segment !== undefined && tensorProto.segment !== null) {\n        throw new Error('Handling of tensor proto segment not yet implemented');\n    }\n    var shape = tensorProto.dims;\n    if (shape === undefined || shape === null) {\n        throw new Error('Tensor shape must be specified');\n    }\n    for (var i = 0; i < shape.length; i++) {\n        if (Long.isLong(shape[i])) {\n            shape[i] = shape[i].toNumber();\n        }\n    }\n    if (shape.length === 0) {\n        shape = [1];\n    }\n    var size = getSize(shape);\n    if (tensorProto.dataType === TENSOR_FLOAT) {\n        if (tensorProto.floatData && tensorProto.floatData.length > 0) {\n            return new CPUTensor(shape, tensorProto.floatData);\n        }\n        else if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var buffer = tensorProto.rawData.buffer.slice(tensorProto.rawData.byteOffset, tensorProto.rawData.byteOffset + tensorProto.rawData.byteLength);\n            var values = new Float32Array(buffer);\n            return new CPUTensor(shape, values);\n        }\n        else if (size === 0) {\n            return new CPUTensor(shape);\n        }\n        else {\n            throw new Error('Cant process float tensor without float or raw data');\n        }\n    }\n    else if (tensorProto.dataType === TENSOR_INT64) {\n        if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var values = new Int32Array(tensorProto.rawData.length / 8);\n            for (var i = 0; i < tensorProto.rawData.length; i += 8) {\n                var value = Long.fromBytesLE(Array.from(tensorProto.rawData.slice(i, i + 8))).toNumber();\n                values[i / 8] = value;\n            }\n            return new CPUTensor(shape, values, \"int\");\n        }\n        else {\n            throw new Error('Cant process int64 tensor without raw data');\n        }\n    }\n    else {\n        throw new Error(\"Handling of tensor type \" + tensorProto.dataType + \" not yet implemented\");\n    }\n}\n//# sourceMappingURL=util.js.map","// Attribute types\nexport var ATTRIBUTE_UNDEFINED = 0;\nexport var ATTRIBUTE_FLOAT = 1; // Float32\nexport var ATTRIBUTE_INT = 2; // Int64\nexport var ATTRIBUTE_STRING = 3;\nexport var ATTRIBUTE_TENSOR = 4;\nexport var ATTRIBUTE_GRAPH = 5;\nexport var ATTRIBUTE_SPARSE_TENSOR = 11;\nexport var ATTRIBUTE_FLOATS = 6;\nexport var ATTRIBUTE_INTS = 7;\nexport var ATTRIBUTE_STRINGS = 8;\nexport var ATTRIBUTE_TENSORS = 9;\nexport var ATTRIBUTE_GRAPHS = 10;\nexport var ATTRIBUTE_SPARSE_TENSORS = 12;\n// Tensor types\nexport var TENSOR_FLOAT = 1; // float  (32 bits)\nexport var TENSOR_UINT8 = 2; // uint8_t\nexport var TENSOR_INT8 = 3; // int8_t\nexport var TENSOR_UINT16 = 4; // uint16_t\nexport var TENSOR_INT16 = 5; // int16_t\nexport var TENSOR_INT32 = 6; // int32_t\nexport var TENSOR_INT64 = 7; // int64_t\nexport var TENSOR_STRING = 8; // string\nexport var TENSOR_BOOL = 9; // bool\nexport var TENSOR_FLOAT16 = 10;\nexport var TENSOR_DOUBLE = 11;\nexport var TENSOR_UINT32 = 12;\nexport var TENSOR_UINT64 = 13;\nexport var TENSOR_COMPLEX64 = 14; // complex with float32 real and imaginary components\nexport var TENSOR_COMPLEX128 = 15; // complex with float64 real and imaginary components\n// Non-IEEE floating-point format based on IEEE754 single-precision\n// floating-point number truncated to 16 bits.\n// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.\nexport var TENSOR_BFLOAT16 = 16;\n//# sourceMappingURL=definitions.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { toCPU, toGPU, toWASM } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nimport { createTensor } from \"../util\";\nvar ConstantNode = /** @class */ (function (_super) {\n    __extends(ConstantNode, _super);\n    function ConstantNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor(\"value\");\n            _this.tensor = createTensor(tensor);\n        }\n        return _this;\n    }\n    ConstantNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [this.tensor]];\n                }\n                throw new Error('Constant with onnx version >= 11 not yet implemented');\n            });\n        });\n    };\n    ConstantNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.tensor, precision)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.getType = function () {\n        return 'Constant';\n    };\n    ConstantNode.prototype.delete = function () {\n        this.tensor.delete();\n    };\n    return ConstantNode;\n}(OnnxNode));\nexport { ConstantNode };\n//# sourceMappingURL=constant.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { toCPU, toGPU, toWASM } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nvar ConvNode = /** @class */ (function (_super) {\n    __extends(ConvNode, _super);\n    function ConvNode(attributes, inputs, outputs, constants, onnxVersion, kernel, bias, activation) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        var autoPad = _this.getAttributeString('autoPad');\n        if (autoPad !== undefined) {\n            throw new Error('Autopad in conv not supported yet');\n        }\n        if (activation === undefined) {\n            activation = \"id\";\n        }\n        _this.activation = activation;\n        _this.group = _this.getAttributeInt('group') || 1;\n        _this.dilations = _this.getAttributeInts('dilations');\n        _this.pads = _this.getAttributeInts('pads');\n        _this.strides = _this.getAttributeInts('strides');\n        _this.kernel = kernel;\n        _this.bias = bias;\n        return _this;\n    }\n    ConvNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, w, b;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                w = this.kernel !== undefined ? this.kernel : inputs[1];\n                b = inputs.length > 2 ? inputs[2] : this.bias;\n                return [2 /*return*/, [x.conv(w, b, this.dilations, this.group, this.pads, this.strides, this.activation)]];\n            });\n        });\n    };\n    ConvNode.prototype.getDilations = function (rank) {\n        if (this.dilations !== undefined) {\n            return this.dilations;\n        }\n        return new Array(rank).fill(1);\n    };\n    ConvNode.prototype.getPads = function (rank) {\n        if (this.pads !== undefined) {\n            return this.pads;\n        }\n        return new Array(rank * 2).fill(0);\n    };\n    ConvNode.prototype.getStrides = function (rank) {\n        if (this.strides !== undefined) {\n            return this.strides;\n        }\n        return new Array(rank).fill(1);\n    };\n    ConvNode.prototype.getType = function () {\n        return 'Conv';\n    };\n    ConvNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.kernel)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toCPU(this.bias)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.kernel)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toWASM(this.bias)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.kernel, precision)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toGPU(this.bias, precision)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.delete = function () {\n        if (this.kernel !== undefined) {\n            this.kernel.delete();\n        }\n        if (this.bias !== undefined) {\n            this.bias.delete();\n        }\n    };\n    return ConvNode;\n}(OnnxNode));\nexport { ConvNode };\n//# sourceMappingURL=conv.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Optimization = /** @class */ (function () {\n    function Optimization() {\n    }\n    return Optimization;\n}());\nexport { Optimization };\nvar SequenceOptimization = /** @class */ (function (_super) {\n    __extends(SequenceOptimization, _super);\n    function SequenceOptimization(nodeTypes) {\n        var _this = _super.call(this) || this;\n        _this.nodeTypes = nodeTypes;\n        return _this;\n    }\n    SequenceOptimization.prototype.findApplications = function (model) {\n        var results = [];\n        var nodes = model.getNodes();\n        for (var nodeId in Object.keys(nodes)) {\n            var node = nodes[nodeId];\n            if (node !== undefined && node.getType() === this.nodeTypes[0]) {\n                var app = this.checkApplication(model, nodeId);\n                if (app !== undefined) {\n                    results.push(app);\n                }\n            }\n        }\n        return results;\n    };\n    SequenceOptimization.prototype.checkApplication = function (model, nodeId) {\n        var nodes = model.getNodes();\n        var nodeSeq = [nodeId];\n        var lastNode = nodes[nodeId];\n        var nodeInstances = [lastNode];\n        for (var i = 1; i < this.nodeTypes.length; i++) {\n            var nextNodeId = model.getNodeWithInput(lastNode.outputs[0]);\n            if (nextNodeId !== undefined) {\n                var nextNode = nodes[nextNodeId];\n                if (nextNode.getType() === this.nodeTypes[i]) {\n                    nodeSeq.push(nextNodeId);\n                    lastNode = nextNode;\n                    nodeInstances.push(lastNode);\n                }\n                else {\n                    return undefined;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        if (this.canApply(nodeInstances)) {\n            return nodeSeq;\n        }\n        else {\n            return undefined;\n        }\n    };\n    SequenceOptimization.prototype.canApply = function (nodes) {\n        return true;\n    };\n    return SequenceOptimization;\n}(Optimization));\nexport { SequenceOptimization };\n//# sourceMappingURL=optimization.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { ConvNode } from \"../nodes/conv\";\nimport { SequenceOptimization } from \"./optimization\";\nvar ConvBatchNorm = /** @class */ (function (_super) {\n    __extends(ConvBatchNorm, _super);\n    function ConvBatchNorm() {\n        return _super.call(this, ['Conv', 'BatchNormalization']) || this;\n    }\n    ConvBatchNorm.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var batchNorm = nodes[1];\n        var kernelConv = resolveConstant(conv.inputs[1]);\n        var biasConv = resolveConstant(conv.inputs[2]);\n        var scaleBN = resolveConstant(batchNorm.inputs[1]);\n        var biasBN = resolveConstant(batchNorm.inputs[2]);\n        var meanBN = resolveConstant(batchNorm.inputs[3]);\n        var varianceBN = resolveConstant(batchNorm.inputs[4]);\n        var varSqrt = varianceBN.add(batchNorm.epsTensor).sqrt();\n        var scale = scaleBN.divide(varSqrt);\n        varSqrt.delete();\n        var bias = biasBN.subtract(meanBN.multiply(scale));\n        var newShape = __spreadArrays(scale.getShape(), new Array(kernelConv.getShape().length - scale.getShape().length).fill(1));\n        var newKernel = kernelConv.multiply(scale.reshape(newShape, false));\n        var newBias = bias;\n        if (biasConv !== undefined) {\n            var scaledBias = biasConv.multiply(scale);\n            newBias = newBias.add(scaledBias);\n            scaledBias.delete();\n        }\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), [conv.inputs[0]], batchNorm.outputs, constants, onnxVersion, newKernel, newBias);\n    };\n    return ConvBatchNorm;\n}(SequenceOptimization));\nexport { ConvBatchNorm };\n//# sourceMappingURL=convBatchnorm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ConvNode } from \"../nodes/conv\";\nimport { SequenceOptimization } from \"./optimization\";\nvar ConvRelu = /** @class */ (function (_super) {\n    __extends(ConvRelu, _super);\n    function ConvRelu() {\n        return _super.call(this, ['Conv', 'Relu']) || this;\n    }\n    ConvRelu.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var relu = nodes[1];\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), conv.inputs, relu.outputs, constants, onnxVersion, conv.kernel, conv.bias, \"relu\");\n    };\n    return ConvRelu;\n}(SequenceOptimization));\nexport { ConvRelu };\n//# sourceMappingURL=convRelu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ConvNode } from \"../nodes/conv\";\nimport { SequenceOptimization } from \"./optimization\";\nvar ConvRelu6 = /** @class */ (function (_super) {\n    __extends(ConvRelu6, _super);\n    function ConvRelu6() {\n        return _super.call(this, ['Conv', 'Clip']) || this;\n    }\n    ConvRelu6.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var clip = nodes[1];\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), conv.inputs, clip.outputs, constants, onnxVersion, conv.kernel, conv.bias, \"relu6\");\n    };\n    ConvRelu6.prototype.canApply = function (nodes) {\n        var clip = nodes[1];\n        return clip.min === 0 && clip.max === 6;\n    };\n    return ConvRelu6;\n}(SequenceOptimization));\nexport { ConvRelu6 };\n//# sourceMappingURL=convRelu6.js.map","import { ConvBatchNorm } from \"./convBatchnorm\";\nimport { ConvRelu } from \"./convRelu\";\nimport { ConvRelu6 } from \"./convRelu6\";\nexport var defaultOptimizations = [\n    new ConvBatchNorm(),\n    new ConvRelu(),\n    new ConvRelu6()\n];\n//# sourceMappingURL=default.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../../node\";\nvar BinaryNode = /** @class */ (function (_super) {\n    __extends(BinaryNode, _super);\n    function BinaryNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    BinaryNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [this.compute(a, b)]];\n                }\n                throw new Error(this.name + \" not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    BinaryNode.prototype.getType = function () {\n        return this.name;\n    };\n    BinaryNode.prototype.delete = function () { };\n    return BinaryNode;\n}(OnnxNode));\nexport { BinaryNode };\n//# sourceMappingURL=binaryNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from \"./binaryNode\";\nvar AddNode = /** @class */ (function (_super) {\n    __extends(AddNode, _super);\n    function AddNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Add';\n        return _this;\n    }\n    AddNode.prototype.compute = function (a, b) {\n        return a.add(b);\n    };\n    return AddNode;\n}(BinaryNode));\nexport { AddNode };\n//# sourceMappingURL=add.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { toCPU, toGPU, toWASM } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nvar BatchNormalizationNode = /** @class */ (function (_super) {\n    __extends(BatchNormalizationNode, _super);\n    function BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-05;\n        _this.momentum = _this.getAttributeFloat('momentum') || 0.9;\n        _this.epsTensor = new CPUTensor([1], [_this.epsilon]);\n        return _this;\n        //TODO: Handle lower onnxversions here\n    }\n    BatchNormalizationNode.prototype.initialize = function (resolveConstant) {\n        var scale = resolveConstant(this.inputs[1]);\n        var B = resolveConstant(this.inputs[2]);\n        var mean = resolveConstant(this.inputs[3]);\n        var variance = resolveConstant(this.inputs[4]);\n        if (scale !== undefined && B !== undefined && mean !== undefined && variance !== undefined) {\n            var varSqrt = variance.add(this.epsTensor).sqrt();\n            //this.scale = scale.divide(varSqrt);\n            //this.bias = B.subtract(mean.multiply(this.scale));\n            varSqrt.delete();\n        }\n    };\n    BatchNormalizationNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, B, mean, variance, C, newShape, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                scale = inputs[1];\n                B = inputs[2];\n                mean = inputs[3];\n                variance = inputs[4];\n                C = scale.getShape()[0];\n                newShape = __spreadArrays([1, C], new Array(x.getShape().length - 2).fill(1));\n                scale = scale.reshape(newShape, false);\n                B = B.reshape(newShape, false);\n                mean = mean.reshape(newShape, false);\n                variance = variance.reshape(newShape, false);\n                result = x.normalize(mean, variance, this.epsilon, scale, B);\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.getType = function () {\n        return 'BatchNormalization';\n    };\n    BatchNormalizationNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.epsTensor)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.epsTensor)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.epsTensor, precision)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.delete = function () {\n        this.epsTensor.delete();\n    };\n    return BatchNormalizationNode;\n}(OnnxNode));\nexport { BatchNormalizationNode };\n//# sourceMappingURL=batchNormalization.js.map","import { CPUTensor } from \"../../tensor/cpu/tensor\";\nexport function cast(a, to) {\n    if (a.type === to) {\n        return a;\n    }\n    else if (to === \"float\") {\n        var arr = new Float32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n    else {\n        var arr = new Int32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n}\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { cast } from \"../../ops/cpu/cast\";\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar CastNode = /** @class */ (function (_super) {\n    __extends(CastNode, _super);\n    function CastNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.to = _this.getAttributeString(\"to\");\n        return _this;\n    }\n    CastNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (x instanceof CPUTensor) {\n                    return [2 /*return*/, [cast(x, this.to)]];\n                }\n                throw new Error(\"Can only cast CPU tensors right now\");\n            });\n        });\n    };\n    CastNode.prototype.getType = function () {\n        return 'Cast';\n    };\n    CastNode.prototype.delete = function () { };\n    return CastNode;\n}(OnnxNode));\nexport { CastNode };\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../../node\";\nvar UnaryNode = /** @class */ (function (_super) {\n    __extends(UnaryNode, _super);\n    function UnaryNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    UnaryNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                return [2 /*return*/, [this.compute(x)]];\n            });\n        });\n    };\n    UnaryNode.prototype.getType = function () {\n        return this.name;\n    };\n    UnaryNode.prototype.delete = function () { };\n    return UnaryNode;\n}(OnnxNode));\nexport { UnaryNode };\n//# sourceMappingURL=unaryNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from \"./unaryNode\";\nvar CeilNode = /** @class */ (function (_super) {\n    __extends(CeilNode, _super);\n    function CeilNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Ceil';\n        return _this;\n    }\n    CeilNode.prototype.compute = function (x) {\n        return x.ceil();\n    };\n    return CeilNode;\n}(UnaryNode));\nexport { CeilNode };\n//# sourceMappingURL=ceil.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ClipNode = /** @class */ (function (_super) {\n    __extends(ClipNode, _super);\n    function ClipNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            _this.min = _this.getAttributeFloat('min');\n            _this.max = _this.getAttributeFloat('max');\n        }\n        return _this;\n    }\n    ClipNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, min, max;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [x.clip(this.min, this.max)]];\n                }\n                else {\n                    min = inputs.length > 1 ? inputs[1] : undefined;\n                    max = inputs.length > 2 ? inputs[2] : undefined;\n                    if (min === undefined && max === undefined) {\n                        return [2 /*return*/, [x.copy()]];\n                    }\n                    throw new Error('Clip with onnx version >= 11 not yet implemented');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    ClipNode.prototype.getType = function () {\n        return 'Clip';\n    };\n    ClipNode.prototype.delete = function () { };\n    return ClipNode;\n}(OnnxNode));\nexport { ClipNode };\n//# sourceMappingURL=clip.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ConcatNode = /** @class */ (function (_super) {\n    __extends(ConcatNode, _super);\n    function ConcatNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.axis = _this.getAttributeInt(\"axis\");\n        }\n        return _this;\n    }\n    ConcatNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, i, newRes;\n            return __generator(this, function (_a) {\n                if (inputs.length > 2) {\n                    // This logging seems to slow down the operation more than the operation itself\n                    //console.warn(`Concat with more than 2 tensors is currently slow. Doing concat with ${inputs.length} tensors`);\n                }\n                result = inputs[0];\n                for (i = 1; i < inputs.length; i++) {\n                    newRes = result.concat(inputs[i], this.axis);\n                    if (i > 1) {\n                        result.delete();\n                    }\n                    result = newRes;\n                }\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    ConcatNode.prototype.getType = function () {\n        return 'Concat';\n    };\n    ConcatNode.prototype.delete = function () { };\n    return ConcatNode;\n}(OnnxNode));\nexport { ConcatNode };\n//# sourceMappingURL=concat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { getSize } from \"../../util/shape\";\nimport { OnnxNode } from \"../node\";\nimport { createTensor } from \"../util\";\nvar ConstantOfShapeNode = /** @class */ (function (_super) {\n    __extends(ConstantOfShapeNode, _super);\n    function ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor(\"value\");\n            _this.tensor = createTensor(tensor);\n        }\n        return _this;\n    }\n    ConstantOfShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _shape, shape, i, size, values;\n            return __generator(this, function (_a) {\n                _shape = inputs[0];\n                if (!(_shape instanceof CPUTensor)) {\n                    throw new Error(\"ConstantOfShape needs cpu tensor as shape tensor\");\n                }\n                shape = new Array(_shape.size);\n                for (i = 0; i < _shape.size; i++) {\n                    shape[i] = _shape.get(i);\n                }\n                size = getSize(shape);\n                values = new Float32Array(size).fill(this.tensor.get(0));\n                return [2 /*return*/, [new CPUTensor(shape, values, this.tensor.type)]];\n            });\n        });\n    };\n    ConstantOfShapeNode.prototype.getType = function () {\n        return 'ConstantOfShape';\n    };\n    ConstantOfShapeNode.prototype.delete = function () {\n        this.tensor.delete();\n    };\n    return ConstantOfShapeNode;\n}(OnnxNode));\nexport { ConstantOfShapeNode };\n//# sourceMappingURL=constantOfShape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from \"./binaryNode\";\nvar DivNode = /** @class */ (function (_super) {\n    __extends(DivNode, _super);\n    function DivNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Div';\n        return _this;\n    }\n    DivNode.prototype.compute = function (a, b) {\n        return a.divide(b);\n    };\n    return DivNode;\n}(BinaryNode));\nexport { DivNode };\n//# sourceMappingURL=div.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from \"./unaryNode\";\nvar ExpNode = /** @class */ (function (_super) {\n    __extends(ExpNode, _super);\n    function ExpNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Exp';\n        return _this;\n    }\n    ExpNode.prototype.compute = function (x) {\n        return x.exp();\n    };\n    return ExpNode;\n}(UnaryNode));\nexport { ExpNode };\n//# sourceMappingURL=exp.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ExpandNode = /** @class */ (function (_super) {\n    __extends(ExpandNode, _super);\n    function ExpandNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ExpandNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tensor, _shape, shape, i;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    tensor = inputs[0];\n                    _shape = inputs[1];\n                    if (!(_shape instanceof CPUTensor)) {\n                        throw new Error(\"Expand needs cpu tensor as shape tensor\");\n                    }\n                    shape = new Array(_shape.size);\n                    for (i = 0; i < _shape.size; i++) {\n                        shape[i] = _shape.get(i);\n                    }\n                    return [2 /*return*/, [tensor.expand(shape)]];\n                }\n                throw new Error(\"Expand not yet implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ExpandNode.prototype.getType = function () {\n        return 'Expand';\n    };\n    ExpandNode.prototype.delete = function () { };\n    return ExpandNode;\n}(OnnxNode));\nexport { ExpandNode };\n//# sourceMappingURL=expand.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from \"./unaryNode\";\nvar FloorNode = /** @class */ (function (_super) {\n    __extends(FloorNode, _super);\n    function FloorNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Floor';\n        return _this;\n    }\n    FloorNode.prototype.compute = function (x) {\n        return x.floor();\n    };\n    return FloorNode;\n}(UnaryNode));\nexport { FloorNode };\n//# sourceMappingURL=floor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar GatherNode = /** @class */ (function (_super) {\n    __extends(GatherNode, _super);\n    function GatherNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axis = _this.getAttributeInt(\"axis\") || 0;\n        return _this;\n    }\n    GatherNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, indices;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                indices = inputs[1];\n                if (!(indices instanceof CPUTensor)) {\n                    throw new Error(\"Gather requires CPU tensor for the indices\");\n                }\n                return [2 /*return*/, [x.gather(this.axis, indices)]];\n            });\n        });\n    };\n    GatherNode.prototype.getType = function () {\n        return 'Gather';\n    };\n    GatherNode.prototype.delete = function () { };\n    return GatherNode;\n}(OnnxNode));\nexport { GatherNode };\n//# sourceMappingURL=gather.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar GemmNode = /** @class */ (function (_super) {\n    __extends(GemmNode, _super);\n    function GemmNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.alpha = _this.getAttributeFloat(\"alpha\") || 1.0;\n        _this.beta = _this.getAttributeFloat(\"beta\") || 1.0;\n        var transA = _this.getAttributeInt(\"transA\");\n        var transB = _this.getAttributeInt(\"transB\");\n        _this.transA = transA === 1;\n        _this.transB = transB === 1;\n        return _this;\n    }\n    GemmNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b, c;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion >= 9 && this.onnxVersion < 11) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    c = inputs[2];\n                    return [2 /*return*/, [a.gemm(b, this.transA, this.transB, this.alpha, c, this.beta)]];\n                }\n                throw new Error(\"Gemm is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    GemmNode.prototype.getType = function () {\n        return 'Gemm';\n    };\n    GemmNode.prototype.delete = function () { };\n    return GemmNode;\n}(OnnxNode));\nexport { GemmNode };\n//# sourceMappingURL=gemm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { glContext } from \"../../tensor/gpu/gl\";\nimport { OnnxNode } from \"../node\";\nvar InstanceNormalizationNode = /** @class */ (function (_super) {\n    __extends(InstanceNormalizationNode, _super);\n    function InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-05;\n        return _this;\n        //TODO: Handle onnx versions < 6 here\n    }\n    InstanceNormalizationNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, B, dataRank, C, newShape, reduceAxes, i, mean, diff, variance, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                scale = inputs[1];\n                B = inputs[2];\n                dataRank = x.getShape().length - 2;\n                C = scale.getShape()[0];\n                newShape = __spreadArrays([1, C], new Array(dataRank).fill(1));\n                scale = scale.reshape(newShape, false);\n                B = B.reshape(newShape, false);\n                reduceAxes = new Array(x.getShape().length - 2);\n                for (i = 0; i < dataRank; i++) {\n                    reduceAxes[i] = i + 2;\n                }\n                mean = x.reduceMean(reduceAxes, true);\n                glContext.flush();\n                diff = x.subtract(mean);\n                glContext.flush();\n                variance = diff.reduceMeanSquare(reduceAxes, true);\n                glContext.flush();\n                result = x.normalize(mean, variance, this.epsilon, scale, B);\n                mean.delete();\n                diff.delete();\n                variance.delete();\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    InstanceNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    InstanceNormalizationNode.prototype.getType = function () {\n        return 'InstanceNormalization';\n    };\n    InstanceNormalizationNode.prototype.delete = function () { };\n    return InstanceNormalizationNode;\n}(OnnxNode));\nexport { InstanceNormalizationNode };\n//# sourceMappingURL=instanceNormalization.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar MatMulNode = /** @class */ (function (_super) {\n    __extends(MatMulNode, _super);\n    function MatMulNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    MatMulNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var A, B;\n            return __generator(this, function (_a) {\n                A = inputs[0];\n                B = inputs[1];\n                if (this.onnxVersion < 13 && this.onnxVersion >= 9) {\n                    if (A.getShape().length !== B.getShape().length) {\n                        throw new Error(\"Automatic broadcasting in MatMul not supported yet\");\n                    }\n                    return [2 /*return*/, [A.gemm(B)]];\n                }\n                throw new Error(\"Matmul with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    MatMulNode.prototype.getType = function () {\n        return 'MatMul';\n    };\n    MatMulNode.prototype.delete = function () { };\n    return MatMulNode;\n}(OnnxNode));\nexport { MatMulNode };\n//# sourceMappingURL=matMul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from \"./binaryNode\";\nvar MulNode = /** @class */ (function (_super) {\n    __extends(MulNode, _super);\n    function MulNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Mul';\n        return _this;\n    }\n    MulNode.prototype.compute = function (a, b) {\n        return a.multiply(b);\n    };\n    return MulNode;\n}(BinaryNode));\nexport { MulNode };\n//# sourceMappingURL=mul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar PadNode = /** @class */ (function (_super) {\n    __extends(PadNode, _super);\n    function PadNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.mode = (_this.getAttributeString('mode') || 'constant');\n        _this.pads = _this.getAttributeInts('pads');\n        _this.value = _this.getAttributeFloat(\"value\") || 0;\n        return _this;\n    }\n    PadNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].pad(this.pads, this.mode, this.value)]];\n                }\n                throw new Error(\"Pad not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    PadNode.prototype.getType = function () {\n        return 'Pad';\n    };\n    PadNode.prototype.delete = function () { };\n    return PadNode;\n}(OnnxNode));\nexport { PadNode };\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../../node\";\nvar ReduceNode = /** @class */ (function (_super) {\n    __extends(ReduceNode, _super);\n    function ReduceNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        var keep = _this.getAttributeInt(\"keepdims\");\n        _this.keepDims = keep === 1 || keep === undefined;\n        return _this;\n    }\n    ReduceNode.prototype.getAxes = function (input) {\n        if (this.axes !== undefined) {\n            return this.axes;\n        }\n        else {\n            var rank = input.getShape().length;\n            var res = new Array(rank);\n            for (var i = 0; i < rank; i++) {\n                res[i] = i;\n            }\n            return res;\n        }\n    };\n    ReduceNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [this.calc(inputs[0])]];\n                }\n                throw new Error(this.name + \" is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ReduceNode.prototype.getType = function () {\n        return this.name;\n    };\n    ReduceNode.prototype.delete = function () { };\n    return ReduceNode;\n}(OnnxNode));\nexport { ReduceNode };\n//# sourceMappingURL=reduceNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from \"./reduceNode\";\nvar ReduceMaxNode = /** @class */ (function (_super) {\n    __extends(ReduceMaxNode, _super);\n    function ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'ReduceMax';\n        return _this;\n    }\n    ReduceMaxNode.prototype.calc = function (input) {\n        return input.max(this.axes, this.keepDims);\n    };\n    return ReduceMaxNode;\n}(ReduceNode));\nexport { ReduceMaxNode };\n//# sourceMappingURL=reduceMax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from \"./reduceNode\";\nvar ReduceMeanNode = /** @class */ (function (_super) {\n    __extends(ReduceMeanNode, _super);\n    function ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'ReduceMean';\n        return _this;\n    }\n    ReduceMeanNode.prototype.calc = function (input) {\n        return input.reduceMean(this.axes, this.keepDims);\n    };\n    return ReduceMeanNode;\n}(ReduceNode));\nexport { ReduceMeanNode };\n//# sourceMappingURL=reduceMean.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from \"./reduceNode\";\nvar ReduceSumNode = /** @class */ (function (_super) {\n    __extends(ReduceSumNode, _super);\n    function ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'ReduceSum';\n        return _this;\n    }\n    ReduceSumNode.prototype.calc = function (input) {\n        return input.sum(this.axes, this.keepDims);\n    };\n    return ReduceSumNode;\n}(ReduceNode));\nexport { ReduceSumNode };\n//# sourceMappingURL=reduceSum.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from \"./reduceNode\";\nvar ReduceSumSquareNode = /** @class */ (function (_super) {\n    __extends(ReduceSumSquareNode, _super);\n    function ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'ReduceSumSquare';\n        return _this;\n    }\n    ReduceSumSquareNode.prototype.calc = function (input) {\n        return input.sumSquare(this.axes, this.keepDims);\n    };\n    return ReduceSumSquareNode;\n}(ReduceNode));\nexport { ReduceSumSquareNode };\n//# sourceMappingURL=reduceSumSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ClipNode } from \"./clip\";\nvar ReluNode = /** @class */ (function (_super) {\n    __extends(ReluNode, _super);\n    function ReluNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.max = undefined;\n        _this.min = 0;\n        return _this;\n    }\n    ReluNode.prototype.getType = function () {\n        return 'Relu';\n    };\n    return ReluNode;\n}(ClipNode));\nexport { ReluNode };\n//# sourceMappingURL=relu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ReshapeNode = /** @class */ (function (_super) {\n    __extends(ReshapeNode, _super);\n    function ReshapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.shape = _this.getAttributeInts(\"shape\");\n        }\n        return _this;\n    }\n    ReshapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shape, _shape, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shape = inputs[1];\n                if (!(shape instanceof CPUTensor)) {\n                    throw new Error('Reshape only works with CPU tensor as shape tensor');\n                }\n                if (this.onnxVersion < 13) {\n                    _shape = new Array(shape.size);\n                    for (i = 0; i < shape.size; i++) {\n                        _shape[i] = shape.get(i);\n                    }\n                    return [2 /*return*/, [x.reshape(_shape)]];\n                }\n                throw new Error(\"Reshape with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    ReshapeNode.prototype.getType = function () {\n        return 'Reshape';\n    };\n    ReshapeNode.prototype.delete = function () { };\n    return ReshapeNode;\n}(OnnxNode));\nexport { ReshapeNode };\n//# sourceMappingURL=reshape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ShapeNode = /** @class */ (function (_super) {\n    __extends(ShapeNode, _super);\n    function ShapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, shape;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    a = inputs[0];\n                    shape = a.getShape();\n                    return [2 /*return*/, [new CPUTensor([shape.length], __spreadArrays(shape), \"int\")]];\n                }\n                throw new Error(\"Shape not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ShapeNode.prototype.getType = function () {\n        return 'Shape';\n    };\n    ShapeNode.prototype.delete = function () { };\n    return ShapeNode;\n}(OnnxNode));\nexport { ShapeNode };\n//# sourceMappingURL=shape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar SliceNode = /** @class */ (function (_super) {\n    __extends(SliceNode, _super);\n    function SliceNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        _this.starts = _this.getAttributeInts(\"starts\");\n        _this.ends = _this.getAttributeInts(\"ends\");\n        return _this;\n    }\n    SliceNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    x = inputs[0];\n                    return [2 /*return*/, [x.slice(this.starts, this.ends, this.axes)]];\n                }\n                throw new Error(\"Slice not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    SliceNode.prototype.getType = function () {\n        return 'Slice';\n    };\n    SliceNode.prototype.delete = function () { };\n    return SliceNode;\n}(OnnxNode));\nexport { SliceNode };\n//# sourceMappingURL=slice.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar SoftmaxNode = /** @class */ (function (_super) {\n    __extends(SoftmaxNode, _super);\n    function SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axis = _this.getAttributeInt(\"axis\");\n        return _this;\n    }\n    SoftmaxNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shapeX, ax, sh1, reshaped, max, normalized, exp, sum, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shapeX = x.getShape();\n                ax = this.axis;\n                if (ax === undefined) {\n                    if (this.onnxVersion < 13) {\n                        ax = 1;\n                    }\n                    else {\n                        ax = shapeX.length - 1;\n                    }\n                }\n                sh1 = shapeX.slice(0, ax).reduce(function (x, y) { return x * y; }, 1);\n                reshaped = x.reshape([sh1, -1], false);\n                max = reshaped.max(1, true);\n                normalized = reshaped.subtract(max);\n                exp = normalized.exp();\n                sum = exp.sum(1, true);\n                result = exp.divide(sum);\n                max.delete();\n                normalized.delete();\n                exp.delete();\n                sum.delete();\n                return [2 /*return*/, [result.reshape(shapeX, false)]];\n            });\n        });\n    };\n    SoftmaxNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    SoftmaxNode.prototype.getType = function () {\n        return 'Softmax';\n    };\n    SoftmaxNode.prototype.delete = function () { };\n    return SoftmaxNode;\n}(OnnxNode));\nexport { SoftmaxNode };\n//# sourceMappingURL=softmax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from \"./binaryNode\";\nvar SubNode = /** @class */ (function (_super) {\n    __extends(SubNode, _super);\n    function SubNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.name = 'Sub';\n        return _this;\n    }\n    SubNode.prototype.compute = function (a, b) {\n        return a.subtract(b);\n    };\n    return SubNode;\n}(BinaryNode));\nexport { SubNode };\n//# sourceMappingURL=sub.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar TileNode = /** @class */ (function (_super) {\n    __extends(TileNode, _super);\n    function TileNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    TileNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, repeats, _repeats, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                repeats = inputs[1];\n                if (!(repeats instanceof CPUTensor)) {\n                    throw new Error('Tile only works with CPU tensor as repeats');\n                }\n                if (this.onnxVersion < 13 && this.onnxVersion >= 6) {\n                    _repeats = new Array(repeats.size);\n                    for (i = 0; i < repeats.size; i++) {\n                        _repeats[i] = repeats.get(i);\n                    }\n                    return [2 /*return*/, [x.repeat(_repeats)]];\n                }\n                throw new Error(\"Tile with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    TileNode.prototype.getType = function () {\n        return 'Tile';\n    };\n    TileNode.prototype.delete = function () { };\n    return TileNode;\n}(OnnxNode));\nexport { TileNode };\n//# sourceMappingURL=tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar TransposeNode = /** @class */ (function (_super) {\n    __extends(TransposeNode, _super);\n    function TransposeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.permutation = _this.getAttributeInts(\"perm\");\n        return _this;\n    }\n    TransposeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.transpose(this.permutation)]];\n            });\n        });\n    };\n    TransposeNode.prototype.getType = function () {\n        return 'Transpose';\n    };\n    TransposeNode.prototype.delete = function () { };\n    return TransposeNode;\n}(OnnxNode));\nexport { TransposeNode };\n//# sourceMappingURL=transpose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar UnsqueezeNode = /** @class */ (function (_super) {\n    __extends(UnsqueezeNode, _super);\n    function UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.axes = _this.getAttributeInts(\"axes\");\n        }\n        return _this;\n    }\n    UnsqueezeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, currShape, newShape, axIx, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 13) {\n                    currShape = x.getShape();\n                    newShape = [];\n                    axIx = 0;\n                    for (i = 0; i < currShape.length; i++) {\n                        if (axIx < this.axes.length && this.axes[axIx] === i) {\n                            newShape.push(1);\n                            axIx++;\n                        }\n                        newShape.push(currShape[i]);\n                    }\n                    if (this.axes[this.axes.length - 1] === currShape.length) {\n                        newShape.push(1);\n                    }\n                    return [2 /*return*/, [x.reshape(newShape)]];\n                }\n                throw new Error(\"Unsqueeze with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    UnsqueezeNode.prototype.getType = function () {\n        return 'Unsqueeze';\n    };\n    UnsqueezeNode.prototype.delete = function () { };\n    return UnsqueezeNode;\n}(OnnxNode));\nexport { UnsqueezeNode };\n//# sourceMappingURL=unsqueeze.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { toCPU } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nvar UpsampleNode = /** @class */ (function (_super) {\n    __extends(UpsampleNode, _super);\n    function UpsampleNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.mode = _this.getAttributeString(\"mode\");\n        if (_this.mode !== \"nearest\") {\n            throw new Error(\"Upsampling only supported with nearest neighbor sampling\");\n        }\n        return _this;\n    }\n    UpsampleNode.prototype.getScales = function (scale) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sc, scales, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!(scale instanceof CPUTensor)) return [3 /*break*/, 2];\n                        console.warn(\"Scales tensor for upsample not on CPU, need to transfer!\");\n                        return [4 /*yield*/, toCPU(scale)];\n                    case 1:\n                        scale = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        sc = scale;\n                        scales = new Array(sc.size);\n                        for (i = 0; i < sc.size; i++) {\n                            scales[i] = sc.get(i);\n                        }\n                        return [2 /*return*/, scales];\n                }\n            });\n        });\n    };\n    UpsampleNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, scales;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        x = inputs[0];\n                        scale = inputs[1];\n                        return [4 /*yield*/, this.getScales(scale)];\n                    case 1:\n                        scales = _a.sent();\n                        return [2 /*return*/, [x.upsample(scales)]];\n                }\n            });\n        });\n    };\n    UpsampleNode.prototype.getType = function () {\n        return 'Upsample';\n    };\n    UpsampleNode.prototype.delete = function () { };\n    return UpsampleNode;\n}(OnnxNode));\nexport { UpsampleNode };\n//# sourceMappingURL=upsample.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar GlobalAveragePoolNode = /** @class */ (function (_super) {\n    __extends(GlobalAveragePoolNode, _super);\n    function GlobalAveragePoolNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    GlobalAveragePoolNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, axes, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                axes = new Array(x.getShape().length - 2);\n                for (i = 0; i < x.getShape().length - 2; i++) {\n                    axes[i] = i + 2;\n                }\n                return [2 /*return*/, [x.reduceMean(axes, true)]];\n            });\n        });\n    };\n    GlobalAveragePoolNode.prototype.getType = function () {\n        return 'GlobalAveragePool';\n    };\n    GlobalAveragePoolNode.prototype.delete = function () { };\n    return GlobalAveragePoolNode;\n}(OnnxNode));\nexport { GlobalAveragePoolNode };\n//# sourceMappingURL=globalAveragePool.js.map","import { AddNode } from \"./nodes/binary/add\";\nimport { BatchNormalizationNode } from \"./nodes/batchNormalization\";\nimport { CastNode } from \"./nodes/cast\";\nimport { CeilNode } from \"./nodes/unary/ceil\";\nimport { ClipNode } from \"./nodes/clip\";\nimport { ConcatNode } from \"./nodes/concat\";\nimport { ConstantNode } from \"./nodes/constant\";\nimport { ConstantOfShapeNode } from \"./nodes/constantOfShape\";\nimport { ConvNode } from \"./nodes/conv\";\nimport { DivNode } from \"./nodes/binary/div\";\nimport { ExpNode } from \"./nodes/unary/exp\";\nimport { ExpandNode } from \"./nodes/expand\";\nimport { FloorNode } from \"./nodes/unary/floor\";\nimport { GatherNode } from \"./nodes/gather\";\nimport { GemmNode } from \"./nodes/gemm\";\nimport { InstanceNormalizationNode } from \"./nodes/instanceNormalization\";\nimport { MatMulNode } from \"./nodes/matMul\";\nimport { MulNode } from \"./nodes/binary/mul\";\nimport { PadNode } from \"./nodes/pad\";\nimport { ReduceMaxNode } from \"./nodes/reduce/reduceMax\";\nimport { ReduceMeanNode } from \"./nodes/reduce/reduceMean\";\nimport { ReduceSumNode } from \"./nodes/reduce/reduceSum\";\nimport { ReduceSumSquareNode } from \"./nodes/reduce/reduceSumSquare\";\nimport { ReluNode } from \"./nodes/relu\";\nimport { ReshapeNode } from \"./nodes/reshape\";\nimport { ShapeNode } from \"./nodes/shape\";\nimport { SliceNode } from \"./nodes/slice\";\nimport { SoftmaxNode } from \"./nodes/softmax\";\nimport { SubNode } from \"./nodes/binary/sub\";\nimport { TileNode } from \"./nodes/tile\";\nimport { TransposeNode } from \"./nodes/transpose\";\nimport { UnsqueezeNode } from \"./nodes/unsqueeze\";\nimport { UpsampleNode } from \"./nodes/upsample\";\nimport { GlobalAveragePoolNode } from \"./nodes/globalAveragePool\";\nexport var nodeResolve = {\n    'Conv': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConvNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'BatchNormalization': function (attributes, inputs, outputs, constants, onnxVersion) { return new BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Clip': function (attributes, inputs, outputs, constants, onnxVersion) { return new ClipNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Add': function (attributes, inputs, outputs, constants, onnxVersion) { return new AddNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceMean': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Gemm': function (attributes, inputs, outputs, constants, onnxVersion) { return new GemmNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Constant': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConstantNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Reshape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReshapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Tile': function (attributes, inputs, outputs, constants, onnxVersion) { return new TileNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'MatMul': function (attributes, inputs, outputs, constants, onnxVersion) { return new MatMulNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Exp': function (attributes, inputs, outputs, constants, onnxVersion) { return new ExpNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceSum': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceMax': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceSumSquare': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Sub': function (attributes, inputs, outputs, constants, onnxVersion) { return new SubNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Mul': function (attributes, inputs, outputs, constants, onnxVersion) { return new MulNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Div': function (attributes, inputs, outputs, constants, onnxVersion) { return new DivNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Unsqueeze': function (attributes, inputs, outputs, constants, onnxVersion) { return new UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Concat': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConcatNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ConstantOfShape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Expand': function (attributes, inputs, outputs, constants, onnxVersion) { return new ExpandNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'InstanceNormalization': function (attributes, inputs, outputs, constants, onnxVersion) { return new InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Pad': function (attributes, inputs, outputs, constants, onnxVersion) { return new PadNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Relu': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReluNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Shape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ShapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Gather': function (attributes, inputs, outputs, constants, onnxVersion) { return new GatherNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Cast': function (attributes, inputs, outputs, constants, onnxVersion) { return new CastNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Floor': function (attributes, inputs, outputs, constants, onnxVersion) { return new FloorNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Ceil': function (attributes, inputs, outputs, constants, onnxVersion) { return new CeilNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Slice': function (attributes, inputs, outputs, constants, onnxVersion) { return new SliceNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Upsample': function (attributes, inputs, outputs, constants, onnxVersion) { return new UpsampleNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Transpose': function (attributes, inputs, outputs, constants, onnxVersion) { return new TransposeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Softmax': function (attributes, inputs, outputs, constants, onnxVersion) { return new SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'GlobalAveragePool': function (attributes, inputs, outputs, constants, onnxVersion) { return new GlobalAveragePoolNode(attributes, inputs, outputs, constants, onnxVersion); },\n};\n//# sourceMappingURL=resolve.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport Long from 'long';\nimport { onnx } from 'onnx-proto';\nimport { glContext } from '../tensor/gpu/gl';\nimport { toCPU, toGPU, toWASM } from '../util/convert';\nimport { ConstantNode } from './nodes/constant';\nimport { defaultOptimizations } from './optimizations/default';\nimport { nodeResolve } from './resolve';\nimport { createTensor } from './util';\nvar OnnxModel = /** @class */ (function () {\n    /**\n     * Builds a new onnx model\n     *\n     * @param buffer Onnx model\n     * @param args Optional arguments for the model\n     */\n    function OnnxModel(buffer, args) {\n        this.inputSet = new Set();\n        this.nodes = {};\n        this.nodeIds = [];\n        this.defaultReady = [];\n        this.intermediaries = {};\n        this.constants = {};\n        this.nodeIdCounter = 10000;\n        if (args === undefined) {\n            args = {};\n        }\n        this.noConvertConstants = new Set(args.noConvertConstants !== undefined ? args.noConvertConstants : []);\n        this.noConvertNodes = new Set(args.noConvertNodes !== undefined ? args.noConvertNodes : []);\n        this.precision = args.precision || 32;\n        var arr;\n        if (buffer instanceof ArrayBuffer) {\n            arr = new Uint8Array(buffer);\n        }\n        else {\n            arr = buffer;\n        }\n        this.modelProto = onnx.ModelProto.decode(arr);\n        var ver = this.modelProto.opsetImport[0].version;\n        if (Long.isLong(ver)) {\n            ver = ver.toNumber();\n        }\n        this.version = ver;\n        this.inputs = this.modelProto.graph.input;\n        for (var i = 0; i < this.inputs.length; i++) {\n            this.inputSet.add(this.inputs[i].name);\n        }\n        this.outputs = this.modelProto.graph.output.map(function (x) { return x.name; });\n        this.initializer(this.modelProto.graph.initializer);\n        this.initNodes(this.modelProto);\n    }\n    OnnxModel.prototype.initNodes = function (modelProto) {\n        var _this = this;\n        for (var i = 0; i < modelProto.graph.node.length; i++) {\n            var nodeData = modelProto.graph.node[i];\n            var cls = nodeResolve[nodeData.opType];\n            if (cls === undefined) {\n                throw new Error(\"Node operator \" + nodeData.opType + \" can not be resolved\");\n            }\n            var attributes = nodeData.attribute || [];\n            var inputs = nodeData.input || [];\n            var outputs = nodeData.output || [];\n            var node = cls(attributes, inputs, outputs, this.constants, this.version);\n            this.nodes[i] = node;\n            this.nodeIds.push(i);\n            for (var j = 0; j < inputs.length; j++) {\n                var input = inputs[j];\n                if (this.intermediaries[input] === undefined) {\n                    this.intermediaries[input] = {\n                        to: [],\n                        deletable: true\n                    };\n                }\n                this.intermediaries[input].to.push(i);\n            }\n            if (node.variableInputs === 0) {\n                this.defaultReady.push(i);\n            }\n            if (nodeData.opType === 'Constant') {\n                if (this.intermediaries[nodeData.output[0]] === undefined) {\n                    this.intermediaries[nodeData.output[0]] = {\n                        to: [],\n                        deletable: false\n                    };\n                }\n                else {\n                    this.intermediaries[nodeData.output[0]].deletable = false;\n                }\n            }\n        }\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            this.nodes[nodeId].initialize(function (name) { return _this.resolveConstant(name); });\n        }\n    };\n    OnnxModel.prototype.initializer = function (initializer) {\n        for (var i = 0; i < initializer.length; i++) {\n            var tensorProto = initializer[i];\n            var tensor = createTensor(tensorProto);\n            this.constants[tensorProto.name] = tensor;\n        }\n    };\n    /**\n     * Do a forward pass for the specified inputs\n     *\n     * @param wait Number of milliseconds to wait between each layer. This\n     *             is especially useful, if your model is complex and\n     *             you dont want your model to block your whole application.\n     */\n    OnnxModel.prototype.forward = function (inputs, wait) {\n        return __awaiter(this, void 0, void 0, function () {\n            var intermediaryRes, nodes, _i, _a, i, nodesReady, nodeId, node, _b, inputs_1, toDelete, outputs_1, e_1, i, inter, outputs, i;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        intermediaryRes = {};\n                        nodes = {};\n                        for (_i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n                            i = _a[_i];\n                            nodes[i] = {\n                                variableInputs: 0\n                            };\n                        }\n                        nodesReady = __spreadArrays(this.defaultReady);\n                        this.initializeForward(inputs, intermediaryRes, nodes, nodesReady);\n                        _c.label = 1;\n                    case 1:\n                        if (!(nodesReady.length > 0)) return [3 /*break*/, 8];\n                        nodeId = nodesReady.shift();\n                        node = this.nodes[nodeId];\n                        _b = this.getInputsToNode(node, intermediaryRes), inputs_1 = _b.inputs, toDelete = _b.toDelete;\n                        outputs_1 = void 0;\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, node.forward(inputs_1)];\n                    case 3:\n                        outputs_1 = _c.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _c.sent();\n                        console.error(\"Error occurred in node \" + nodeId + \" with inputs \" + node.inputs + \" from nodes \" + node.inputs.map(function (x) { return _this.getNodeWithOutput(x); }));\n                        throw e_1;\n                    case 5:\n                        glContext.flush();\n                        this.propagateResults(node, intermediaryRes, outputs_1, nodes, nodesReady);\n                        for (i = 0; i < toDelete.length; i++) {\n                            if (!this.inputSet.has(toDelete[i])) {\n                                inter = intermediaryRes[toDelete[i]];\n                                inter.value.delete();\n                                delete intermediaryRes[toDelete[i]];\n                            }\n                        }\n                        if (!(wait !== undefined)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, new Promise(function (resolve, _) {\n                                setTimeout(resolve, wait);\n                            })];\n                    case 6:\n                        _c.sent();\n                        _c.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8:\n                        outputs = [];\n                        for (i = 0; i < this.outputs.length; i++) {\n                            outputs.push(intermediaryRes[this.outputs[i]].value);\n                        }\n                        return [2 /*return*/, outputs];\n                }\n            });\n        });\n    };\n    OnnxModel.prototype.initializeForward = function (inputs, intermediaryRes, nodes, nodesReady) {\n        for (var i = 0; i < inputs.length; i++) {\n            intermediaryRes[this.inputs[i].name] = {\n                value: inputs[i],\n                used: 0\n            };\n            var inter = this.intermediaries[this.inputs[i].name];\n            for (var j = 0; j < inter.to.length; j++) {\n                var id = inter.to[j];\n                nodes[id].variableInputs++;\n                if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                    nodesReady.push(id);\n                    delete nodes[id];\n                }\n            }\n        }\n    };\n    OnnxModel.prototype.getInputsToNode = function (node, intermediaryRes) {\n        var inputs = [];\n        var toDelete = [];\n        for (var i = 0; i < node.inputs.length; i++) {\n            var input = node.inputs[i];\n            if (this.constants[input] !== undefined) {\n                inputs.push(this.constants[input]);\n            }\n            else {\n                var inter = intermediaryRes[input];\n                inter.used++;\n                if (inter.used >= this.intermediaries[input].to.length && this.intermediaries[input].deletable) {\n                    toDelete.push(input);\n                }\n                inputs.push(inter.value);\n            }\n        }\n        return { inputs: inputs, toDelete: toDelete };\n    };\n    OnnxModel.prototype.propagateResults = function (node, intermediaryRes, outputs, nodes, nodesReady) {\n        for (var i = 0; i < node.outputs.length; i++) {\n            var output = node.outputs[i];\n            intermediaryRes[output] = {\n                value: outputs[i],\n                used: 0\n            };\n            var inter = this.intermediaries[output];\n            if (inter !== undefined) {\n                for (var j = 0; j < inter.to.length; j++) {\n                    var id = inter.to[j];\n                    nodes[id].variableInputs++;\n                    if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                        nodesReady.push(id);\n                        delete nodes[id];\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Transfer the model to the CPU\n     */\n    OnnxModel.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toCPU(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toCPU()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Transfer the model to WASM\n     */\n    OnnxModel.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toWASM(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toWASM()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Transfer the model to the GPU\n     */\n    OnnxModel.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toGPU(this.constants[i], this.precision)];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toGPU(this.precision)];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Optimize the model.\n     */\n    OnnxModel.prototype.optimize = function () {\n        var _this = this;\n        for (var _i = 0, defaultOptimizations_1 = defaultOptimizations; _i < defaultOptimizations_1.length; _i++) {\n            var optimization = defaultOptimizations_1[_i];\n            var applications = optimization.findApplications(this);\n            for (var _a = 0, applications_1 = applications; _a < applications_1.length; _a++) {\n                var nodeIds = applications_1[_a];\n                var nodes = nodeIds.map(function (x) { return _this.nodes[x]; });\n                var newNode = optimization.apply(nodes, function (name) { return _this.resolveConstant(name); }, this.constants, this.version);\n                var outputs = new Set(newNode.outputs);\n                for (var _b = 0, nodeIds_1 = nodeIds; _b < nodeIds_1.length; _b++) {\n                    var nodeId = nodeIds_1[_b];\n                    this.removeNode(nodeId, outputs);\n                }\n                this.insertNode(newNode);\n            }\n        }\n        this.prune();\n    };\n    OnnxModel.prototype.prune = function () {\n        var _this = this;\n        while (true) {\n            var nodesToDelete = this.pruneIntermediaries();\n            if (nodesToDelete.size > 0) {\n                nodesToDelete.forEach(function (id) {\n                    _this.removeNode(id, new Set());\n                });\n            }\n            else {\n                break;\n            }\n        }\n    };\n    OnnxModel.prototype.pruneIntermediaries = function () {\n        var nodesToDelete = new Set();\n        var intermediariesToDelete = [];\n        for (var id in this.intermediaries) {\n            var intermediary = this.intermediaries[id];\n            if (intermediary.to.length === 0) {\n                intermediariesToDelete.push(id);\n                var nodeId = this.getNodeWithOutput(id);\n                if (nodeId !== undefined) {\n                    nodesToDelete.add(nodeId);\n                }\n            }\n        }\n        for (var _i = 0, intermediariesToDelete_1 = intermediariesToDelete; _i < intermediariesToDelete_1.length; _i++) {\n            var id = intermediariesToDelete_1[_i];\n            delete this.intermediaries[id];\n        }\n        return nodesToDelete;\n    };\n    OnnxModel.prototype.removeNode = function (nodeId, preserveIntermediaries) {\n        var node = this.nodes[nodeId];\n        for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n            if (this.intermediaries[input] !== undefined) {\n                this.intermediaries[input].to = this.intermediaries[input].to.filter(function (x) { return x.toString() !== nodeId.toString(); });\n            }\n        }\n        if (!preserveIntermediaries.has(node.outputs[0])) {\n            delete this.intermediaries[node.outputs[0]];\n        }\n        this.nodeIds = this.nodeIds.filter(function (x) { return x.toString() !== nodeId.toString(); });\n        this.nodes[nodeId].delete();\n        delete this.nodes[nodeId];\n    };\n    OnnxModel.prototype.insertNode = function (node) {\n        var id = this.nodeIdCounter++;\n        this.nodeIds.push(id);\n        this.nodes[id] = node;\n        for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n            this.intermediaries[input].to.push(id);\n        }\n    };\n    // Utility functions\n    OnnxModel.prototype.getNodeWithOutput = function (output) {\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var id = _a[_i];\n            if (this.nodes[id].outputs.findIndex(function (x) { return x === output; }) !== -1) {\n                return id;\n            }\n        }\n    };\n    OnnxModel.prototype.getNodeWithInput = function (output) {\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var id = _a[_i];\n            if (this.nodes[id].inputs.findIndex(function (x) { return x === output; }) !== -1) {\n                return id;\n            }\n        }\n    };\n    OnnxModel.prototype.resolveConstant = function (name) {\n        if (this.constants[name] !== undefined) {\n            return this.constants[name];\n        }\n        var nodeIdOut = this.getNodeWithOutput(name);\n        var nodeOut = this.nodes[nodeIdOut];\n        if (nodeOut instanceof ConstantNode) {\n            return nodeOut.tensor;\n        }\n        return undefined;\n    };\n    OnnxModel.prototype.getNodes = function () {\n        return this.nodes;\n    };\n    /**\n     * Deletes the model\n     *\n     * This will release the memory/framebuffers (depending on the backend)\n     */\n    OnnxModel.prototype.delete = function () {\n        for (var c in this.constants) {\n            this.constants[c].delete();\n        }\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            this.nodes[nodeId].delete();\n        }\n    };\n    return OnnxModel;\n}());\nexport { OnnxModel };\n//# sourceMappingURL=model.js.map","import * as tjs from '@hoff97/tensor-js';\n\n\nexport async function loadModel(name: string) {\n    const res = await fetch(`models/${name}.onnx`);\n    const buffer = await res.arrayBuffer();\n\n    const model = new tjs.onnx.model.OnnxModel(buffer, {\n        noConvertNodes: [69, 98],\n        precision: 16\n    });\n    await model.toGPU();\n\n    return model;\n}","import React from 'react';\nimport './App.css';\nimport { loadModel } from './inference';\n\nimport * as tjs from '@hoff97/tensor-js';\nimport { GPUTensor } from '../../../dist/lib/tensor/gpu/tensor';\n\ninterface AppState {\n  img: any;\n  scale: number;\n  croppedSize: number;\n  showResult: boolean;\n  model: string;\n}\n\nconst models = [\n  \"mosaic\",\n  \"candy\",\n  \"pointilism\",\n  \"udnie\",\n  \"rain-princess\"\n];\n\nconst imgs = [\n  \"n01440764_tench.JPEG\",\n  \"n03160309_dam.JPEG\",\n  \"n03216828_dock.JPEG\",\n  \"n03670208_limousine.JPEG\",\n  \"n04548280_wall_clock.JPEG\",\n  \"n04552348_warplane.JPEG\",\n  \"n04599235_wool.JPEG\",\n  \"n06874185_traffic_light.JPEG\",\n  \"n07873807_pizza.JPEG\",\n  \"n07920052_espresso.JPEG\",\n  \"n09193705_alp.JPEG\",\n  \"n12620546_hip.JPEG\",\n];\n\nclass App extends React.Component<{}, AppState> {\n  private model?: tjs.onnx.model.OnnxModel = undefined;\n\n  private scale = new tjs.tensor.gpu.GPUTensor(new Float32Array([255]), [1], 16);\n\n  constructor(props: {}) {\n    super(props);\n\n    loadModel('mosaic').then(x => {\n      this.model = x;\n      console.log('Got model');\n    });\n\n    this.setState({\n      scale: 50,\n      model: 'mosaic'\n    });\n  }\n\n  getImageData() {\n    const el = document.getElementById(\"img\") as HTMLImageElement;\n\n    console.log('Reading pixels');\n    const tensor = tjs.tensor.gpu.GPUTensor.fromData(el, 16);\n\n    let [height, width] = tensor.shape.slice(0,2);\n\n    const cropSize = Math.min(width, height);\n    const halfSize = Math.floor(cropSize/2);\n\n    const widthSliceStart = Math.floor(width/2) - halfSize;\n    const heightSliceStart = Math.floor(height/2) - halfSize;\n\n    const sliced = tensor.slice([heightSliceStart, widthSliceStart,0], [heightSliceStart + cropSize,widthSliceStart + cropSize,3], [0,1,2]);\n    tensor.delete();\n\n    const showWidth = this.getImageWidth(this.state.scale);\n    const scale = showWidth/width;\n    const scaled = sliced.upsample([scale,scale,1]);\n    sliced.delete();\n\n    const croppedSize = scaled.getShape()[0];\n\n    this.setState({\n      ...this.state,\n      croppedSize: croppedSize,\n    });\n\n    const transposed = scaled.transpose([2, 0, 1]);\n    scaled.delete();\n    const multiplied = transposed.multiply(this.scale)\n    transposed.delete();\n    const reshaped = multiplied.reshape([1,3,croppedSize,croppedSize], false);\n\n    console.log('Doing forward pass');\n    this.model?.forward([reshaped], 100).then(result => this.handleResult(result[0]));\n  }\n\n  handleResult(tensor: tjs.Tensor) {\n    console.log('Got result', tensor);\n\n    this.setState({\n      ...this.state,\n      showResult: true\n    })\n\n    const sh = tensor.getShape();\n\n    tensor = tensor.reshape(sh.slice(1), false);\n    const transposed = tensor.transpose([1,2,0]);\n    console.log(transposed.getShape());\n    tensor.delete();\n\n    const t = (transposed as tjs.tensor.gpu.GPUTensor).copy(32) as GPUTensor;\n    transposed.delete();\n\n    t.getValues().then(x => {\n      const canv = document.getElementById(\"canvas\") as HTMLCanvasElement;\n      const context = canv.getContext(\"2d\");\n\n      if (context) {\n        var id = context.createImageData(t.shape[0],t.shape[1]);\n        var d  = id.data;\n        console.log(d.length, x.length);\n\n        for (let i = 0; i < x.length; i++) {\n          const pos = Math.floor(i/3);\n          const offset = i%3;\n          d[pos*4+offset] = Math.round(x[i]);\n          d[pos*4+3] = 255;\n        }\n        context.putImageData(id, 0, 0);\n      }\n\n      t.delete();\n    });\n  }\n\n  fileSelected(ev: React.ChangeEvent<HTMLInputElement>) {\n    //@ts-ignore\n    this.setState({\n      ...this.state,\n      scale: 50,\n      //@ts-ignore\n      img: URL.createObjectURL(ev.target.files[0]),\n      showResult: false\n    });\n  }\n\n  setImage(img: string) {\n    this.setState({\n      ...this.state,\n      //@ts-ignore\n      img: \"img/\" + img,\n      scale: 50,\n      showResult: false\n    });\n  }\n\n  getImageWidth(scale: number) {\n    const width = Math.round(400*(scale/50) + 50);\n\n    return Math.floor(width/32)*32;\n  }\n\n  async setModel(name: string) {\n    this.setState({\n      ...this.state,\n      model: name\n    })\n    this.model = await loadModel(name);\n  }\n\n  render() {\n    let img;\n    let scale = 50;\n    let croppedSize = 50;\n    let showResult = false;\n    if (this.state) {\n      img = this.state.img;\n      scale = this.state.scale || 50;\n      croppedSize = this.state.croppedSize;\n      showResult = this.state.showResult;\n    }\n\n    const width = this.getImageWidth(scale);\n\n    return (\n      <div className=\"App\">\n        <h1>Style transfer</h1>\n        <label htmlFor=\"model\">Choose a style:</label> <select id=\"model\" onChange={x => this.setModel(x.target.value)}>\n          {\n            models.map(x => (\n              <option value={x} key={x}>{x}</option>\n            ))\n          }\n        </select><br/>\n        <label htmlFor=\"file\">Choose an image:</label> <input type='file' id=\"file\" onChange={x => this.fileSelected(x)}/><br/>\n        Or use one of the examples:\n        <table>\n          <tr>\n            {imgs.map(img => (\n              <td>\n                <img src={\"img/\" + img}\n                  height={50} onClick={() => this.setImage(img)}\n                  className=\"exampleImage\" alt=\"Example\"></img>\n              </td>\n            ))}\n          </tr>\n        </table>\n        { img !== undefined ? (<>\n            <div className=\"slidecontainer\">\n              Scale: <input type=\"range\" min=\"1\" max=\"100\" defaultValue={scale}\n                className=\"slider\" id=\"myRange\"\n                //@ts-ignore\n                onChange={ev => this.setState({...this.state, showResult: false, scale: parseInt(ev.currentTarget.value)})}/>\n            </div>\n            <img id=\"img\" src={this.state.img} alt=\"Your upload\" width={width}/><br/>\n\n            <button onClick={() => this.getImageData()}>Run</button><br/>\n\n            {\n              showResult ? (\n                <canvas id=\"canvas\" width={croppedSize} height={croppedSize}></canvas>\n              ) : (<></>)\n            }\n          </>) : (<></>)}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}