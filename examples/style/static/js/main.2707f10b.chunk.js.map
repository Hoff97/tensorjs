{"version":3,"sources":["../../../../lib/util/shape.ts","../../../lib/types.ts","../../../../../lib/ops/util/conv.ts","../../../../../lib/ops/cpu/basic.ts","../../../../../lib/ops/util/convTranspose.ts","../../../../../lib/ops/util/pool.ts","../../../../../lib/ops/cpu/pool.ts","../../../../../lib/ops/cpu/pad.ts","../../../../../lib/tensor/cpu/tensor.ts","../../../../../lib/ops/cpu/setValues.ts","../../../../../lib/ops/cpu/matMul.ts","../../../../../lib/ops/cpu/gemm.ts","../../../../../lib/ops/cpu/sum.ts","../../../../../lib/ops/cpu/sumSquare.ts","../../../../../lib/ops/cpu/product.ts","../../../../../lib/ops/cpu/max.ts","../../../../../lib/ops/cpu/min.ts","../../../../../lib/ops/cpu/reduceMean.ts","../../../../../lib/ops/cpu/reduceMeanSquare.ts","../../../../../lib/ops/cpu/conv.ts","../../../../../lib/ops/cpu/convTranspose.ts","../../../../../lib/ops/cpu/averagePool.ts","../../../../../lib/ops/cpu/concat.ts","../../../../../lib/ops/cpu/transpose.ts","../../../../../lib/ops/cpu/repeat.ts","../../../../../lib/ops/cpu/expand.ts","../../../../../lib/ops/cpu/gather.ts","../../../../../lib/ops/cpu/slice.ts","../../../../../lib/ops/cpu/upsample.ts","../../../../../lib/ops/cpu/normalize.ts","../../../../../lib/util/datastructs/dict.ts","../../../../lib/util/math.ts","../../../../../lib/tensor/gpu/memory.ts","../../../../../lib/tensor/gpu/gl.ts","../../../../../lib/tensor/wasm/tensor.ts","../../../../../lib/ops/gpu/operation.ts","../../../../../../lib/ops/gpu/matMul/matmul.ts","../../../../../../lib/ops/gpu/unary/unaryOperation.ts","../../../../../../lib/ops/gpu/unary/exp.ts","../../../../../../lib/ops/gpu/conv/conv.ts","../../../../../../lib/ops/gpu/unary/abs.ts","../../../../../../lib/ops/gpu/binary/binaryOperation.ts","../../../../../../lib/ops/gpu/binary/add.ts","../../../../../../lib/ops/gpu/binary/multiply.ts","../../../../../../lib/ops/gpu/binary/subtract.ts","../../../../../../lib/ops/gpu/binary/divide.ts","../../../../../../lib/ops/gpu/conv/averagePool.ts","../../../../../../lib/ops/gpu/pool/pool.ts","../../../../../../lib/ops/gpu/pool/reduceMean.ts","../../../../../../lib/ops/gpu/pool/reduceMeanSquare.ts","../../../../../../lib/ops/gpu/pool/sumSquare.ts","../../../../../../lib/ops/gpu/pool/sum.ts","../../../../../../lib/ops/gpu/pool/product.ts","../../../../../../lib/ops/gpu/pool/max.ts","../../../../../../lib/ops/gpu/pool/min.ts","../../../../../../lib/ops/gpu/unary/ceil.ts","../../../../../../lib/ops/gpu/unary/clip.ts","../../../../../../lib/ops/gpu/unary/floor.ts","../../../../../../lib/ops/gpu/util/concat.ts","../../../../../../lib/ops/gpu/util/copy.ts","../../../../../../lib/ops/gpu/util/expand.ts","../../../../../../lib/ops/gpu/util/gather.ts","../../../../../../lib/ops/gpu/matMul/gemm.ts","../../../../../../lib/ops/gpu/binary/power.ts","../../../../../../lib/ops/gpu/unary/sqrt.ts","../../../../../../lib/ops/gpu/unary/log.ts","../../../../../../lib/ops/gpu/util/transpose.ts","../../../../../../lib/ops/gpu/util/repeat.ts","../../../../../../lib/ops/gpu/conv/pad.ts","../../../../../../lib/ops/gpu/util/slice.ts","../../../../../../lib/ops/gpu/conv/upsample.ts","../../../../../../lib/ops/gpu/conv/normalize.ts","../../../../../lib/ops/gpu/dispatcher.ts","../../../../../../lib/ops/gpu/unary/sign.ts","../../../../../../lib/ops/gpu/unary/negate.ts","../../../../../../lib/ops/gpu/util/clipBackward.ts","../../../../../../lib/ops/gpu/conv/convTranspose.ts","../../../../../../lib/ops/gpu/unary/sigmoid.ts","../../../../../../lib/ops/gpu/unary/addMultiplyScalar.ts","../../../../../../lib/ops/gpu/util/setValues.ts","../../../../../lib/tensor/gpu/tensor.ts","../../../../../../lib/autograd/ops/unary/absBack.ts","../../../../../../lib/autograd/ops/unary/expBack.ts","../../../../../../lib/autograd/ops/unary/logBack.ts","../../../../../../lib/autograd/ops/matMul/matMulBack.ts","../../../../../../lib/autograd/ops/unary/negateBack.ts","../../../../../../lib/autograd/ops/unary/sqrtBack.ts","../../../../../../lib/autograd/ops/util/concatBack.ts","../../../../../../lib/autograd/ops/unary/clipBack.ts","../../../../../../lib/autograd/ops/util/repeatBack.ts","../../../../../../lib/autograd/ops/util/expandBack.ts","../../../../../../lib/autograd/ops/util/reshapeBack.ts","../../../../../../lib/autograd/ops/binary/addBack.ts","../../../../../../lib/autograd/ops/binary/subtractBack.ts","../../../../../../lib/autograd/ops/binary/multiplyBack.ts","../../../../../../lib/autograd/ops/conv/convBack.ts","../../../../../../lib/autograd/ops/binary/divideBack.ts","../../../../../../lib/autograd/ops/binary/powerBack.ts","../../../../../../lib/autograd/ops/matMul/gemmBack.ts","../../../../../../lib/autograd/ops/util/transposeBack.ts","../../../../../../lib/autograd/ops/reduce/sumBack.ts","../../../../../../lib/autograd/ops/reduce/sumSquareBack.ts","../../../../../../lib/autograd/ops/unary/addMultiplyScalarBack.ts","../../../../../../lib/autograd/ops/reduce/meanBack.ts","../../../../../../lib/autograd/ops/reduce/meanSquareBack.ts","../../../../../../lib/autograd/ops/util/sliceBack.ts","../../../../../../lib/autograd/ops/conv/averagePoolBack.ts","../../../../../../lib/autograd/ops/conv/padBack.ts","../../../../../../lib/autograd/ops/reduce/productBack.ts","../../../../../../lib/autograd/ops/unary/sigmoidBack.ts","../../../../lib/autograd/variable.ts","../../../../lib/util/convert.ts","../../../../lib/model/module.ts","../../../../lib/onnx/node.ts","../../../../lib/onnx/util.ts","../../../../lib/onnx/definitions.ts","../../../../../lib/onnx/nodes/constant.ts","../../../../../lib/onnx/nodes/conv.ts","../../../../../lib/onnx/optimizations/optimization.ts","../../../../../lib/onnx/optimizations/convBatchnorm.ts","../../../../../lib/onnx/optimizations/convRelu.ts","../../../../../lib/onnx/optimizations/convRelu6.ts","../../../../../lib/onnx/optimizations/default.ts","../../../../../../lib/onnx/nodes/binary/binaryNode.ts","../../../../../../lib/onnx/nodes/binary/add.ts","../../../../../lib/onnx/nodes/batchNormalization.ts","../../../../../lib/ops/cpu/cast.ts","../../../../../lib/onnx/nodes/cast.ts","../../../../../../lib/onnx/nodes/unary/unaryNode.ts","../../../../../../lib/onnx/nodes/unary/ceil.ts","../../../../../lib/onnx/nodes/clip.ts","../../../../../lib/onnx/nodes/concat.ts","../../../../../lib/onnx/nodes/constantOfShape.ts","../../../../../../lib/onnx/nodes/binary/div.ts","../../../../../../lib/onnx/nodes/unary/exp.ts","../../../../../lib/onnx/nodes/expand.ts","../../../../../../lib/onnx/nodes/unary/floor.ts","../../../../../lib/onnx/nodes/gather.ts","../../../../../lib/onnx/nodes/gemm.ts","../../../../../lib/onnx/nodes/instanceNormalization.ts","../../../../../lib/onnx/nodes/matMul.ts","../../../../../../lib/onnx/nodes/binary/mul.ts","../../../../../lib/onnx/nodes/pad.ts","../../../../../../lib/onnx/nodes/reduce/reduceNode.ts","../../../../../../lib/onnx/nodes/reduce/reduceMax.ts","../../../../../../lib/onnx/nodes/reduce/reduceMean.ts","../../../../../../lib/onnx/nodes/reduce/reduceSum.ts","../../../../../../lib/onnx/nodes/reduce/reduceSumSquare.ts","../../../../../lib/onnx/nodes/relu.ts","../../../../../lib/onnx/nodes/reshape.ts","../../../../../lib/onnx/nodes/shape.ts","../../../../../lib/onnx/nodes/slice.ts","../../../../../lib/onnx/nodes/softmax.ts","../../../../../../lib/onnx/nodes/binary/sub.ts","../../../../../lib/onnx/nodes/tile.ts","../../../../../lib/onnx/nodes/transpose.ts","../../../../../lib/onnx/nodes/unsqueeze.ts","../../../../../lib/onnx/nodes/upsample.ts","../../../../../lib/onnx/nodes/globalAveragePool.ts","../../../../lib/onnx/resolve.ts","../../../../lib/onnx/model.ts","../../../../../lib/model/optimizer/optimizer.ts","../../../../lib/model/basic.ts","../../../../../../lib/model/optimizer/adam/updateMoments.ts","../../../../../../lib/model/optimizer/adam/updateParams.ts","../../../../../../lib/model/optimizer/adam/Adam.ts","../../../../../lib/model/optimizer/SGD.ts","../../../../../../../lib/model/functional/bce/back/gpu.ts","../../../../../../../lib/model/functional/bce/back/back.ts","../../../../../../../lib/model/functional/bce/back/cpu.ts","../../../../../../lib/model/functional/bce/gpu.ts","../../../../lib/model/regularization.ts","inference.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["getSize","shape","strides","i","ax","this","getShape","Tensor","prototype","outputDimSize","a","poolResultShape","_this","CPUTensor","add_impl","rank","x","length","result","ix","indexX","outputShape","resultShape","axIx","primeFactors","num","gte","lte","Operation","type","MultiplyOperation","getVariables","SubtractOperation","DivideOperation","b","ClipOperation","ConcatOperation","ExpandOperation","GemmOperation","input","RepeatOperation","SliceOperation","Dispatcher","AddMultiplyScalarOperation","operation","SetValuesOperation","GPUTensor","WASMTensor","ConcatBack","backward","gradB","permutation","newShape","Variable","backEdge","noGrad","value","tensor","bias","to","arr","ReduceNode","SoftmaxNode","attributes","inputs","outputs","constants","onnxVersion","mode","inter","_i","_a","moment1","back","gradX","loadModel","name","fetch","res","arrayBuffer","buffer","model","tjs","OnnxModel","noConvertNodes","precision","toGPU","models","imgs","App","props","undefined","scale","gpu","Float32Array","then","console","log","setState","el","document","getElementById","fromData","slice","height","width","cropSize","Math","min","halfSize","floor","widthSliceStart","heightSliceStart","sliced","delete","getImageWidth","state","scaled","upsample","croppedSize","transposed","transpose","multiplied","multiply","reshaped","reshape","forward","handleResult","showResult","sh","t","copy","getValues","context","getContext","id","createImageData","d","data","pos","round","putImageData","ev","img","URL","createObjectURL","target","files","className","htmlFor","onChange","setModel","map","fileSelected","src","onClick","setImage","alt","max","defaultValue","parseInt","currentTarget","getImageData","React","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2707f10b.chunk.js","sourcesContent":["export function getSize(shape) {\n    if (shape.length === 0) {\n        return 0;\n    }\n    var size = 1;\n    for (var i = 0; i < shape.length; i += 1) {\n        size *= shape[i];\n    }\n    return size;\n}\nexport function computeStrides(shape) {\n    var rank = shape.length;\n    if (rank === 0) {\n        return [];\n    }\n    if (rank === 1) {\n        if (shape[0] === 1) {\n            return [0];\n        }\n        else {\n            return [1];\n        }\n    }\n    var strides = new Array(rank);\n    strides[rank - 1] = 1;\n    if (shape[rank - 1] === 1) {\n        strides[rank - 1] = 0;\n    }\n    var lastStride = 1;\n    for (var i = rank - 2; i >= 0; i -= 1) {\n        lastStride = shape[i + 1] * lastStride;\n        if (shape[i] === 1) {\n            strides[i] = 0;\n        }\n        else {\n            strides[i] = lastStride;\n        }\n    }\n    return strides;\n}\nexport function indexToPos(index, strides, shape) {\n    var ix = 0;\n    for (var i = 0; i < index.length; i += 1) {\n        if (shape) {\n            if (index[i] < 0 || (index[i] >= shape[i] && shape[i] !== 1)) {\n                throw new Error('Invalid index');\n            }\n        }\n        ix += index[i] * strides[i];\n    }\n    return ix;\n}\nexport function posToIndex(pos, strides) {\n    var res = pos;\n    var rank = strides.length;\n    var index = new Array(rank);\n    for (var i = 0; i < index.length; i += 1) {\n        index[i] = Math.floor(res / strides[i]);\n        res %= strides[i];\n    }\n    return index;\n}\nexport function compareShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function checkEquivShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i] && a[i] !== 1 && b[i] !== 1) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function incrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] += 1;\n        if (index[i] >= shape[i]) {\n            index[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function decrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] -= 1;\n        if (index[i] < 0) {\n            index[i] = shape[i] - 1;\n        }\n        else {\n            break;\n        }\n    }\n}\n//# sourceMappingURL=shape.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { compareShapes, getSize } from './util/shape';\nvar Tensor = /** @class */ (function () {\n    function Tensor() {\n    }\n    /**\n     * Compares this tensor to another tensor.\n     *\n     * @param tensor Tensor to compare to\n     * @param epsilon Optional maximum difference between the tensors. If not specified the tensors have to be exactly equal\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2], [1,2,3,4]);\n     * const b = new CPUTensor([2,2], [1.1,2.1,2.9,4.05]);\n     * const c = new CPUTensor([4], [1,2,3,4]);\n     * a.compare(b, 0.5).then(equal => {\n     *  //equal will be true\n     * });\n     *\n     * a.compare(b).then(equal => {\n     *  //equal will be false\n     * });\n     *\n     * a.compare(c).then(equal => {\n     *  //equal will be false since the shapes of the tensors do not match\n     * });\n     * ```\n     */\n    Tensor.prototype.compare = function (tensor, epsilon) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arrA, arrB, i, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!compareShapes(this.getShape(), tensor.getShape())) {\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.getValues()];\n                    case 1:\n                        arrA = _a.sent();\n                        return [4 /*yield*/, tensor.getValues()];\n                    case 2:\n                        arrB = _a.sent();\n                        if (epsilon !== undefined) {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (Math.abs(arrA[i] - arrB[i]) > epsilon) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        else {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (arrA[i] !== arrB[i]) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    Tensor.prototype.getAxes = function (axes) {\n        var ax;\n        var sh = this.getShape();\n        if (axes === undefined) {\n            ax = [];\n            for (var i = 0; i < sh.length; i++) {\n                ax.push(i);\n            }\n        }\n        else if (!(axes instanceof Array)) {\n            ax = [axes];\n        }\n        else {\n            ax = axes;\n        }\n        return ax;\n    };\n    /**\n     * Sums over the specified axis/axes.\n     *\n     * @param axes One or multiple axes to sum over. If not specified this will sum over all axes\n     * @param keepDims Wether the summation axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.sum(); //Will be [21]\n     * a.sum(0); //Will be [5,7,9]\n     * a.sum(1); //Will [6,15]\n     * a.sum(0, true); //Will be [[5,7,9]]\n     * ```\n     */\n    Tensor.prototype.sum = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sum_impl(ax, keepDims);\n    };\n    /**\n     * Sums over the specified axis/axes with the entries of the tensor squared.\n     * This is equal to `a.multiply(a).sum(axes, keepDims)` but faster\n     *\n     * @param axes One or multiple axes to sum over. If not specified this will sum over all axes\n     * @param keepDims Wether the summation axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.sumSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sumSquare_impl(ax, keepDims);\n    };\n    /**\n     * Takes the product over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the product over. If not specified this will be all axes\n     * @param keepDims Wether the product axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.product(); //Will be [720]\n     * a.product(0); //Will be [4,10,18]\n     * a.product(1); //Will [6,120]\n     * a.product(0, true); //Will be [[4,10,18]]\n     * ```\n     */\n    Tensor.prototype.product = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.product_impl(ax, keepDims);\n    };\n    /**\n     * Takes the maximum over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the maximum over. If not specified this will be all axes\n     * @param keepDims Wether the maximum axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.max(); //Will be [6]\n     * a.max(0); //Will be [4,5,6]\n     * a.max(1); //Will [3,6]\n     * a.max(0, true); //Will be [[4,5,6]]\n     * ```\n     */\n    Tensor.prototype.max = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.max_impl(ax, keepDims);\n    };\n    /**\n     * Takes the minimum over specified axis/axes.\n     *\n     * @param axes One or multiple axes to take the minimum over. If not specified this will be all axes\n     * @param keepDims Wether the minimum axes will be kept with size 1\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,3], [1,2,3,4,5,6]);\n     *\n     * a.min(); //Will be [1]\n     * a.min(0); //Will be [1,2,3]\n     * a.min(1); //Will [1,4]\n     * a.min(0, true); //Will be [[1,2,3]]\n     * ```\n     */\n    Tensor.prototype.min = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.min_impl(ax, keepDims);\n    };\n    /**\n     * Takes the mean over the specified axis/axes.\n     * This is equal to `a.sum(axes, keepDims).divide(sumSize)` (where sumSize is the number\n     * of entries in the summation axes) but faster.\n     *\n     * @param axes One or multiple axes to take the mean over. If not specified this will take the mean over all axes\n     * @param keepDims Wether the mean axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.reduceMean = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMean_impl(ax, keepDims);\n    };\n    /**\n     * Takes the mean over the specified axis/axes with the entries of the tensor squared.\n     * This is equal to `a.multiply(a).sum(axes, keepDims).divide(sumSize)` (where sumSize is the number\n     * of entries in the summation axes) but faster.\n     *\n     * @param axes One or multiple axes to take the mean over. If not specified this will take the mean over all axes\n     * @param keepDims Wether the mean axes will be kept with size 1\n     *\n     */\n    Tensor.prototype.reduceMeanSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMeanSquare_impl(ax, keepDims);\n    };\n    /**\n     * Convolves this tensor with the specified kernel.\n     *\n     * This tensor should have shape [N,C,D1,D2,...] where D1,D2,... are the spatial dimensions.\n     *\n     * Behaves according to https://github.com/onnx/onnx/blob/master/docs/Operators.md#Conv\n     *\n     * @param kernel Convolution kernel with shape [M,C/G,K1,K2] where G is the group parameter\n     * @param bias Optional bias to add to the result with shape [M]\n     * @param dilations Per axis dilations for the spatial dimension. Defaults to 1 for all axes\n     * @param group Group parameter\n     * @param pads Padding to add to the input for each spatial dimension. Defaults to 0 for all axes\n     * @param strides Convolution stride for each spatial dimension. Defaults to 1 for all axes\n     * @param activation Optional activation to apply. Defaults to the identity (so no activation)\n     */\n    Tensor.prototype.conv = function (kernel, bias, dilations, group, pads, strides, activation) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        dilations = dilations || new Array(dataRank).fill(1);\n        group = group || 1;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        if (activation === undefined) {\n            activation = 'id';\n        }\n        return this.conv_impl(kernel, dilations, group, pads, strides, activation, bias);\n    };\n    /**\n     * Calculates the transpose convolution\n     *\n     * This tensor should have shape [N,C,D1,D2,...] where D1,D2,... are the spatial dimensions.\n     *\n     * @param kernel Convolution kernel with shape [M,C/G,K1,K2] where G is the group parameter\n     * @param dilations Per axis dilations for the spatial dimension. Defaults to 1 for all axes\n     * @param group Group parameter\n     * @param pads Padding to add to the input for each spatial dimension. Defaults to 0 for all axes\n     * @param strides Convolution stride for each spatial dimension. Defaults to 1 for all axes\n     */\n    Tensor.prototype.convTranspose = function (kernel, dilations, group, pads, strides) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        dilations = dilations || new Array(dataRank).fill(1);\n        group = group || 1;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        return this.convTranspose_impl(kernel, dilations, group, pads, strides);\n    };\n    /**\n     * Pads the input according to the padding mode. The input has shape [D1,D2,..]\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * a.pad([1,1,1,1],'constant',5);\n     * //Result will be:\n     * // [[5,5,5,5],\n     * //  [5,1,2,5],\n     * //  [5,3,4,5],\n     * //  [5,5,5,5]]\n     * a.pad([1,1,1,1],'edge');\n     * //Result will be:\n     * // [[1,1,2,2],\n     * //  [1,1,2,2],\n     * //  [3,3,4,4],\n     * //  [3,3,4,4]]\n     *\n     * a.pad([2,2,2,2],'reflect');\n     * //Result will be:\n     * // [[4,3,3,4,4,3],\n     * //  [2,1,1,2,2,1],\n     * //  [2,1,1,2,2,1],\n     * //  [4,3,3,4,4,3],\n     * //  [4,3,3,4,4,3],\n     * //  [2,1,1,2,2,1]]\n     * ```\n     *\n     * @param pads Padding size of each input. Specified as [startpad_D1,startpad_D2,...,startpad_DN,endpad_D1,endpad_D2,...]\n     * @param mode Padding mode. One of 'constant', 'edge', 'reflect'. Defaults to 'constant'\n     * @param value Value for constant padding. Defaults to 0.0\n     */\n    Tensor.prototype.pad = function (pads, mode, value) {\n        if (mode === undefined) {\n            mode = 'constant';\n        }\n        if (value === undefined) {\n            value = 0;\n        }\n        return this.pad_impl(pads, mode, value);\n    };\n    /**\n     * Performs average pooling over the spatial dimensions of this tensor with\n     * shape [N,C,D1,D2,..]\n     * @param kernelShape Size of the average pooling dimension\n     * @param pads Padding of the input specified as [startpad_D1,startpad_D2,...,startpad_DN,endpad_D1,endpad_D2,...]\n     *             Padding value will be 0. Defaults to 0 for all axes\n     * @param strides Stride size of the average pooling kernel. Defaults to 1 for all axes\n     * @param includePad Wether padded values should be included in the average (or masked out). Defaults to false\n     */\n    Tensor.prototype.averagePool = function (kernelShape, pads, strides, includePad) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        includePad = includePad || false;\n        return this.averagePool_impl(kernelShape, pads, strides, includePad);\n    };\n    /**\n     * Reshape the tensor to the specified shape\n     *\n     * At most one value in the shape can be -1, which will be replaced by the inferred size for this dimension.\n     *\n     * @param shape New shape of the tensor\n     * @param copy Wether the tensor values should be copied. Only has an effect on GPU tensors\n     */\n    Tensor.prototype.reshape = function (shape, copy) {\n        var shSize = 1;\n        var negIndex = -1;\n        for (var i = 0; i < shape.length; i++) {\n            if (shape[i] === -1) {\n                negIndex = i;\n            }\n            else {\n                shSize *= shape[i];\n            }\n        }\n        if (copy === undefined) {\n            copy = true;\n        }\n        if (negIndex !== -1) {\n            var currShape = this.getShape();\n            var currSize = getSize(currShape);\n            var _shape = __spreadArrays(shape);\n            _shape[negIndex] = currSize / shSize;\n            return this.reshape_impl(_shape, copy);\n        }\n        return this.reshape_impl(shape, copy);\n    };\n    Tensor.prototype.alignShapes = function (shape1, shape2) {\n        var _a, _b;\n        if (compareShapes(shape1, shape2)) {\n            return [shape1, shape2, shape1];\n        }\n        if (shape1.length < shape2.length) {\n            shape1 = __spreadArrays(shape1);\n            var prepend = shape2.length - shape1.length;\n            (_a = shape1).unshift.apply(_a, new Array(prepend).fill(1));\n        }\n        else if (shape2.length < shape1.length) {\n            shape2 = __spreadArrays(shape2);\n            var prepend = shape1.length - shape2.length;\n            (_b = shape2).unshift.apply(_b, new Array(prepend).fill(1));\n        }\n        var resultShape = new Array(shape1.length).fill(1);\n        for (var i = 0; i < shape1.length; i++) {\n            resultShape[i] = Math.max(shape1[i], shape2[i]);\n        }\n        return [shape1, shape2, resultShape];\n    };\n    /**\n     * Align the shapes of this tensor and the given tensor according to\n     * the broadcasting rules:\n     * https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md\n     *\n     * @param tensor Tensor of which the shapes should be aligned\n     */\n    Tensor.prototype.alignTensor = function (tensor) {\n        var _a, _b;\n        var thisShape = this.getShape();\n        var thatShape = tensor.getShape();\n        if (compareShapes(thisShape, thatShape)) {\n            return [this, tensor, thisShape];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        var th = this;\n        if (thisShape.length < thatShape.length) {\n            thisShape = __spreadArrays(thisShape);\n            var prepend = thatShape.length - thisShape.length;\n            (_a = thisShape).unshift.apply(_a, new Array(prepend).fill(1));\n            th = this.reshape(thisShape, false);\n        }\n        else if (thatShape.length < thisShape.length) {\n            thatShape = __spreadArrays(thatShape);\n            var prepend = thisShape.length - thatShape.length;\n            (_b = thatShape).unshift.apply(_b, new Array(prepend).fill(1));\n            tensor = tensor.reshape(thatShape, false);\n        }\n        var resultShape = new Array(thisShape.length).fill(1);\n        for (var i = 0; i < thisShape.length; i++) {\n            resultShape[i] = Math.max(thisShape[i], thatShape[i]);\n        }\n        return [th, tensor, resultShape];\n    };\n    /**\n     * Adds two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * const b = new CPUTensor([2,2],[5,6,7,8]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.add(b);\n     * //Will be\n     * // [[6,8],\n     * //  [10,12]]\n     *\n     * a.add(c);\n     * //Will be\n     * // [[3,4],\n     * //  [5,6]]\n     * ```\n     */\n    Tensor.prototype.add = function (tensor, alpha, beta) {\n        if (alpha === undefined) {\n            alpha = 1;\n        }\n        if (beta === undefined) {\n            beta = 1;\n        }\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.add_impl(th, tens, resultShape, alpha, beta);\n    };\n    /**\n     * Subtracts two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[1,2,3,4]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.subtract(b);\n     * //Will be\n     * // [[4,4],\n     * //  [4,4]]\n     *\n     * a.subtract(c);\n     * //Will be\n     * // [[3,4],\n     * //  [5,6]]\n     * ```\n     */\n    Tensor.prototype.subtract = function (tensor, alpha, beta) {\n        if (alpha === undefined) {\n            alpha = 1;\n        }\n        if (beta === undefined) {\n            beta = 1;\n        }\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.subtract_impl(th, tens, resultShape, alpha, beta);\n    };\n    /**\n     * Multiplies two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[1,2,3,4]);\n     * const b = new CPUTensor([2,2],[5,6,7,8]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.multiply(b);\n     * //Will be\n     * // [[5,12],\n     * //  [21,32]]\n     *\n     * a.multiply(c);\n     * //Will be\n     * // [[2,4]\n     *     [6,8]]\n     * ```\n     */\n    Tensor.prototype.multiply = function (tensor, alpha) {\n        if (alpha === undefined) {\n            alpha = 1;\n        }\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.multiply_impl(th, tens, resultShape, alpha);\n    };\n    Tensor.prototype.multiplyScalar = function (value) {\n        return this.addMultiplyScalar(value, 0);\n    };\n    Tensor.prototype.addScalar = function (value) {\n        return this.addMultiplyScalar(1, value);\n    };\n    /**\n     * Divides two tensors. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[1,2,3,4]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.divide(b);\n     * //Will be\n     * // [[5,3],\n     * //  [2.333,2]]\n     *\n     * a.divide(c);\n     * //Will be\n     * // [[2.5,3],\n     * //  [3.5,4]]\n     * ```\n     */\n    Tensor.prototype.divide = function (tensor, alpha) {\n        if (alpha === undefined) {\n            alpha = 1;\n        }\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.divide_impl(th, tens, resultShape, alpha);\n    };\n    /**\n     * Takes the positionwise power. Supports broadcasting\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     * const b = new CPUTensor([2,2],[2,3,2,3]);\n     * const c = new CPUTensor([1],[2]);\n     *\n     * a.power(b);\n     * //Will be\n     * // [[25,216],\n     * //  [49,512]]\n     *\n     * a.power(c);\n     * //Will be\n     * // [[25,36],\n     * //  [49,64]]\n     * ```\n     */\n    Tensor.prototype.power = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.power_impl(th, tens, resultShape);\n    };\n    /**\n     * Transposes the tensor according to the given permutation\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     *\n     * a.transpose();\n     * //Will be\n     * // [[5,7],\n     * //  [6,8]]\n     * ```\n     * @param permutation Permutation for the axes. Default is the reverse axis order\n     */\n    Tensor.prototype.transpose = function (permutation) {\n        if (permutation === undefined) {\n            var shape = this.getShape();\n            var rank = shape.length;\n            permutation = [];\n            for (var i = 0; i < rank; i++) {\n                permutation.push(rank - i - 1);\n            }\n        }\n        return this.transpose_impl(permutation);\n    };\n    /**\n     * Takes the softmax along the given axis\n     * https://en.wikipedia.org/wiki/Softmax_function\n     */\n    Tensor.prototype.softmax = function (axis) {\n        var max = this.max(axis, true);\n        var normalized = this.subtract(max);\n        var exp = normalized.exp();\n        var sum = exp.sum(axis, true);\n        var result = exp.divide(sum);\n        max.delete();\n        normalized.delete();\n        exp.delete();\n        sum.delete();\n        return result;\n    };\n    /**\n     * Calculates the general matrix product.\n     * https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_3\n     *\n     * A and B can have batch dimensions. Their last two dimensions should\n     * correspond to the dimensions for the matrix product\n     *\n     * @param b Second matrix for the matrix product\n     * @param aTranspose If the last two dimensions of a are transposed. Defaults to false\n     * @param bTranspose If the last two dimensions of a are transposed. Defaults to false\n     * @param alpha Alpha parameter. Defaults to 1.0\n     * @param c Optional tensor to add to the result.\n     * @param beta Beta parameter, only used if c is specified. Defaults to 1.0\n     */\n    Tensor.prototype.gemm = function (b, aTranspose, bTranspose, alpha, c, beta) {\n        aTranspose = aTranspose || false;\n        bTranspose = bTranspose || false;\n        alpha = alpha !== undefined ? alpha : 1;\n        beta = beta !== undefined ? beta : 1;\n        if (c !== undefined) {\n            var aShape = this.getShape();\n            var cShape = c.getShape();\n            var aRank = aShape.length;\n            var cRank = cShape.length;\n            if (aRank > cRank) {\n                cShape = __spreadArrays(new Array(aRank - cRank).fill(1), cShape);\n                c = c.reshape(cShape, false);\n            }\n        }\n        return this.gemm_impl(b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    /**\n     * Takes a slice of the tensor along the specified axes.\n     *\n     * @example\n     * ```typescript\n     * const a = new CPUTensor([2,2],[5,6,7,8]);\n     *\n     * a.slice([0],[1],[0]);\n     * //Will be\n     * // [[5,6]]\n     *\n     * a.slice([0],[1],[1]);\n     * //Will be\n     * // [[5],\n     *     [6]]\n     * ```\n     *\n     * @param starts Start of the slice for each axis\n     * @param ends End of the slice for each axis - Exclusive (the end index will not be included in the slice)\n     * @param axes Axes to slice. Defaults to all axes\n     */\n    Tensor.prototype.slice = function (starts, ends, axes) {\n        var shape = this.getShape();\n        var rank = shape.length;\n        if (axes === undefined) {\n            axes = [];\n            for (var i = 0; i < rank; i++) {\n                axes.push(i);\n            }\n        }\n        starts = __spreadArrays(starts);\n        ends = __spreadArrays(ends);\n        for (var i = 0; i < axes.length; i++) {\n            var sh = shape[axes[i]];\n            if (starts[i] < 0) {\n                starts[i] += sh;\n            }\n            else if (starts[i] >= sh) {\n                starts[i] = sh;\n            }\n            if (ends[i] < 0) {\n                ends[i] += sh;\n            }\n            else if (ends[i] >= sh) {\n                ends[i] = sh;\n            }\n        }\n        return this.slice_impl(starts, ends, axes);\n    };\n    return Tensor;\n}());\nexport default Tensor;\n//# sourceMappingURL=types.js.map","export function outputDimSize(inSize, kernel, headPad, tailPad, dilation, stride) {\n    var dkernel = dilation * (kernel - 1) + 1;\n    return Math.floor((inSize + headPad + tailPad - dkernel) / stride + 1);\n}\nexport function outputDimsSize(inSizes, kernels, headPads, tailPads, dilations, strides) {\n    var result = [];\n    for (var i = 0; i < inSizes.length; i++) {\n        result.push(outputDimSize(inSizes[i], kernels[i], headPads[i], tailPads[i], dilations[i], strides[i]));\n    }\n    return result;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { checkEquivShapes, incrementIndex } from '../../util/shape';\nexport function positionWiseUnaryOp(a, op) {\n    var result = new CPUTensor(a.shape);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(i, op(a.get(i)));\n    }\n    return result;\n}\nexport function positionWiseBinaryOp(a, b, op, resultShape) {\n    if (!checkEquivShapes(a.shape, b.shape)) {\n        throw new Error('The shapes of the two tensors should be the same for a binary operation');\n    }\n    var result = new CPUTensor(resultShape);\n    var index = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(index, op(a.get(index), b.get(index)));\n        incrementIndex(index, resultShape);\n    }\n    return result;\n}\nexport function exp(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.exp(o1); });\n}\nexport function log(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.log(o1); });\n}\nexport function sqrt(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.sqrt(o1); });\n}\nexport function abs(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.abs(o1); });\n}\nexport function floor(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.floor(o1); });\n}\nexport function ceil(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.ceil(o1); });\n}\nexport function sign(a) {\n    return positionWiseUnaryOp(a, function (o1) { return (o1 < 0 ? -1 : 1); });\n}\nexport function negate(a) {\n    return positionWiseUnaryOp(a, function (o1) { return -o1; });\n}\nexport function addMultiplyScalar(a, factor, add) {\n    return positionWiseUnaryOp(a, function (o1) { return o1 * factor + add; });\n}\nexport function sigmoid(a) {\n    return positionWiseUnaryOp(a, function (o1) { return 1 / (1 + Math.exp(-o1)); });\n}\nexport function clip(a, min, max) {\n    var f = function (o1) { return o1; };\n    if (min !== undefined && max !== undefined) {\n        f = function (o1) { return Math.min(max, Math.max(min, o1)); };\n    }\n    else if (max !== undefined) {\n        f = function (o1) { return Math.min(max, o1); };\n    }\n    else if (min !== undefined) {\n        f = function (o1) { return Math.max(min, o1); };\n    }\n    return positionWiseUnaryOp(a, f);\n}\nexport function add(a, b, resultShape, alpha, beta) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 * alpha + o2 * beta; }, resultShape);\n}\nexport function subtract(a, b, resultShape, alpha, beta) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 * alpha - o2 * beta; }, resultShape);\n}\nexport function multiply(a, b, resultShape, alpha) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 * o2 * alpha; }, resultShape);\n}\nexport function divide(a, b, resultShape, alpha) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return (o1 / o2) * alpha; }, resultShape);\n}\nexport function power(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return Math.pow(o1, o2); }, resultShape);\n}\nexport function clipBackward(value, grad, resultShape, min, max) {\n    return positionWiseBinaryOp(value, grad, function (v, g) {\n        if (min !== undefined && v < min) {\n            return 0;\n        }\n        if (max !== undefined && v > max) {\n            return 0;\n        }\n        return g;\n    }, resultShape);\n}\n//# sourceMappingURL=basic.js.map","export function outputDimSize(inSize, kernel, headPad, tailPad, dilation, stride) {\n    var kernelSize = dilation * (kernel - 1) + 1;\n    return stride * (inSize - 1) + headPad + tailPad - kernelSize + 2;\n}\nexport function outputDimsSize(inSizes, kernels, headPads, tailPads, dilations, strides) {\n    var result = [];\n    for (var i = 0; i < inSizes.length; i++) {\n        result.push(outputDimSize(inSizes[i], kernels[i], headPads[i], tailPads[i], dilations[i], strides[i]));\n    }\n    return result;\n}\n//# sourceMappingURL=convTranspose.js.map","export function poolResultShape(inputShape, axes, keepDims) {\n    var resultShape = [];\n    var sumShape = [];\n    var ixMap = [];\n    for (var i = 0; i < inputShape.length; i++) {\n        if (!axes.includes(i)) {\n            resultShape.push(inputShape[i]);\n            ixMap.push(i);\n        }\n        else {\n            if (keepDims) {\n                resultShape.push(1);\n                ixMap.push(i);\n            }\n            sumShape.push(inputShape[i]);\n        }\n    }\n    if (resultShape.length === 0) {\n        resultShape.push(1);\n    }\n    return [resultShape, ixMap];\n}\n//# sourceMappingURL=pool.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex, indexToPos, computeStrides, } from '../../util/shape';\nimport { poolResultShape } from '../util/pool';\nexport function pool(a, axes, operation, keepDims, postProcess) {\n    var inputShape = a.getShape();\n    var inputSize = getSize(inputShape);\n    var _a = poolResultShape(inputShape, axes, keepDims), resultShape = _a[0], ixMap = _a[1];\n    var resultSize = getSize(resultShape);\n    var resultStrides = computeStrides(resultShape);\n    var result = new CPUTensor(resultShape);\n    var initialized = new Array(resultSize).fill(false);\n    var index = new Array(inputShape.length).fill(0);\n    var outIndex = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < inputSize; i++) {\n        for (var j = 0; j < ixMap.length; j++) {\n            outIndex[j] = index[ixMap[j]];\n        }\n        var outOffset = indexToPos(outIndex, resultStrides);\n        if (initialized[outOffset]) {\n            result.set(outIndex, operation(a.get(i), result.get(outIndex)));\n        }\n        else {\n            initialized[outOffset] = true;\n            result.set(outIndex, operation(a.get(i)));\n        }\n        incrementIndex(index, inputShape);\n    }\n    if (postProcess) {\n        for (var i = 0; i < result.size; i++) {\n            result.set(i, postProcess(result.get(i)));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=pool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function pad(x, pads, mode, value) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] += pads[i] + pads[i + rank];\n    }\n    var Y = new CPUTensor(resultShape);\n    var ix = new Array(rank).fill(0);\n    var inputIx = new Array(rank).fill(0);\n    for (var i = 0; i < Y.size; i++) {\n        var allInRange = true;\n        for (var j = 0; j < rank; j++) {\n            inputIx[j] = ix[j] - pads[j];\n            if (inputIx[j] < 0 || inputIx[j] >= x.shape[j]) {\n                allInRange = false;\n            }\n        }\n        Y.set(i, getPadValue(x, inputIx, mode, value, allInRange));\n        incrementIndex(ix, resultShape);\n    }\n    return Y;\n}\nfunction getPadValue(x, index, mode, value, allInRange) {\n    if (allInRange) {\n        return x.get(index);\n    }\n    var rank = x.shape.length;\n    if (mode === 'constant') {\n        return value;\n    }\n    else if (mode === 'edge') {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = 0;\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = x.shape[j] - 1;\n            }\n        }\n    }\n    else {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = -index[j];\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = 2 * x.shape[j] - index[j] - 2;\n            }\n        }\n    }\n    return x.get(index);\n}\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { averagePool } from '../../ops/cpu/averagePool';\nimport { abs, add, addMultiplyScalar, ceil, clip, clipBackward, divide, exp, floor, log, multiply, negate, power, sigmoid, sign, sqrt, subtract, } from '../../ops/cpu/basic';\nimport { concat } from '../../ops/cpu/concat';\nimport { conv } from '../../ops/cpu/conv';\nimport { convTranspose } from '../../ops/cpu/convTranspose';\nimport { expand } from '../../ops/cpu/expand';\nimport { gather } from '../../ops/cpu/gather';\nimport { gemm } from '../../ops/cpu/gemm';\nimport { matMul } from '../../ops/cpu/matMul';\nimport { max } from '../../ops/cpu/max';\nimport { min } from '../../ops/cpu/min';\nimport { normalize } from '../../ops/cpu/normalize';\nimport { pad } from '../../ops/cpu/pad';\nimport { product } from '../../ops/cpu/product';\nimport { reduceMean } from '../../ops/cpu/reduceMean';\nimport { reduceMeanSquare } from '../../ops/cpu/reduceMeanSquare';\nimport { repeat } from '../../ops/cpu/repeat';\nimport { setValues } from '../../ops/cpu/setValues';\nimport { slice } from '../../ops/cpu/slice';\nimport { sum } from '../../ops/cpu/sum';\nimport { sumSquare } from '../../ops/cpu/sumSquare';\nimport { transpose } from '../../ops/cpu/transpose';\nimport { upsample } from '../../ops/cpu/upsample';\nimport Tensor from '../../types';\nimport { compareShapes, computeStrides, getSize, indexToPos, } from '../../util/shape';\nvar CPUTensor = /** @class */ (function (_super) {\n    __extends(CPUTensor, _super);\n    function CPUTensor(shape, values, type) {\n        var _this = _super.call(this) || this;\n        _this.deleted = false;\n        _this.shape = shape;\n        _this.strides = computeStrides(shape);\n        _this.size = getSize(shape);\n        if (values !== undefined) {\n            if (values instanceof Float32Array || values instanceof Int32Array) {\n                _this.values = values;\n                _this.type = values instanceof Float32Array ? 'float' : 'int';\n            }\n            else if (type === 'int') {\n                _this.values = Int32Array.from(values);\n                _this.type = 'int';\n            }\n            else {\n                _this.values = Float32Array.from(values);\n                _this.type = 'float';\n            }\n        }\n        else {\n            if (type === 'int') {\n                _this.values = new Int32Array(_this.size);\n                _this.type = 'int';\n            }\n            else {\n                _this.values = new Float32Array(_this.size);\n                _this.type = 'float';\n            }\n        }\n        _this.type = 'float';\n        return _this;\n    }\n    CPUTensor.prototype.getValues = function () {\n        return Promise.resolve(this.values);\n    };\n    CPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    CPUTensor.prototype.constantLike = function (value) {\n        return new CPUTensor(this.shape, new Float32Array(this.size).fill(value));\n    };\n    CPUTensor.prototype.singleConstant = function (value) {\n        return new CPUTensor([1], [value]);\n    };\n    CPUTensor.prototype.cpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    CPUTensor.prototype.delete = function () {\n        //@ts-ignore\n        this.values = undefined;\n        this.deleted = true;\n    };\n    CPUTensor.prototype.copy = function (newShape) {\n        if (newShape === undefined) {\n            newShape = __spreadArrays(this.shape);\n        }\n        var values = new Float32Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            values[i] = this.values[i];\n        }\n        return new CPUTensor(newShape, values);\n    };\n    CPUTensor.prototype.get = function (index) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides, this.shape);\n        }\n        else {\n            pos = index;\n        }\n        return this.values[pos];\n    };\n    CPUTensor.prototype.set = function (index, value) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides);\n        }\n        else {\n            pos = index;\n        }\n        this.values[pos] = value;\n    };\n    CPUTensor.prototype.setValues = function (values, starts) {\n        if (!(values instanceof CPUTensor)) {\n            throw new Error('Can only set CPU values to CPU values');\n        }\n        return setValues(this, values, starts);\n    };\n    CPUTensor.prototype.exp = function () {\n        return exp(this);\n    };\n    CPUTensor.prototype.log = function () {\n        return log(this);\n    };\n    CPUTensor.prototype.sqrt = function () {\n        return sqrt(this);\n    };\n    CPUTensor.prototype.abs = function () {\n        return abs(this);\n    };\n    CPUTensor.prototype.floor = function () {\n        return floor(this);\n    };\n    CPUTensor.prototype.ceil = function () {\n        return ceil(this);\n    };\n    CPUTensor.prototype.negate = function () {\n        return negate(this);\n    };\n    CPUTensor.prototype.multiplyScalar = function (value) {\n        return addMultiplyScalar(this, value, 0);\n    };\n    CPUTensor.prototype.addScalar = function (value) {\n        return addMultiplyScalar(this, 1, value);\n    };\n    CPUTensor.prototype.addMultiplyScalar = function (factor, add) {\n        return addMultiplyScalar(this, factor, add);\n    };\n    CPUTensor.prototype.sign = function () {\n        return sign(this);\n    };\n    CPUTensor.prototype.clip = function (min, max) {\n        return clip(this, min, max);\n    };\n    CPUTensor.prototype.clipBackward = function (grad, min, max) {\n        if (!(grad instanceof CPUTensor)) {\n            throw new Error('Can only do clipBackward with CPUTensor');\n        }\n        return clipBackward(this, grad, this.getShape(), min, max);\n    };\n    CPUTensor.prototype.sigmoid = function () {\n        return sigmoid(this);\n    };\n    CPUTensor.prototype.add_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return add(th, tensor, resultShape, alpha, beta);\n    };\n    CPUTensor.prototype.subtract_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only subtract CPU tensor to CPU tensor');\n        }\n        return subtract(th, tensor, resultShape, alpha, beta);\n    };\n    CPUTensor.prototype.multiply_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return multiply(th, tensor, resultShape, alpha);\n    };\n    CPUTensor.prototype.divide_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return divide(th, tensor, resultShape, alpha);\n    };\n    CPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only take CPU tensor to power of CPU tensor');\n        }\n        return power(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return matMul(this, tensor);\n    };\n    CPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof CPUTensor && (c === undefined || c instanceof CPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        return gemm(this, b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    CPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return sum(this, axes, keepDims);\n    };\n    CPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return sumSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return product(this, axes, keepDims);\n    };\n    CPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return max(this, axes, keepDims);\n    };\n    CPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return min(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return reduceMean(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return reduceMeanSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, activation, bias) {\n        if (!(kernel instanceof CPUTensor) ||\n            (bias !== undefined && !(bias instanceof CPUTensor))) {\n            throw new Error('Can only do convolution of CPU tensor with CPU tensor');\n        }\n        return conv(this, kernel, dilations, group, pads, strides, activation, bias);\n    };\n    CPUTensor.prototype.convTranspose_impl = function (kernel, dilations, group, pads, strides) {\n        if (!(kernel instanceof CPUTensor)) {\n            throw new Error('Can only do transpose convolution of CPU tensor with CPU tensor');\n        }\n        return convTranspose(this, kernel, dilations, group, pads, strides);\n    };\n    CPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return pad(this, pads, mode, value);\n    };\n    CPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return averagePool(this, kernelShape, pads, strides, includePad);\n    };\n    CPUTensor.prototype.reshape_impl = function (shape, copy) {\n        if (copy) {\n            return this.copy(shape);\n        }\n        else {\n            return new CPUTensor(shape, this.values, this.type);\n        }\n    };\n    CPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only concat CPU tensor to CPU tensor');\n        }\n        return concat(this, tensor, axis);\n    };\n    CPUTensor.prototype.transpose_impl = function (permutation) {\n        return transpose(this, permutation);\n    };\n    CPUTensor.prototype.repeat = function (repeats) {\n        return repeat(this, repeats);\n    };\n    CPUTensor.prototype.expand = function (shape) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return expand(this.reshape(_shape, false), resultShape);\n    };\n    CPUTensor.prototype.gather = function (axis, indices) {\n        return gather(this, axis, indices);\n    };\n    CPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return slice(this, starts, ends, axes);\n    };\n    CPUTensor.prototype.upsample = function (scales) {\n        return upsample(this, scales);\n    };\n    CPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof CPUTensor) ||\n            !(variance instanceof CPUTensor) ||\n            !(scale instanceof CPUTensor) ||\n            !(bias instanceof CPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return normalize(this, mean, variance, epsilon, scale, bias);\n    };\n    return CPUTensor;\n}(Tensor));\nexport { CPUTensor };\n//# sourceMappingURL=tensor.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function setValues(a, b, starts) {\n    var result = new CPUTensor(a.shape);\n    var index = new Array(a.shape.length).fill(0);\n    for (var i = 0; i < result.size; i += 1) {\n        var inB = true;\n        var bIx = new Array(starts.length).fill(0);\n        for (var j = 0; j < starts.length; j++) {\n            if (index[j] < starts[j] || index[j] >= starts[j] + b.shape[j]) {\n                inB = false;\n                break;\n            }\n            else {\n                bIx[j] = index[j] - starts[j];\n            }\n        }\n        if (inB) {\n            result.set(i, b.get(bIx));\n        }\n        else {\n            result.set(i, a.get(i));\n        }\n        incrementIndex(index, a.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=setValues.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nexport function matMul(a, b) {\n    if (a.shape.length !== 2 || b.shape.length !== 2) {\n        throw new Error('Matmul expects both operands to have rank 2');\n    }\n    if (a.shape[1] !== b.shape[0]) {\n        throw new Error('Matmul expects dimension 1 of operand 1 to equal dimension 0 of operand 2');\n    }\n    var m = a.shape[0];\n    var n = a.shape[1];\n    var o = b.shape[1];\n    var result = new CPUTensor([m, o]);\n    for (var i = 0; i < m; i += 1) {\n        for (var k = 0; k < o; k += 1) {\n            var res = 0;\n            for (var j = 0; j < n; j += 1) {\n                res += a.get([i, j]) * b.get([j, k]);\n            }\n            result.set([i, k], res);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=matMul.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize } from '../../util/shape';\nexport function gemm(a, b, aTranspose, bTranspose, alpha, beta, c) {\n    var rank = a.shape.length;\n    var M = aTranspose ? a.shape[rank - 1] : a.shape[rank - 2];\n    var N = aTranspose ? a.shape[rank - 2] : a.shape[rank - 1];\n    var O = bTranspose ? b.shape[rank - 2] : b.shape[rank - 1];\n    var aBatchMult = M * N;\n    var bBatchMult = N * O;\n    var yBatchMult = M * O;\n    var aNMult = aTranspose ? M : 1;\n    var aMMult = aTranspose ? 1 : N;\n    var bNMult = bTranspose ? 1 : O;\n    var bOMult = bTranspose ? N : 1;\n    var cMMult = 0;\n    var cOMult = 0;\n    var cBatchMult = 0;\n    if (c !== undefined) {\n        cMMult = c.strides[rank - 2];\n        cOMult = c.strides[rank - 1];\n        var cBatchSize = getSize(c.shape.slice(0, rank - 2));\n        if (cBatchSize > 1) {\n            cBatchMult = c.shape[rank - 2] * c.shape[rank - 1];\n            if (cBatchMult === 1) {\n                cBatchMult = 0;\n            }\n        }\n        else {\n            cBatchMult = 0;\n        }\n    }\n    var batchShape = a.shape.slice(0, rank - 2);\n    var batchSize = getSize(batchShape);\n    if (batchSize === 0) {\n        batchSize = 1;\n    }\n    var resultShape = __spreadArrays(batchShape, [M, O]);\n    var Y = new CPUTensor(resultShape);\n    for (var i = 0; i < batchSize; i++) {\n        var aBase = i * aBatchMult;\n        var bBase = i * bBatchMult;\n        var yBase = i * yBatchMult;\n        var cBase = i * cBatchMult;\n        for (var m = 0; m < M; m++) {\n            for (var o = 0; o < O; o++) {\n                var result = 0;\n                for (var n = 0; n < N; n++) {\n                    result +=\n                        a.get(aBase + m * aMMult + n * aNMult) *\n                            b.get(bBase + n * bNMult + o * bOMult);\n                }\n                result = alpha * result;\n                if (c !== undefined) {\n                    result += beta * c.get(cBase + m * cMMult + o * cOMult);\n                }\n                Y.set(yBase + m * O + o, result);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=gemm.js.map","import { pool } from './pool';\nexport function sum(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sum.js.map","import { pool } from './pool';\nexport function sumSquare(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a * a + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sumSquare.js.map","import { pool } from './pool';\nexport function product(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a * (b !== undefined ? b : 1);\n    }, keepDims);\n}\n//# sourceMappingURL=product.js.map","import { pool } from './pool';\nexport function max(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.max(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=max.js.map","import { pool } from './pool';\nexport function min(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.min(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=min.js.map","import { pool } from './pool';\nexport function reduceMean(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMean.js.map","import { pool } from './pool';\nexport function reduceMeanSquare(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return a * a + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMeanSquare.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function conv(x, w, dilations, group, pads, strides, activation, bias) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var W = w.shape.slice(2);\n    var M = w.shape[0];\n    var CG = C / group;\n    var kernelSize = getSize(W);\n    var R = outputDimsSize(D, W, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), dilations, strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, M];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    var dataRank = R.length;\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var m = 0; m < M; m++) {\n            if (bias) {\n                var b = bias ? bias.get([m]) : 0;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    Y.set(outputIndices, b);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n            for (var cg = 0; cg < CG; cg++) {\n                var c = (m * CG + cg) % C;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    var result = Y.get(outputIndices);\n                    var kernelIndices = new Array(R.length).fill(0);\n                    kernelIndices.unshift(m, cg);\n                    for (var kIx = 0; kIx < kernelSize; kIx++) {\n                        var inputIx = [n, c];\n                        var skip = false;\n                        for (var axis = 0; axis < dataRank; axis++) {\n                            var stride = strides.length === 0 ? 1 : strides[axis];\n                            var pad = pads.length === 0 ? 0 : pads[axis];\n                            var dilation = dilations.length === 0 ? 1 : dilations[axis];\n                            var ix = outputIndices[axis + 2] * stride -\n                                pad +\n                                kernelIndices[axis + 2] * dilation;\n                            if (ix < 0 || ix >= D[axis]) {\n                                skip = true;\n                                break;\n                            }\n                            inputIx.push(ix);\n                        }\n                        if (!skip) {\n                            var Wi = w.get(kernelIndices);\n                            var Xi = x.get(inputIx);\n                            result += Wi * Xi;\n                        }\n                        incrementIndex(kernelIndices, w.shape);\n                    }\n                    Y.set(outputIndices, result);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n            if (activation !== 'id') {\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    var result = Y.get(outputIndices);\n                    if (activation === 'relu') {\n                        result = Math.max(0, result);\n                    }\n                    else if (activation === 'relu6') {\n                        result = Math.min(Math.max(0, result), 6);\n                    }\n                    Y.set(outputIndices, result);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/convTranspose';\nexport function convTranspose(x, w, dilations, group, pads, strides) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var W = w.shape.slice(2);\n    var M = w.shape[0];\n    var CG = C / group;\n    var kernelSize = getSize(W);\n    var R = outputDimsSize(D, W, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), dilations, strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, M];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    var dataRank = R.length;\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var m = 0; m < M; m++) {\n            for (var cg = 0; cg < CG; cg++) {\n                var c = (m * CG + cg) % C;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    var result = Y.get(outputIndices);\n                    var kernelIndices = new Array(R.length).fill(0);\n                    kernelIndices.unshift(m, cg);\n                    for (var kIx = 0; kIx < kernelSize; kIx++) {\n                        var inputIx = [n, c];\n                        var skip = false;\n                        for (var axis = 0; axis < dataRank; axis++) {\n                            var stride = strides.length === 0 ? 1 : strides[axis];\n                            var pad = pads.length === 0 ? 0 : pads[axis];\n                            var dilation = dilations.length === 0 ? 1 : dilations[axis];\n                            var ix = outputIndices[axis + 2] -\n                                pad +\n                                kernelIndices[axis + 2] * dilation;\n                            var res = ix % stride;\n                            if (res !== 0) {\n                                skip = true;\n                                break;\n                            }\n                            ix = ix / stride;\n                            if (ix < 0 || ix >= D[axis]) {\n                                skip = true;\n                                break;\n                            }\n                            inputIx.push(ix);\n                        }\n                        if (!skip) {\n                            var transposedKernelIx = [m, cg];\n                            for (var i = 0; i < dataRank; i++) {\n                                transposedKernelIx.push(W[i] - kernelIndices[i + 2] - 1);\n                            }\n                            var Wi = w.get(transposedKernelIx);\n                            var Xi = x.get(inputIx);\n                            result += Wi * Xi;\n                        }\n                        incrementIndex(kernelIndices, w.shape);\n                    }\n                    Y.set(outputIndices, result);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=convTranspose.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function averagePool(x, kernelShape, pads, strides, includePad) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var dataRank = D.length;\n    var kernelSize = getSize(kernelShape);\n    var R = outputDimsSize(D, kernelShape, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), new Array(dataRank).fill(1), strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, C];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var c = 0; c < C; c++) {\n            var outputIndices = new Array(R.length).fill(0);\n            outputIndices.unshift(n, c);\n            for (var oIx = 0; oIx < outputSize; oIx++) {\n                var result = 0;\n                var kernelIndices = new Array(R.length).fill(0);\n                var count = 0;\n                for (var kIx = 0; kIx < kernelSize; kIx++) {\n                    var inputIx = [n, c];\n                    var skip = false;\n                    for (var axis = 0; axis < dataRank; axis++) {\n                        var stride = strides.length === 0 ? 1 : strides[axis];\n                        var pad = pads.length === 0 ? 0 : pads[axis];\n                        var ix = outputIndices[axis + 2] * stride - pad + kernelIndices[axis];\n                        if (ix < 0 || ix >= D[axis]) {\n                            skip = true;\n                            break;\n                        }\n                        inputIx.push(ix);\n                    }\n                    if (!skip) {\n                        var Xi = x.get(inputIx);\n                        result += Xi;\n                    }\n                    if (!skip || includePad) {\n                        count += 1;\n                    }\n                    incrementIndex(kernelIndices, kernelShape);\n                }\n                result = result / count;\n                Y.set(outputIndices, result);\n                incrementIndex(outputIndices, Y.shape);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=averagePool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nexport function concat(x, y, axis) {\n    var outputShape = __spreadArrays(x.shape);\n    outputShape[axis] += y.shape[axis];\n    var result = new CPUTensor(outputShape);\n    var indexX = 0;\n    var indexY = 0;\n    var ix = 0;\n    var iterXSize = result.strides[axis] * x.shape[axis];\n    var iterYSize = result.strides[axis] * y.shape[axis];\n    var outerIters = result.size / (axis > 0 ? result.strides[axis - 1] : result.size);\n    for (var i = 0; i < outerIters; i++) {\n        for (var j = 0; j < iterXSize; j++) {\n            result.set(ix, x.get(indexX));\n            ix++;\n            indexX++;\n        }\n        for (var j = 0; j < iterYSize; j++) {\n            result.set(ix, y.get(indexY));\n            ix++;\n            indexY++;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=concat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function transpose(x, permutation) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    var reversePerm = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[permutation[i]];\n        reversePerm[permutation[i]] = i;\n    }\n    var result = new CPUTensor(outputShape);\n    var resultStrides = result.strides;\n    var mappedStrides = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        mappedStrides[i] = resultStrides[reversePerm[i]];\n    }\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < x.size; i++) {\n        var outIx = 0;\n        for (var j = 0; j < rank; j++) {\n            outIx += index[j] * mappedStrides[j];\n        }\n        result.set(outIx, x.get(i));\n        incrementIndex(index, x.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=transpose.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function repeat(x, repeats) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[i] * repeats[i];\n    }\n    var result = new CPUTensor(outputShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var inIndex = new Array(rank);\n        for (var j = 0; j < rank; j++) {\n            inIndex[j] = index[j] % x.shape[j];\n        }\n        result.set(i, x.get(inIndex));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=repeat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function expand(x, resultShape) {\n    var rank = x.shape.length;\n    var result = new CPUTensor(resultShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        result.set(i, x.get(index));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=expand.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function gather(x, axis, indices) {\n    var r = x.shape.length;\n    var q = indices.shape.length;\n    var resultRank = r + q - 1;\n    var resultShape = new Array(resultRank);\n    for (var i = 0; i < axis; i++) {\n        resultShape[i] = x.shape[i];\n    }\n    for (var i = 0; i < q; i++) {\n        resultShape[i + axis] = indices.shape[i];\n    }\n    for (var i = axis + 1; i < r; i++) {\n        resultShape[i + q - 1] = x.shape[i];\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(resultRank).fill(0);\n    var gatherIx;\n    var inputIx;\n    for (var i = 0; i < result.size; i++) {\n        gatherIx = outIx.slice(axis, axis + q);\n        var axIx = indices.get(gatherIx);\n        inputIx = __spreadArrays(outIx.slice(0, axis), [axIx], outIx.slice(axis + q));\n        result.set(i, x.get(inputIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=gather.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function slice(x, starts, ends, axis) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var axIx = 0;\n    for (var i = 0; i < rank && axIx < axis.length; i++) {\n        if (i === axis[axIx]) {\n            resultShape[i] = ends[axIx] - starts[axIx];\n            axIx++;\n        }\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx;\n    for (var i = 0; i < result.size; i++) {\n        inIx = __spreadArrays(outIx);\n        for (var j = 0; j < axis.length; j++) {\n            inIx[axis[j]] += starts[j];\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=slice.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function upsample(x, scales) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] = Math.floor(resultShape[i] * scales[i]);\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx = new Array(rank);\n    for (var i = 0; i < result.size; i++) {\n        for (var j = 0; j < rank; j++) {\n            inIx[j] = Math.floor(outIx[j] / scales[j]);\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=upsample.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function normalize(x, mean, variance, epsilon, scale, bias) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var res = (x.get(outIx) - mean.get(outIx)) /\n            Math.sqrt(variance.get(outIx) + epsilon);\n        res = res * scale.get(outIx) + bias.get(outIx);\n        result.set(i, res);\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=normalize.js.map","var Dict = /** @class */ (function () {\n    function Dict(toNumber) {\n        this.toNumber = toNumber;\n        this.numEntries = 0;\n        this.dict = {};\n    }\n    Dict.prototype.betweenBoundsFirst = function (query) {\n        if (query.gte !== undefined) {\n            var k = this.toNumber(query.gte);\n            if (this.dict[k] !== undefined && this.dict[k].length > 0) {\n                return [\n                    {\n                        key: query.gte,\n                        value: this.dict[k][this.dict[k].length - 1],\n                    },\n                ];\n            }\n            return [];\n        }\n        else if (query.lte !== undefined) {\n            var k = this.toNumber(query.lte);\n            if (this.dict[k] !== undefined && this.dict[k].length > 0) {\n                return [\n                    {\n                        key: query.lte,\n                        value: this.dict[k][this.dict[k].length - 1],\n                    },\n                ];\n            }\n            return [];\n        }\n        return [];\n    };\n    Dict.prototype.deleteFirst = function (key) {\n        var k = this.toNumber(key);\n        if (this.dict[k] !== undefined) {\n            this.dict[k].pop();\n            this.numEntries--;\n        }\n    };\n    Dict.prototype.insert = function (key, value) {\n        var k = this.toNumber(key);\n        if (this.dict[k] === undefined) {\n            this.dict[k] = [];\n        }\n        this.dict[k].push(value);\n        this.numEntries++;\n    };\n    return Dict;\n}());\nexport { Dict };\n//# sourceMappingURL=dict.js.map","export function primeFactors(num) {\n    return primeFactorsCompute(num);\n}\nexport function primeFactorsCompute(inputNum, result, repeat) {\n    if (result === void 0) { result = []; }\n    if (repeat === void 0) { repeat = true; }\n    if (!Number.isInteger(inputNum))\n        return result;\n    var num = Math.abs(inputNum);\n    if (num < 2)\n        return result;\n    var sqrt = Math.sqrt(num);\n    var x = 2;\n    if (num % x) {\n        x = 3;\n        if (num % x) {\n            x = 5;\n            var add = 2;\n            while (num % x && x < sqrt) {\n                // search numbers: 5, 7, 11, 13, 17, 19, 23...\n                x += add;\n                // add each time: 2, 4, 2, 4, 2, 4, 2...\n                add = 6 - add;\n            }\n        }\n    }\n    x = x <= sqrt ? x : num;\n    if (!repeat) {\n        var index = result.indexOf(x);\n        if (index < 0)\n            result.push(x);\n    }\n    else\n        result.push(x);\n    return x === num ? result : primeFactorsCompute(num / x, result, repeat);\n}\n/**\n * Generate two normally distributed values using the box-muller transform\n */\nexport function boxMuller() {\n    var u1 = 0;\n    var u2 = 0;\n    while (u1 === 0)\n        u1 = Math.random();\n    while (u2 === 0)\n        u2 = Math.random();\n    var z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    var z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);\n    return [z0, z1];\n}\n/**\n * Generates n normally distributed values using the Box-Muller transform\n * @param n Number of values to generate\n * @param mean Mean of the normal distribution, defaults to 0\n * @param variance Variance of the normal distribution, defaults to 1\n */\nexport function normal(n, mean, variance) {\n    if (mean === void 0) { mean = 0; }\n    if (variance === void 0) { variance = 1; }\n    var result = [];\n    for (var i = 0; i < n; i += 2) {\n        var _a = boxMuller(), z0 = _a[0], z1 = _a[1];\n        result.push(z0 * variance + mean);\n        if (i < n - 1) {\n            result.push(z1 * variance + mean);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=math.js.map","import { primeFactors } from '../../util/math';\nvar GPUMemoryAllocator = /** @class */ (function () {\n    function GPUMemoryAllocator(regl, orderedDictConstructor, maxSizeFactor) {\n        this.totalAllocations = 0;\n        this.trees = {\n            16: orderedDictConstructor(),\n            32: orderedDictConstructor(),\n        };\n        this.regl = regl;\n        this.entryId = 0;\n        this.maxSizeFactor = maxSizeFactor || 2;\n    }\n    GPUMemoryAllocator.prototype.allocate = function (size, precision) {\n        var upperBound = size * this.maxSizeFactor;\n        var texSize = Math.ceil(size / 4) * 4;\n        if (texSize < upperBound) {\n            upperBound = texSize;\n        }\n        var results = this.trees[precision].betweenBoundsFirst({\n            gte: texSize,\n            lte: upperBound,\n        });\n        if (results.length === 0) {\n            var textureSize = Math.ceil(size / 4);\n            var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n            var framebuffer = this.regl.framebuffer({\n                width: width,\n                height: height,\n                depthStencil: false,\n                colorFormat: 'rgba',\n                colorType: precision === 32 ? 'float' : 'half float',\n            });\n            var memoryEntry = {\n                width: width,\n                height: height,\n                size: width * height * 4,\n                frameBuffer: framebuffer,\n                id: this.entryId++,\n                precision: precision,\n            };\n            this.totalAllocations++;\n            return memoryEntry;\n        }\n        else {\n            var first = results[0];\n            this.trees[precision].deleteFirst(first.key);\n            return first.value;\n        }\n    };\n    GPUMemoryAllocator.prototype.getAllocationDimensions = function (size, precision) {\n        var upperBound = size * this.maxSizeFactor;\n        var texSize = Math.ceil(size / 4) * 4;\n        if (texSize < upperBound) {\n            upperBound = texSize;\n        }\n        var results = this.trees[precision].betweenBoundsFirst({\n            gte: size,\n            lte: upperBound,\n        });\n        if (results.length === 0) {\n            var textureSize = Math.ceil(size / 4);\n            return this.getTextureDims(textureSize);\n        }\n        else {\n            var first = results[0];\n            return {\n                width: first.value.width,\n                height: first.value.height,\n            };\n        }\n    };\n    GPUMemoryAllocator.prototype.deallocate = function (entry) {\n        this.trees[entry.precision].insert(entry.size, entry);\n    };\n    GPUMemoryAllocator.prototype.allocateTexture = function (values, precision) {\n        var textureSize = Math.ceil(values.length / 4);\n        var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n        var arraySize = width * height * 4;\n        var vals = new Float32Array(arraySize);\n        for (var i = 0; i < values.length; i++) {\n            vals[i] = values[i];\n        }\n        for (var i = values.length; i < arraySize; i++) {\n            vals[i] = 0;\n        }\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: precision === 32 ? 'float' : 'half float',\n            data: precision === 32 ? vals : Array.from(vals),\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false,\n        });\n        this.totalAllocations++;\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision,\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateOfDimensions = function (width, height, precision) {\n        var arraySize = width * height * 4;\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: precision === 32 ? 'float' : 'half float',\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false,\n        });\n        this.totalAllocations++;\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision,\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateFramebuffer = function (texture, precision) {\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: texture.width,\n            height: texture.height,\n            depthStencil: false,\n        });\n        this.totalAllocations++;\n        return {\n            width: texture.width,\n            height: texture.height,\n            size: texture.width * texture.height * 4,\n            frameBuffer: framebuffer,\n            id: this.entryId++,\n            precision: precision,\n        };\n    };\n    GPUMemoryAllocator.prototype.getTextureDims = function (size) {\n        var factors = primeFactors(size);\n        var width = 1;\n        var height = 1;\n        for (var i = 0; i < factors.length; i += 2) {\n            width *= factors[i];\n            if (i + 1 < factors.length) {\n                height *= factors[i + 1];\n            }\n        }\n        return { width: width, height: height };\n    };\n    GPUMemoryAllocator.prototype.getNumEntries = function () {\n        return this.trees[16].numEntries + this.trees[32].numEntries;\n    };\n    return GPUMemoryAllocator;\n}());\nexport { GPUMemoryAllocator };\n//# sourceMappingURL=memory.js.map","import REGL from 'regl';\nimport { Dict } from '../../util/datastructs/dict';\nimport { GPUMemoryAllocator } from './memory';\nvar canvas = document.createElement('canvas');\nexport var glContext;\nexport var gl;\nexport var defaultAllocator;\nfunction setup() {\n    //@ts-ignore\n    glContext = canvas.getContext('webgl', {\n        failIfMajorPerformanceCaveat: false,\n    });\n    gl = REGL({\n        gl: glContext,\n        extensions: [\n            'OES_texture_float',\n            'WEBGL_color_buffer_float',\n            'OES_texture_half_float',\n        ],\n    });\n    defaultAllocator = new GPUMemoryAllocator(gl, function () {\n        return new Dict(function (key) { return key; });\n    });\n}\nsetup();\n//# sourceMappingURL=gl.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes } from '../../util/shape';\nvar WASMT;\nexport var wasmLoaded = new Promise(function (resolve) {\n    import('../../wasm/rust_wasm_tensor').then(function (x) {\n        WASMT = x.Tensor;\n        resolve();\n    });\n});\nvar WASMTensor = /** @class */ (function (_super) {\n    __extends(WASMTensor, _super);\n    function WASMTensor(values, shape) {\n        var _this = _super.call(this) || this;\n        if (values instanceof Float32Array) {\n            if (shape === undefined) {\n                throw new Error('Need the shape when creating a Wasm tensor from values');\n            }\n            _this.wasmTensor = WASMT.create(shape, values);\n        }\n        else {\n            _this.wasmTensor = values;\n        }\n        return _this;\n    }\n    WASMTensor.prototype.getValues = function () {\n        return Promise.resolve(this.wasmTensor.get_vals());\n    };\n    WASMTensor.prototype.getShape = function () {\n        return Array.from(this.wasmTensor.get_shape());\n    };\n    WASMTensor.prototype.constantLike = function (value) {\n        // TODO: Maybe more efficient in WASM?\n        return new WASMTensor(new Float32Array(this.wasmTensor.size).fill(value), this.wasmTensor.get_shape());\n    };\n    WASMTensor.prototype.singleConstant = function (value) {\n        return new WASMTensor(new Float32Array([value]), new Uint32Array([1]));\n    };\n    WASMTensor.prototype.wasm = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    WASMTensor.prototype.delete = function () {\n        if (this.wasmTensor !== undefined) {\n            this.wasmTensor.free();\n            //@ts-ignore\n            this.wasmTensor = undefined;\n        }\n    };\n    WASMTensor.prototype.copy = function () {\n        return new WASMTensor(this.wasmTensor.copy());\n    };\n    WASMTensor.prototype.exp = function () {\n        return new WASMTensor(this.wasmTensor.exp());\n    };\n    WASMTensor.prototype.log = function () {\n        return new WASMTensor(this.wasmTensor.log());\n    };\n    WASMTensor.prototype.sqrt = function () {\n        return new WASMTensor(this.wasmTensor.sqrt());\n    };\n    WASMTensor.prototype.abs = function () {\n        return new WASMTensor(this.wasmTensor.abs());\n    };\n    WASMTensor.prototype.sigmoid = function () {\n        return new WASMTensor(this.wasmTensor.sigmoid());\n    };\n    WASMTensor.prototype.negate = function () {\n        return new WASMTensor(this.wasmTensor.negate());\n    };\n    WASMTensor.prototype.addMultiplyScalar = function (factor, add) {\n        return new WASMTensor(this.wasmTensor.add_multiply_scalar(factor, add));\n    };\n    WASMTensor.prototype.sign = function () {\n        return new WASMTensor(this.wasmTensor.sign());\n    };\n    WASMTensor.prototype.setValues = function (values, starts) {\n        if (!(values instanceof WASMTensor)) {\n            throw new Error('Can only set WASM values to WASM values');\n        }\n        return new WASMTensor(this.wasmTensor.set_values(values.wasmTensor, new Uint32Array(starts)));\n    };\n    WASMTensor.prototype.add_impl = function (th, tensor, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _resultShape, alpha, beta) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.addition(tensor.wasmTensor, alpha, beta));\n    };\n    WASMTensor.prototype.subtract_impl = function (th, tensor, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    resultShape, alpha, beta) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only subtract WASM tensor from WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.subtraction(tensor.wasmTensor, alpha, beta));\n    };\n    WASMTensor.prototype.multiply_impl = function (th, tensor, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    resultShape, alpha) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only multiply WASM tensor with WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.multiply(tensor.wasmTensor, alpha));\n    };\n    WASMTensor.prototype.divide_impl = function (th, tensor, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    resultShape, alpha) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only divide WASM tensor by WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.divide(tensor.wasmTensor, alpha));\n    };\n    WASMTensor.prototype.power_impl = function (th, tensor, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only take WASM tensor to power of WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.power(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.matmul(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof WASMTensor && (c === undefined || c instanceof WASMTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        if (c !== undefined) {\n            return new WASMTensor(this.wasmTensor.gemm_with_c(b.wasmTensor, aTranspose, bTranspose, alpha, c.wasmTensor, beta));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.gemm(b.wasmTensor, aTranspose, bTranspose, alpha));\n        }\n    };\n    WASMTensor.prototype.sum_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.product_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.product(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.max_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.max(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.min_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.min(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.getActivationFlag = function (activation) {\n        if (activation === 'id') {\n            return 0;\n        }\n        else if (activation === 'relu') {\n            return 1;\n        }\n        else {\n            return 2;\n        }\n    };\n    WASMTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, activation, bias) {\n        if (!(kernel instanceof WASMTensor) ||\n            (bias !== undefined && !(bias instanceof WASMTensor))) {\n            throw new Error('Can only do convolution of WASM tensor with WASM tensor');\n        }\n        var activationFlag = this.getActivationFlag(activation);\n        if (bias !== undefined) {\n            return new WASMTensor(this.wasmTensor.conv_with_bias(kernel.wasmTensor, bias.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides), activationFlag));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.conv(kernel.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides), activationFlag));\n        }\n    };\n    WASMTensor.prototype.convTranspose_impl = function (kernel, dilations, group, pads, strides) {\n        if (!(kernel instanceof WASMTensor)) {\n            throw new Error('Can only do transpose convolution of WASM tensor with WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.conv_transpose(kernel.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides)));\n    };\n    WASMTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return new WASMTensor(this.wasmTensor.average_pool(new Uint32Array(kernelShape), new Uint32Array(pads), new Uint32Array(strides), includePad));\n    };\n    WASMTensor.prototype.reshape_impl = function (shape) {\n        var sh = new Uint32Array(shape);\n        return new WASMTensor(this.wasmTensor.reshape(sh), sh);\n    };\n    WASMTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only concat WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.concat(tensor.wasmTensor, axis));\n    };\n    WASMTensor.prototype.transpose_impl = function (permutation) {\n        return new WASMTensor(this.wasmTensor.transpose(new Uint32Array(permutation)));\n    };\n    WASMTensor.prototype.clip = function (min, max) {\n        if (min !== undefined && max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip(min, max));\n        }\n        else if (min !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_min(min));\n        }\n        else if (max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_max(max));\n        }\n        return this.copy();\n    };\n    WASMTensor.prototype.clipBackward = function (grad, min, max) {\n        if (!(grad instanceof WASMTensor)) {\n            throw new Error('Can only do grad backward with Wasm tensor');\n        }\n        if (min !== undefined && max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_backward(min, max, grad.wasmTensor));\n        }\n        else if (min !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_min_backward(min, grad.wasmTensor));\n        }\n        else if (max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_max_backward(max, grad.wasmTensor));\n        }\n        return this.copy();\n    };\n    WASMTensor.prototype.repeat = function (repeats) {\n        return new WASMTensor(this.wasmTensor.repeat(new Uint32Array(repeats)));\n    };\n    WASMTensor.prototype.expand = function (shape) {\n        var thisShape = this.getShape();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _a = this.alignShapes(thisShape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(thisShape, resultShape)) {\n            return this.copy();\n        }\n        var reshaped = this.reshape(_shape, false);\n        return new WASMTensor(reshaped.wasmTensor.expand(new Uint32Array(resultShape)));\n    };\n    WASMTensor.prototype.pad_impl = function (pads, mode, value) {\n        return new WASMTensor(this.wasmTensor.pad(new Uint32Array(pads), WASMTensor.padModeToInt[mode], value));\n    };\n    WASMTensor.prototype.gather = function (axis, indices) {\n        return new WASMTensor(this.wasmTensor.gather(axis, indices.values, new Uint32Array(indices.shape)));\n    };\n    WASMTensor.prototype.floor = function () {\n        return new WASMTensor(this.wasmTensor.floor());\n    };\n    WASMTensor.prototype.ceil = function () {\n        return new WASMTensor(this.wasmTensor.ceil());\n    };\n    WASMTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return new WASMTensor(this.wasmTensor.slice(new Uint32Array(starts), new Uint32Array(ends), new Uint32Array(axes)));\n    };\n    WASMTensor.prototype.upsample = function (scales) {\n        return new WASMTensor(this.wasmTensor.upsample(new Float32Array(scales)));\n    };\n    WASMTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof WASMTensor) ||\n            !(variance instanceof WASMTensor) ||\n            !(scale instanceof WASMTensor) ||\n            !(bias instanceof WASMTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return new WASMTensor(this.wasmTensor.normalize(mean.wasmTensor, variance.wasmTensor, epsilon, scale.wasmTensor, bias.wasmTensor));\n    };\n    WASMTensor.padModeToInt = {\n        constant: 0,\n        reflect: 1,\n        edge: 2,\n    };\n    return WASMTensor;\n}(Tensor));\nexport { WASMTensor };\n//# sourceMappingURL=tensor.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defaultAllocator, gl } from '../../tensor/gpu/gl';\nimport { computeStrides, getSize } from '../../util/shape';\nexport var defaultMaxRank = 10;\nexport var defaultMaxIterations = 10000000;\n/**\n * A GPU operation takes some input of the InputType and\n * calculates a single GPUTensor\n *\n * This is done with WebGL, which takes some input information of type Info,\n * which is passed to the shader in the form of uniforms.\n */\nvar Operation = /** @class */ (function () {\n    function Operation(tensorConstructor, allocator, maxRank) {\n        this.statics = new Set();\n        this.copyCounter = 0;\n        this.fullyStatic = false;\n        if (allocator === undefined) {\n            allocator = defaultAllocator;\n        }\n        if (maxRank === undefined) {\n            maxRank = defaultMaxRank;\n        }\n        this.allocator = allocator;\n        this.maxRank = maxRank;\n        this.gpuTensorConstructor = tensorConstructor;\n    }\n    Operation.prototype.registerStatics = function (info) {\n        var staticTextures = 0;\n        var staticVars = 0;\n        for (var key in info) {\n            if (key.startsWith('shape')) {\n                var texName = key.slice('shape'.length);\n                this.statics.add(\"shape\" + texName);\n                this.statics.add(\"size\" + texName);\n                this.statics.add(\"rank\" + texName);\n                this.statics.add(\"strides\" + texName);\n                staticTextures++;\n            }\n            else {\n                this.statics.add(key);\n                if (!key.startsWith('width') && !key.startsWith('height')) {\n                    staticVars++;\n                }\n            }\n        }\n        if (staticTextures - 1 === this.getTextureNames().length &&\n            staticVars === this.getUniformAttrs().length) {\n            this.fullyStatic = true;\n            this.outputShape = info['shapeOutput'];\n        }\n    };\n    /**\n     * Gets the variable modifier for the WebGL variable with the given name\n     */\n    Operation.prototype.getVarModifier = function (name) {\n        return this.statics.has(name) ? '' : 'uniform';\n    };\n    /**\n     * Pads an array to the specified length, or the maxRank by default\n     */\n    Operation.prototype.pad = function (arr, len) {\n        if (len === void 0) { len = this.maxRank; }\n        while (arr.length < len) {\n            arr.push(-1);\n        }\n        return arr;\n    };\n    Operation.prototype.copyPad = function (arr, len) {\n        if (len === void 0) { len = this.maxRank; }\n        var result = Array.from(arr);\n        while (result.length < len) {\n            result.push(-1);\n        }\n        return result;\n    };\n    /**\n     * Gets the variable declarations for the WebGL shader. Overwrite this if you\n     * need extra uniform inputs\n     */\n    Operation.prototype.getVariables = function () {\n        return '';\n    };\n    Operation.prototype.getVariableDeclarations = function () {\n        var _this = this;\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        return \"\\n      \" + textures\n            .map(function (x) {\n            return \"\\n        \" + (x === 'Output' ? '' : \"uniform sampler2D \" + x + \";\") + \"\\n        \" + _this.getVarModifier('size' + x) + \" int size\" + x + \";\\n        \" + _this.getVarModifier('width' + x) + \" int width\" + x + \";\\n        \" + _this.getVarModifier('height' + x) + \" int height\" + x + \";\\n        \" + _this.getVarModifier('strides' + x) + \" int strides\" + x + \"[\" + _this.maxRank + \"];\\n        \" + _this.getVarModifier('shape' + x) + \" int shape\" + x + \"[\" + _this.maxRank + \"];\\n        \" + _this.getVarModifier('rank' + x) + \" int rank\" + x + \";\\n        \";\n        })\n            .join('\\n') + \"\\n      varying vec2 uv;\\n\\n      \" + this.getVariables();\n    };\n    Operation.prototype.getVariableInitializations = function (info) {\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        var inits = '';\n        for (var _i = 0, textures_1 = textures; _i < textures_1.length; _i++) {\n            var tex = textures_1[_i];\n            if (\"shape\" + tex in info) {\n                var shape = info[\"shape\" + tex];\n                var strides = computeStrides(shape);\n                var size = getSize(shape);\n                var rank = shape.length;\n                inits += this.getArrayInit(\"shape\" + tex, shape);\n                inits += this.getArrayInit(\"strides\" + tex, strides);\n                inits += \"\\nsize\" + tex + \" = \" + size + \";\";\n                inits += \"\\nrank\" + tex + \" = \" + rank + \";\";\n            }\n        }\n        for (var k in info) {\n            if (!k.startsWith('shape')) {\n                if (Array.isArray(info[k])) {\n                    inits += this.getArrayInit(k, info[k]);\n                }\n                else {\n                    var type = this.getVarType(k);\n                    if (type === 'int') {\n                        inits += \"\\n\" + k + \" = \" + info[k] + \";\";\n                    }\n                    else {\n                        inits += \"\\n\" + k + \" = \" + info[k].toPrecision(20) + \";\";\n                    }\n                }\n            }\n        }\n        return inits;\n    };\n    Operation.prototype.getVarType = function (name) {\n        var res = this.getUniformAttrs().find(function (x) { return x.name === name; });\n        if (res !== undefined) {\n            return res.type ? res.type : 'int';\n        }\n        return 'int';\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Operation.prototype.getArrayInit = function (name, values, len, pad) {\n        if (len === undefined) {\n            len = this.maxRank;\n        }\n        var type = this.getVarType(name);\n        if (pad === undefined) {\n            if (type === 'int') {\n                pad = '-1';\n            }\n            else if (type === 'float') {\n                pad = '-1.0';\n            }\n        }\n        var res = '';\n        for (var i = 0; i < len; i++) {\n            if (i < values.length) {\n                if (type === 'int') {\n                    res += \"\\n \" + name + \"[\" + i + \"] = \" + values[i] + \";\";\n                }\n                else if (type === 'float') {\n                    res += \"\\n \" + name + \"[\" + i + \"] = \" + values[i].toPrecision(20) + \";\";\n                }\n            }\n            else {\n                res += \"\\n \" + name + \"[\" + i + \"] = \" + pad + \";\";\n            }\n        }\n        return res;\n    };\n    Operation.prototype.getUtilFunctions = function () {\n        return \"\\n    int fromFloat(float f) {\\n      return int(floor(f+0.5));\\n    }\\n\\n    int coordinateToPos(vec2 coordinate, int textureWidth, int textureHeight) {\\n      int x = (fromFloat(coordinate.x*float(textureWidth*2))-1)/2;\\n      int y = (fromFloat(coordinate.y*float(textureHeight*2))-1)/2;\\n\\n      int pos = x + y*textureWidth;\\n\\n      return pos*4;\\n    }\\n\\n    vec2 posToCoordinate(int pos, int textureWidth, int textureHeight) {\\n      // 4 positions map to the same coordinate\\n      pos = pos/4;\\n\\n      int y = pos/textureWidth;\\n      int x = pos - y*textureWidth;\\n\\n      return vec2(float(x*2+1)/float(textureWidth*2), float(y*2+1)/float(textureHeight*2));\\n    }\\n\\n    int indexToPos(int index[\" + this.maxRank + \"], int strides[\" + this.maxRank + \"]) {\\n      int pos = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (strides[i] == -1) {\\n          break;\\n        }\\n        pos += index[i]*strides[i];\\n      }\\n      return pos;\\n    }\\n\\n    float getValueAtPos(int pos, int textureWidth, int textureHeight, sampler2D tex) {\\n      vec2 coord = posToCoordinate(pos, textureWidth, textureHeight);\\n      int res = pos - (pos/4)*4;\\n      vec4 val = texture2D(tex, coord);\\n      if (res == 0) {\\n        return val.r;\\n      } else if (res == 1) {\\n        return val.g;\\n      } else if (res == 2) {\\n        return val.b;\\n      } else {\\n        return val.a;\\n      }\\n    }\\n\\n    float getValueAt(int index[\" + this.maxRank + \"], int strides[\" + this.maxRank + \"], int textureWidth, int textureHeight, sampler2D tex) {\\n      int pos = indexToPos(index, strides);\\n      return getValueAtPos(pos, textureWidth, textureHeight, tex);\\n    }\";\n    };\n    Operation.prototype.getTextureFunctions = function () {\n        var _this = this;\n        var textures = this.getTextureNames();\n        return textures\n            .map(function (x) {\n            return \"\\n      float _\" + x + \"(int indices[\" + _this.maxRank + \"]) {\\n        return getValueAt(indices, strides\" + x + \", width\" + x + \", height\" + x + \", \" + x + \");\\n      }\\n      \";\n        })\n            .join('\\n');\n    };\n    Operation.prototype.getCompleteFragmentShader = function (info, precision) {\n        var fragShader = this.getFragmentShader(info);\n        var variableDecls = this.getVariableDeclarations();\n        var varInits = this.getVariableInitializations(info);\n        var utilFunctions = this.getUtilFunctions();\n        var textureFunctions = this.getTextureFunctions();\n        var result = \"\\n    precision \" + this.precisionString(precision) + \" float;\\n\\n    \" + variableDecls + \"\\n\\n    \" + utilFunctions + \"\\n    \" + textureFunctions + \"\\n\\n    void initVars() {\\n      \" + varInits + \"\\n    }\\n\\n    \" + fragShader;\n        return result;\n    };\n    Operation.prototype.getUniforms = function (info) {\n        var uniformAttrs = [];\n        var defaultUniformAttrs = this.getUniformAttrs();\n        for (var _i = 0, defaultUniformAttrs_1 = defaultUniformAttrs; _i < defaultUniformAttrs_1.length; _i++) {\n            var defaultAttr = defaultUniformAttrs_1[_i];\n            if (info[defaultAttr.name] === undefined) {\n                uniformAttrs.push(defaultAttr);\n            }\n        }\n        var textures = this.getTextureNames();\n        textures.push('Output');\n        for (var _a = 0, textures_2 = textures; _a < textures_2.length; _a++) {\n            var texture = textures_2[_a];\n            uniformAttrs.push({ name: texture });\n            if (info[\"shape\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"size\" + texture });\n                uniformAttrs.push({ name: \"strides\" + texture, length: this.maxRank });\n                uniformAttrs.push({ name: \"shape\" + texture, length: this.maxRank });\n                uniformAttrs.push({ name: \"rank\" + texture });\n            }\n            if (info[\"width\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"width\" + texture });\n            }\n            if (info[\"height\" + texture] === undefined) {\n                uniformAttrs.push({ name: \"height\" + texture });\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var uniforms = {};\n        for (var _b = 0, uniformAttrs_1 = uniformAttrs; _b < uniformAttrs_1.length; _b++) {\n            var uniformAttr = uniformAttrs_1[_b];\n            if (info[uniformAttr.name] === undefined) {\n                if (uniformAttr.length !== undefined) {\n                    for (var i = 0; i < uniformAttr.length; i++) {\n                        var name_1 = uniformAttr.name + \"[\" + i + \"]\";\n                        uniforms[name_1] = gl.prop(name_1);\n                    }\n                }\n                else {\n                    uniforms[uniformAttr.name] = gl.prop(uniformAttr.name);\n                }\n            }\n        }\n        return uniforms;\n    };\n    Operation.prototype.posToIndex = function (strides, result, pos) {\n        var name = pos + \"_\" + this.copyCounter++;\n        return \"\\n    int \" + name + \" = \" + pos + \";\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (\" + strides + \"[i] == -1) {\\n        \" + result + \"[i] = -1;\\n      } else {\\n        if (\" + strides + \"[i] == 0) {\\n          \" + result + \"[i] = 0;\\n        } else {\\n          \" + result + \"[i] = \" + name + \"/\" + strides + \"[i];\\n          \" + name + \" = \" + name + \" - \" + strides + \"[i]*\" + result + \"[i]; // Stupid modulo hack\\n        }\\n      }\\n    }\";\n    };\n    Operation.prototype.initIndex = function (index, rank) {\n        if (rank === undefined) {\n            return \"\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          \" + index + \"[i] = -1;\\n        }\";\n        }\n        else {\n            return \"\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (i < \" + rank + \") {\\n            \" + index + \"[i] = 0;\\n          } else {\\n            \" + index + \"[i] = -1;\\n          }\\n        }\";\n        }\n    };\n    Operation.prototype.incrementIndex = function (index, shape) {\n        return \"\\n    for (int i = \" + this.maxRank + \" - 1; i >= 0; i--) {\\n      if (\" + shape + \"[i] != -1) {\\n        \" + index + \"[i] += 1;\\n        if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n          \" + index + \"[i] = 0;\\n        } else {\\n          break;\\n        }\\n      }\\n    }\\n    \";\n    };\n    Operation.prototype.incrementConditional = function (index, shape, cond) {\n        return \"\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (\" + cond + \"[i] == 1) {\\n        \" + index + \"[i] += 1;\\n        if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n          \" + index + \"[i] = 0;\\n        } else {\\n          break;\\n        }\\n      } else if (\" + cond + \"[i] == -1) {\\n        break;\\n      }\\n    }\\n    \";\n    };\n    /**\n     * The default main function of the fragment shader.\n     * Unless in special cases, you will use this and your fragment shader will look something like this:\n     *\n     * ```\n     * float process(int index[maxRank]) {\n     *   // Calculate the value of the output at the given index\n     * }\n     *\n     * ${this.getDefaultMain()}\n     * ```\n     */\n    Operation.prototype.getDefaultMain = function () {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      int pos = coordinateToPos(uv, widthOutput, heightOutput);\\n\\n      vec4 result = vec4(0,0,0,0);\\n\\n      if (pos < sizeOutput) {\\n        int index[\" + this.maxRank + \"];\\n        \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n        result.r = process(index);\\n\\n        pos += 1;\\n\\n        if (pos < sizeOutput) {\\n          \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n          result.g = process(index);\\n\\n          pos += 1;\\n\\n          if (pos < sizeOutput) {\\n            \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n            result.b = process(index);\\n\\n            pos += 1;\\n\\n            if (pos < sizeOutput) {\\n              \" + this.posToIndex('stridesOutput', 'index', 'pos') + \"\\n              result.a = process(index);\\n            }\\n          }\\n        }\\n      }\\n\\n      gl_FragColor = result;\\n    }\";\n    };\n    Operation.prototype.precisionString = function (precision) {\n        return precision === 32 ? 'highp' : 'mediump';\n    };\n    Operation.prototype.getDrawCommand = function (info, precision) {\n        var fragShader = this.getCompleteFragmentShader(info, precision);\n        var uniforms = this.getUniforms(info);\n        var result = gl({\n            frag: fragShader,\n            vert: \"\\n        precision \" + this.precisionString(precision) + \" float;\\n        attribute vec2 position;\\n        varying vec2 uv;\\n        void main() {\\n          uv = 0.5 * (position + 1.0);\\n          gl_Position = vec4(position, 0, 1);\\n        }\",\n            attributes: {\n                position: [-4, -4, 4, -4, 0, 4],\n            },\n            uniforms: uniforms,\n            framebuffer: gl.prop('framebuffer'),\n            depth: {\n                enable: false,\n            },\n            count: 3,\n        });\n        return result;\n    };\n    /**\n     * Compiles the fragment shader with the given compilation info and precision\n     *\n     * If you need to add extra compilation info, overwrite this method\n     */\n    Operation.prototype.compile = function (info, precision) {\n        this.registerStatics(info);\n        this.precision = precision;\n        this.drawCommand = this.getDrawCommand(info, precision);\n    };\n    Operation.prototype.compute = function (resultShape, inputTensors, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputs) {\n        if (this.drawCommand === undefined) {\n            this.compile({}, 32);\n        }\n        var resultSize = getSize(resultShape);\n        //@ts-ignore\n        var result = this.allocator.allocate(resultSize, this.precision);\n        for (var i in inputTensors) {\n            var t = inputTensors[i];\n            if (t.memory.id === result.id) {\n                throw new Error(\"Allocator returned a framebuffer that is also an input\\n                         Did you delete a GPU tensor that was still used elsewhere?\");\n            }\n        }\n        var inputTextures = {};\n        for (var name_2 in inputTensors) {\n            inputTextures[name_2] = inputTensors[name_2].memory.frameBuffer;\n        }\n        if (inputs === undefined) {\n            inputs = {};\n        }\n        if (!this.fullyStatic) {\n            for (var name_3 in inputTensors) {\n                if (!this.statics.has(\"shape\" + name_3)) {\n                    inputs[\"size\" + name_3] = inputTensors[name_3].size;\n                    inputs[\"strides\" + name_3] = this.pad(computeStrides(inputTensors[name_3].shape));\n                    inputs[\"shape\" + name_3] = this.copyPad(inputTensors[name_3].shape);\n                    inputs[\"rank\" + name_3] = inputTensors[name_3].shape.length;\n                }\n                if (!this.statics.has(\"width\" + name_3)) {\n                    inputs[\"width\" + name_3] = inputTensors[name_3].memory.width;\n                }\n                if (!this.statics.has(\"height\" + name_3)) {\n                    inputs[\"height\" + name_3] = inputTensors[name_3].memory.height;\n                }\n            }\n            if (!this.statics.has('shapeOutput')) {\n                inputs['sizeOutput'] = resultSize;\n                inputs['stridesOutput'] = this.pad(computeStrides(resultShape));\n                inputs['shapeOutput'] = this.copyPad(resultShape);\n                inputs['rankOutput'] = resultShape.length;\n            }\n            if (!this.statics.has('widthOutput')) {\n                inputs['widthOutput'] = result.width;\n            }\n            if (!this.statics.has('heightOutput')) {\n                inputs['heightOutput'] = result.height;\n            }\n        }\n        //@ts-ignore\n        this.drawCommand(__assign(__assign({ framebuffer: result.frameBuffer }, inputTextures), inputs));\n        //@ts-ignore\n        return this.gpuTensorConstructor(result, resultShape, this.precision);\n    };\n    Operation.prototype.getUniformAttrs = function () {\n        return [];\n    };\n    return Operation;\n}());\nexport { Operation };\n//# sourceMappingURL=operation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar MatMulOperation = /** @class */ (function (_super) {\n    __extends(MatMulOperation, _super);\n    function MatMulOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        _this.maxRank = 2;\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    MatMulOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int ix1[\" + this.maxRank + \"];\\n      \" + this.initIndex('ix1') + \"\\n      ix1[0] = index[0];\\n\\n      int ix2[\" + this.maxRank + \"];\\n      \" + this.initIndex('ix2') + \"\\n      ix2[1] = index[1];\\n\\n      int k = shapeA[1];\\n\\n      float res = 0.0;\\n\\n      for (int i = 0; i < \" + this.maxIterations + \"; i++) {\\n        if (i >= k) {\\n          break;\\n        }\\n        ix1[1] = i;\\n        ix2[0] = i;\\n\\n        float v1 = _A(ix1);\\n        float v2 = _B(ix2);\\n        res += v1*v2;\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    MatMulOperation.prototype.getTextureNames = function () {\n        return ['A', 'B'];\n    };\n    MatMulOperation.prototype.calc = function (input) {\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A, B: input.B });\n    };\n    MatMulOperation.prototype.getOutputShape = function (input) {\n        return [input.A.shape[0], input.B.shape[1]];\n    };\n    MatMulOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxIterations = info.shapeA[1];\n        }\n        else if (info.shapeB !== undefined) {\n            this.maxIterations = info.shapeB[0];\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    MatMulOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.A.shape,\n            widthB: input.A.memory.width,\n            heightB: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n        };\n    };\n    MatMulOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape;\n    };\n    return MatMulOperation;\n}(Operation));\nexport { MatMulOperation };\n//# sourceMappingURL=matmul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar UnaryOperation = /** @class */ (function (_super) {\n    __extends(UnaryOperation, _super);\n    function UnaryOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UnaryOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      gl_FragColor = \" + this.operation('texture2D(X, uv)') + \";\\n    }\\n    \";\n    };\n    UnaryOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    UnaryOperation.prototype.calc = function (input) {\n        return this.compute(input.input.shape, { X: input.input });\n    };\n    UnaryOperation.prototype.getOutputShape = function (input) {\n        return input.input.shape;\n    };\n    UnaryOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UnaryOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: this.getOutputShape(input),\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n        };\n    };\n    UnaryOperation.prototype.getInputInfoString = function (input) {\n        return \"\" + input.input.shape;\n    };\n    return UnaryOperation;\n}(Operation));\nexport { UnaryOperation };\n//# sourceMappingURL=unaryOperation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar ExpOperation = /** @class */ (function (_super) {\n    __extends(ExpOperation, _super);\n    function ExpOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ExpOperation.prototype.operation = function (input) {\n        return \"exp(\" + input + \")\";\n    };\n    return ExpOperation;\n}(UnaryOperation));\nexport { ExpOperation };\n//# sourceMappingURL=exp.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { getSize } from '../../../util/shape';\nimport { outputDimsSize } from '../../util/conv';\nimport { Operation } from '../operation';\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nvar ConvOperation = /** @class */ (function (_super) {\n    __extends(ConvOperation, _super);\n    function ConvOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    ConvOperation.prototype.updateInputIx = function () {\n        return \"\\n    for (int d = 0; d < \" + (this.maxRank - 2) + \"; d++) {\\n      int stride = strides[d];\\n      int pad = pads[d];\\n      int dilation = dilations[d];\\n      if (stride == -1) {\\n        break;\\n      }\\n\\n      inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d+2]*dilation;\\n      if (inputIx[d+2] < 0 || inputIx[d+2] >= shapeX[d+2]) {\\n        skip = true;\\n        break;\\n      }\\n    }\\n    \";\n    };\n    ConvOperation.prototype.getMainBody = function () {\n        return \"\\n    int n = index[0];\\n    int m = index[1];\\n\\n    int kernelIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('kernelIx') + \"\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (i >= dataRank) {\\n        break;\\n      }\\n      kernelIx[i+2] = 0;\\n    }\\n    kernelIx[0] = m;\\n    int inputIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('inputIx') + \"\\n    inputIx[0] = n;\\n\\n    for (int cg = 0; cg < \" + this.maxIterations + \"; cg++) {\\n      if (cg >= CG) {\\n        break;\\n      }\\n      int c = m * CG + cg;\\n      int d = c/C;\\n      c = c - d*C;\\n      inputIx[1] = c;\\n      kernelIx[1] = cg;\\n      for (int kIx = 0; kIx < \" + this.maxIterations + \"; kIx++) {\\n        if (kIx >= kernelSize) {\\n          break;\\n        }\\n\\n        bool skip = false;\\n\\n        \" + this.updateInputIx() + \"\\n\\n        if (!skip) {\\n          res += _X(inputIx) * _W(kernelIx);\\n        }\\n\\n        \" + this.incrementIndex('kernelIx', 'shapeW') + \"\\n      }\\n    }\\n    \";\n    };\n    ConvOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('CG') + \" int CG;\\n    \" + this.getVarModifier('kernelSize') + \" int kernelSize;\\n    \" + this.getVarModifier('dataRank') + \" int dataRank;\\n    \" + this.getVarModifier('C') + \" int C;\\n    \" + this.getVarModifier('dilations') + \" int dilations[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('strides') + \" int strides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('activation') + \" int activation;\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConvOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n\\n      \" + this.getMainBody() + \"\\n\\n      if (activation == 1) {\\n        res = max(0.0, res);\\n      } else if (activation == 2) {\\n        res = max(0.0, min(res,6.0));\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConvOperation.prototype.getTextureNames = function () {\n        return ['X', 'W'];\n    };\n    ConvOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'CG' },\n            { name: 'kernelSize' },\n            { name: 'C' },\n            { name: 'dataRank' },\n            { name: 'pads', length: this.maxRank * 2 },\n            { name: 'strides', length: this.maxRank },\n            { name: 'dilations', length: this.maxRank },\n            { name: 'activation' },\n        ];\n    };\n    ConvOperation.prototype.getActivationFlag = function (activation) {\n        if (activation === 'id') {\n            return 0;\n        }\n        else if (activation === 'relu') {\n            return 1;\n        }\n        else {\n            return 2;\n        }\n    };\n    ConvOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X, W: input.W });\n        }\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var CG = input.W.shape[1];\n        var kernelSize = getSize(W);\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X, W: input.W }, {\n            CG: CG,\n            kernelSize: kernelSize,\n            C: C,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            dilations: this.copyPad(input.dilations),\n            activation: this.getActivationFlag(input.activation),\n        });\n    };\n    ConvOperation.prototype.getOutputShape = function (input) {\n        var N = input.X.shape[0];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return outputShape;\n    };\n    ConvOperation.prototype.compile = function (info, precision) {\n        if (info.shapeW !== undefined) {\n            info.CG = info.shapeW[1];\n            info.kernelSize = getSize(info.shapeW.slice(2));\n            info.dataRank = info.shapeW.length - 2;\n            this.maxRank = info.shapeW.length;\n        }\n        if (info.shapeX !== undefined) {\n            info.C = info.shapeX[1];\n            info.dataRank = info.shapeX.length - 2;\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.activation !== undefined && typeof info.activation === 'string') {\n            info.activation = this.getActivationFlag(info.activation);\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ConvOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var kernelSize = getSize(input.W.shape.slice(2));\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeW: input.W.shape,\n            widthW: input.W.memory.width,\n            heightW: input.W.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            dilations: input.dilations,\n            strides: input.strides,\n            CG: input.W.shape[1],\n            kernelSize: kernelSize,\n            dataRank: D.length,\n            C: C,\n            activation: this.getActivationFlag(input.activation),\n        };\n    };\n    ConvOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.W.shape + \"-\" + input.dilations + \"-\" + input.pads + \"-\" + input.dilations + \"-\" + input.strides + \"-\" + input.activation;\n    };\n    return ConvOperation;\n}(Operation));\nexport { ConvOperation };\nvar ConvBiasOperation = /** @class */ (function (_super) {\n    __extends(ConvBiasOperation, _super);\n    function ConvBiasOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConvBiasOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int biasIndex[\" + this.maxRank + \"];\\n      \" + this.initIndex('biasIndex') + \"\\n      biasIndex[0] = index[1];\\n      float res = _B(biasIndex);\\n\\n      \" + this.getMainBody() + \"\\n\\n      if (activation == 1) {\\n        res = max(0.0, res);\\n      } else if (activation == 2) {\\n        res = max(0.0, min(res,6.0));\\n      }\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConvBiasOperation.prototype.getTextureNames = function () {\n        return ['X', 'W', 'B'];\n    };\n    ConvBiasOperation.prototype.calc = function (input) {\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var CG = input.W.shape[1];\n        var kernelSize = getSize(W);\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X, W: input.W, B: input.B }, {\n            CG: CG,\n            kernelSize: kernelSize,\n            C: C,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            dilations: this.copyPad(input.dilations),\n            activation: this.getActivationFlag(input.activation),\n        });\n    };\n    ConvBiasOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { shapeB: input.B.shape, widthB: input.B.memory.width, heightB: input.B.memory.height });\n    };\n    ConvBiasOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.B.shape;\n    };\n    return ConvBiasOperation;\n}(ConvOperation));\nexport { ConvBiasOperation };\n//# sourceMappingURL=conv.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar AbsOperation = /** @class */ (function (_super) {\n    __extends(AbsOperation, _super);\n    function AbsOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    AbsOperation.prototype.operation = function (input) {\n        return \"abs(\" + input + \")\";\n    };\n    return AbsOperation;\n}(UnaryOperation));\nexport { AbsOperation };\n//# sourceMappingURL=abs.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from './../operation';\nvar BinaryOperation = /** @class */ (function (_super) {\n    __extends(BinaryOperation, _super);\n    function BinaryOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    BinaryOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int[\" + this.maxRank + \"] index) {\\n      return \" + this.getOp('_A(index)', '_B(index)') + \";\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    BinaryOperation.prototype.getOutputShape = function (input) {\n        return input.outputShape;\n    };\n    BinaryOperation.prototype.getTextureNames = function () {\n        return ['A', 'B'];\n    };\n    BinaryOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B });\n    };\n    BinaryOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        if (info.shapeB !== undefined) {\n            this.maxRank = info.shapeB.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    BinaryOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(input.outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.B.shape,\n            widthB: input.B.memory.width,\n            heightB: input.B.memory.height,\n            shapeOutput: input.outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n        };\n    };\n    BinaryOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape;\n    };\n    return BinaryOperation;\n}(Operation));\nexport { BinaryOperation };\n//# sourceMappingURL=binaryOperation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { BinaryOperation } from './binaryOperation';\nvar AddOperation = /** @class */ (function (_super) {\n    __extends(AddOperation, _super);\n    function AddOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    AddOperation.prototype.getOp = function (a, b) {\n        return \"alpha*\" + a + \" + beta*\" + b;\n    };\n    AddOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B }, { alpha: input.alpha, beta: input.beta });\n    };\n    AddOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \" + this.getVarModifier('beta') + \" float beta;\\n    \";\n    };\n    AddOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'alpha', type: 'float' },\n            { name: 'beta', type: 'float' },\n        ];\n    };\n    AddOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { alpha: input.alpha, beta: input.beta });\n    };\n    AddOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.alpha + \"-\" + input.beta;\n    };\n    return AddOperation;\n}(BinaryOperation));\nexport { AddOperation };\n//# sourceMappingURL=add.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { BinaryOperation } from './binaryOperation';\nvar MultiplyOperation = /** @class */ (function (_super) {\n    __extends(MultiplyOperation, _super);\n    function MultiplyOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    MultiplyOperation.prototype.getOp = function (a, b) {\n        return \"alpha*\" + a + \" * \" + b;\n    };\n    MultiplyOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B }, { alpha: input.alpha });\n    };\n    MultiplyOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \";\n    };\n    MultiplyOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'alpha', type: 'float' }];\n    };\n    MultiplyOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { alpha: input.alpha });\n    };\n    MultiplyOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.alpha;\n    };\n    return MultiplyOperation;\n}(BinaryOperation));\nexport { MultiplyOperation };\n//# sourceMappingURL=multiply.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { BinaryOperation } from './binaryOperation';\nvar SubtractOperation = /** @class */ (function (_super) {\n    __extends(SubtractOperation, _super);\n    function SubtractOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SubtractOperation.prototype.getOp = function (a, b) {\n        return \"alpha*\" + a + \" - beta*\" + b;\n    };\n    SubtractOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B }, { alpha: input.alpha, beta: input.beta });\n    };\n    SubtractOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \" + this.getVarModifier('beta') + \" float beta;\\n    \";\n    };\n    SubtractOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'alpha', type: 'float' },\n            { name: 'beta', type: 'float' },\n        ];\n    };\n    SubtractOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { alpha: input.alpha, beta: input.beta });\n    };\n    SubtractOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.alpha + \"-\" + input.beta;\n    };\n    return SubtractOperation;\n}(BinaryOperation));\nexport { SubtractOperation };\n//# sourceMappingURL=subtract.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { BinaryOperation } from './binaryOperation';\nvar DivideOperation = /** @class */ (function (_super) {\n    __extends(DivideOperation, _super);\n    function DivideOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    DivideOperation.prototype.getOp = function (a, b) {\n        return \"alpha*\" + a + \" / \" + b;\n    };\n    DivideOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { A: input.A, B: input.B }, { alpha: input.alpha });\n    };\n    DivideOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \";\n    };\n    DivideOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'alpha', type: 'float' }];\n    };\n    DivideOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { alpha: input.alpha });\n    };\n    DivideOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.alpha;\n    };\n    return DivideOperation;\n}(BinaryOperation));\nexport { DivideOperation };\n//# sourceMappingURL=divide.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getSize } from '../../../util/shape';\nimport { outputDimsSize } from '../../util/conv';\nimport { Operation } from '../operation';\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nvar AveragePoolOperation = /** @class */ (function (_super) {\n    __extends(AveragePoolOperation, _super);\n    function AveragePoolOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    AveragePoolOperation.prototype.updateInputIx = function () {\n        return \"\\n    for (int d = 0; d < \" + (this.maxRank - 2) + \"; d++) {\\n      int stride = strides[d];\\n      int pad = pads[d];\\n      if (stride == -1) {\\n        break;\\n      }\\n\\n      inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d];\\n      if (inputIx[d+2] < 0 || inputIx[d+2] >= shapeX[d+2]) {\\n        skip = true;\\n        break;\\n      }\\n    }\\n    \";\n    };\n    AveragePoolOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('kernelSize') + \" int kernelSize;\\n    \" + this.getVarModifier('dataRank') + \" int dataRank;\\n    \" + this.getVarModifier('includePad') + \" int includePad;\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('strides') + \" int strides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('kernelShape') + \" int kernelShape[\" + this.maxRank + \"];\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AveragePoolOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n      int count = 0;\\n\\n      int n = index[0];\\n      int c = index[1];\\n\\n      int kernelIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('kernelIx') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i >= dataRank) {\\n          break;\\n        }\\n        kernelIx[i] = 0;\\n      }\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n      inputIx[0] = n;\\n      inputIx[1] = c;\\n\\n      for (int kIx = 0; kIx < \" + this.maxIterations + \"; kIx++) {\\n        if (kIx >= kernelSize) {\\n          break;\\n        }\\n\\n        bool skip = false;\\n\\n        \" + this.updateInputIx() + \"\\n\\n        if (!skip) {\\n          res += _X(inputIx);\\n        }\\n\\n        if (!skip || includePad == 1) {\\n          count += 1;\\n        }\\n\\n        \" + this.incrementIndex('kernelIx', 'kernelShape') + \"\\n      }\\n\\n      res = res / float(count);\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    AveragePoolOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    AveragePoolOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'kernelSize' },\n            { name: 'dataRank' },\n            { name: 'includePad' },\n            { name: 'pads', length: this.maxRank * 2 },\n            { name: 'strides', length: this.maxRank },\n            { name: 'kernelShape', length: this.maxRank },\n        ];\n    };\n    AveragePoolOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var kernelSize = getSize(input.kernelShape);\n        var R = outputDimsSize(D, input.kernelShape, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), new Array(D.length).fill(1), input.strides);\n        var outputShape = [N, C];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X }, {\n            kernelSize: kernelSize,\n            includePad: input.includePad ? 1 : 0,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            kernelShape: this.copyPad(input.kernelShape),\n        });\n    };\n    AveragePoolOperation.prototype.getOutputShape = function (input) {\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var R = outputDimsSize(D, input.kernelShape, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), new Array(D.length).fill(1), input.strides);\n        var outputShape = [N, C];\n        outputShape = outputShape.concat(R);\n        return outputShape;\n    };\n    AveragePoolOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            info.dataRank = info.shapeX.length - 2;\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.includePad === true) {\n            info.includePad = 1;\n        }\n        else if (info.includePad === false) {\n            info.includePad = 0;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    AveragePoolOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var kernelSize = getSize(input.kernelShape);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            kernelShape: input.kernelShape,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            strides: input.strides,\n            kernelSize: kernelSize,\n            dataRank: input.X.shape.length - 2,\n            includePad: input.includePad ? 1 : 0,\n        };\n    };\n    AveragePoolOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.kernelShape + \"-\" + input.pads + \"-\" + input.strides + \"-\" + input.includePad;\n    };\n    return AveragePoolOperation;\n}(Operation));\nexport { AveragePoolOperation };\n//# sourceMappingURL=averagePool.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { computeStrides, getSize } from '../../../util/shape';\nimport { poolResultShape } from '../../util/pool';\nimport { Operation } from '../operation';\nvar PoolOperation = /** @class */ (function (_super) {\n    __extends(PoolOperation, _super);\n    function PoolOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    PoolOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('mappedInputStrides') + \" int mappedInputStrides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int sumDims[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int sumSize;\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    PoolOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n\\n      int inputPos = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (mappedInputStrides[i] == -1 || index[i] == -1) {\\n          break;\\n        }\\n        inputPos += mappedInputStrides[i]*index[i];\\n      }\\n\\n      \" + this.posToIndex('stridesX', 'inputIx', 'inputPos') + \"\\n\\n      float res = 0.0;\\n\\n      for (int i = 0; i < \" + this.maxIterations + \"; i++) {\\n        if (i >= sumSize) {\\n          break;\\n        }\\n        float curr = _X(inputIx);\\n        if (i == 0) {\\n          res = \" + this.init('curr') + \";\\n        } else {\\n          res = \" + this.update('curr', 'res') + \";\\n        }\\n\\n        \" + this.incrementConditional('inputIx', 'shapeX', 'sumDims') + \"\\n      }\\n\\n      \" + this.post('res') + \"\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    PoolOperation.prototype.post = function (res) {\n        return '';\n    };\n    PoolOperation.prototype.init = function (res) {\n        return res;\n    };\n    PoolOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    PoolOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'mappedInputStrides', length: this.maxRank },\n            { name: 'sumDims', length: this.maxRank },\n            { name: 'sumSize' },\n        ];\n    };\n    PoolOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        var inputStrides = computeStrides(input.X.shape);\n        var mappedInputStrides = [];\n        for (var _i = 0, ixMap_1 = ixMap; _i < ixMap_1.length; _i++) {\n            var i = ixMap_1[_i];\n            mappedInputStrides.push(inputStrides[i]);\n        }\n        var sumSize = 1;\n        var sumDims = new Array(input.X.shape.length).fill(0);\n        for (var i = 0; i < input.axes.length; i++) {\n            sumDims[input.axes[i]] = 1;\n            sumSize *= input.X.shape[input.axes[i]];\n        }\n        return this.compute(outputShape, { X: input.X }, {\n            mappedInputStrides: this.pad(mappedInputStrides),\n            sumDims: this.pad(sumDims),\n            sumSize: sumSize,\n        });\n    };\n    PoolOperation.prototype.getOutputShape = function (input) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        return outputShape;\n    };\n    PoolOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined &&\n            info.axes !== undefined &&\n            info.keepDims !== undefined) {\n            var _a = poolResultShape(info.shapeX, info.axes, info.keepDims), outputShape = _a[0], ixMap = _a[1];\n            var inputStrides = computeStrides(info.shapeX);\n            var mappedInputStrides = [];\n            for (var _i = 0, ixMap_2 = ixMap; _i < ixMap_2.length; _i++) {\n                var i = ixMap_2[_i];\n                mappedInputStrides.push(inputStrides[i]);\n            }\n            var sumSize = 1;\n            var sumDims = new Array(info.shapeX.length).fill(0);\n            for (var i = 0; i < info.axes.length; i++) {\n                sumDims[info.axes[i]] = 1;\n                sumSize *= info.shapeX[info.axes[i]];\n            }\n            info.sumDims = sumDims;\n            info.shapeOutput = outputShape;\n            info.mappedInputStrides = mappedInputStrides;\n            info.sumSize = sumSize;\n            delete info['keepDims'];\n            delete info['axes'];\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    PoolOperation.prototype.getCompilationInfo = function (input, precision) {\n        var _a = poolResultShape(input.X.shape, input.axes, input.keepDims), outputShape = _a[0], ixMap = _a[1];\n        var inputStrides = computeStrides(input.X.shape);\n        var mappedInputStrides = [];\n        for (var _i = 0, ixMap_3 = ixMap; _i < ixMap_3.length; _i++) {\n            var i = ixMap_3[_i];\n            mappedInputStrides.push(inputStrides[i]);\n        }\n        var sumSize = 1;\n        var sumDims = new Array(input.X.shape.length).fill(0);\n        for (var i = 0; i < input.axes.length; i++) {\n            sumDims[input.axes[i]] = 1;\n            sumSize *= input.X.shape[input.axes[i]];\n        }\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            mappedInputStrides: mappedInputStrides,\n            sumDims: sumDims,\n            sumSize: sumSize,\n        };\n    };\n    PoolOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axes + \"-\" + input.keepDims;\n    };\n    return PoolOperation;\n}(Operation));\nexport { PoolOperation };\n//# sourceMappingURL=pool.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar ReduceMeanOperation = /** @class */ (function (_super) {\n    __extends(ReduceMeanOperation, _super);\n    function ReduceMeanOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReduceMeanOperation.prototype.update = function (a, b) {\n        return a + \" + \" + b;\n    };\n    ReduceMeanOperation.prototype.post = function (res) {\n        return res + \" = \" + res + \"/float(sumSize);\";\n    };\n    return ReduceMeanOperation;\n}(PoolOperation));\nexport { ReduceMeanOperation };\n//# sourceMappingURL=reduceMean.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar ReduceMeanSquareOperation = /** @class */ (function (_super) {\n    __extends(ReduceMeanSquareOperation, _super);\n    function ReduceMeanSquareOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReduceMeanSquareOperation.prototype.update = function (a, b) {\n        return \"(\" + a + \"*\" + a + \") + \" + b;\n    };\n    ReduceMeanSquareOperation.prototype.post = function (res) {\n        return res + \" = \" + res + \"/float(sumSize);\";\n    };\n    ReduceMeanSquareOperation.prototype.init = function (res) {\n        return res + \"*\" + res;\n    };\n    return ReduceMeanSquareOperation;\n}(PoolOperation));\nexport { ReduceMeanSquareOperation };\n//# sourceMappingURL=reduceMeanSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar SumSquareOperation = /** @class */ (function (_super) {\n    __extends(SumSquareOperation, _super);\n    function SumSquareOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SumSquareOperation.prototype.update = function (a, b) {\n        return \"(\" + a + \"*\" + a + \") + \" + b;\n    };\n    SumSquareOperation.prototype.init = function (res) {\n        return res + \"*\" + res;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    SumSquareOperation.prototype.compile = function (info, precision) {\n        _super.prototype.compile.call(this, info, 32);\n    };\n    return SumSquareOperation;\n}(PoolOperation));\nexport { SumSquareOperation };\n//# sourceMappingURL=sumSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar SumOperation = /** @class */ (function (_super) {\n    __extends(SumOperation, _super);\n    function SumOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SumOperation.prototype.update = function (a, b) {\n        return a + \" + \" + b;\n    };\n    return SumOperation;\n}(PoolOperation));\nexport { SumOperation };\n//# sourceMappingURL=sum.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar ProductOperation = /** @class */ (function (_super) {\n    __extends(ProductOperation, _super);\n    function ProductOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ProductOperation.prototype.update = function (a, b) {\n        return a + \" * \" + b;\n    };\n    return ProductOperation;\n}(PoolOperation));\nexport { ProductOperation };\n//# sourceMappingURL=product.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar MaxOperation = /** @class */ (function (_super) {\n    __extends(MaxOperation, _super);\n    function MaxOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MaxOperation.prototype.update = function (a, b) {\n        return \"max(\" + a + \", \" + b + \")\";\n    };\n    return MaxOperation;\n}(PoolOperation));\nexport { MaxOperation };\n//# sourceMappingURL=max.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { PoolOperation } from './pool';\nvar MinOperation = /** @class */ (function (_super) {\n    __extends(MinOperation, _super);\n    function MinOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MinOperation.prototype.update = function (a, b) {\n        return \"min(\" + a + \", \" + b + \")\";\n    };\n    return MinOperation;\n}(PoolOperation));\nexport { MinOperation };\n//# sourceMappingURL=min.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar CeilOperation = /** @class */ (function (_super) {\n    __extends(CeilOperation, _super);\n    function CeilOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    CeilOperation.prototype.operation = function (input) {\n        return \"ceil(\" + input + \")\";\n    };\n    return CeilOperation;\n}(UnaryOperation));\nexport { CeilOperation };\n//# sourceMappingURL=ceil.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { Operation } from '../operation';\nvar ClipOperation = /** @class */ (function (_super) {\n    __extends(ClipOperation, _super);\n    function ClipOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ClipOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      vec4 maxVec = vec4(maxVal,maxVal,maxVal,maxVal);\\n      vec4 minVec = vec4(minVal,minVal,minVal,minVal);\\n\\n      vec4 res = texture2D(X, uv);\\n      if (doMin == 1) {\\n        res = max(minVec, res);\\n      }\\n      if (doMax == 1) {\\n        res = min(maxVec, res);\\n      }\\n\\n      gl_FragColor = res;\\n    }\\n    \";\n    };\n    ClipOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    ClipOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('minVal') + \" float minVal;\\n    \" + this.getVarModifier('maxVal') + \" float maxVal;\\n    \" + this.getVarModifier('doMin') + \" int doMin;\\n    \" + this.getVarModifier('doMax') + \" int doMax;\\n    \";\n    };\n    ClipOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'minVal', type: 'float' },\n            { name: 'maxVal', type: 'float' },\n            { name: 'doMin' },\n            { name: 'doMax' },\n        ];\n    };\n    ClipOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.input });\n        }\n        return this.compute(input.input.shape, { X: input.input }, {\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0,\n        });\n    };\n    ClipOperation.prototype.getOutputShape = function (input) {\n        return input.input.shape;\n    };\n    ClipOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ClipOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputSize = defaultAllocator.getAllocationDimensions(input.input.size, precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: input.input.shape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0,\n        };\n    };\n    ClipOperation.prototype.getInputInfoString = function (input) {\n        return input.input.shape + \"-\" + input.minVal + \"-\" + input.maxVal;\n    };\n    return ClipOperation;\n}(Operation));\nexport { ClipOperation };\n//# sourceMappingURL=clip.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar FloorOperation = /** @class */ (function (_super) {\n    __extends(FloorOperation, _super);\n    function FloorOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    FloorOperation.prototype.operation = function (input) {\n        return \"floor(\" + input + \")\";\n    };\n    return FloorOperation;\n}(UnaryOperation));\nexport { FloorOperation };\n//# sourceMappingURL=floor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar ConcatOperation = /** @class */ (function (_super) {\n    __extends(ConcatOperation, _super);\n    function ConcatOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    ConcatOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('axis') + \" int axis;\\n    \";\n    };\n    ConcatOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'axis' }];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConcatOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i == axis) {\\n          if (index[i] >= shapeA[i]) {\\n            index[i] = index[i] - shapeA[i];\\n            res = _B(index);\\n          } else {\\n            res = _A(index);\\n          }\\n          break;\\n        }\\n      }\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConcatOperation.prototype.getTextureNames = function () {\n        return ['A', 'B'];\n    };\n    ConcatOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { A: input.A, B: input.B });\n        }\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A, B: input.B }, { axis: input.axis });\n    };\n    ConcatOperation.prototype.getOutputShape = function (input) {\n        var outputShape = __spreadArrays(input.A.shape);\n        outputShape[input.axis] += input.B.shape[input.axis];\n        return outputShape;\n    };\n    ConcatOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        if (info.shapeB !== undefined) {\n            this.maxRank = info.shapeB.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ConcatOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeB: input.B.shape,\n            widthB: input.B.memory.width,\n            heightB: input.B.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            axis: input.axis,\n        };\n    };\n    ConcatOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.B.shape + \"-\" + input.axis;\n    };\n    return ConcatOperation;\n}(Operation));\nexport { ConcatOperation };\n//# sourceMappingURL=concat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar CopyOperation = /** @class */ (function (_super) {\n    __extends(CopyOperation, _super);\n    function CopyOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    CopyOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      gl_FragColor = texture2D(X, uv);\\n    }\\n    \";\n    };\n    CopyOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    CopyOperation.prototype.calc = function (input) {\n        var shape = this.getOutputShape(input);\n        return this.compute(shape, { X: input.input });\n    };\n    CopyOperation.prototype.getOutputShape = function (input) {\n        var shape = input.outputShape;\n        if (shape === undefined) {\n            shape = input.input.shape;\n        }\n        return shape;\n    };\n    CopyOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    CopyOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n        };\n    };\n    CopyOperation.prototype.getInputInfoString = function (input) {\n        return input.input + \"-\" + this.getOutputShape(input);\n    };\n    return CopyOperation;\n}(Operation));\nexport { CopyOperation };\n//# sourceMappingURL=copy.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar ExpandOperation = /** @class */ (function (_super) {\n    __extends(ExpandOperation, _super);\n    function ExpandOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ExpandOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      return _X(index);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ExpandOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    ExpandOperation.prototype.calc = function (input) {\n        return this.compute(input.outputShape, { X: input.input });\n    };\n    ExpandOperation.prototype.getOutputShape = function (input) {\n        return input.outputShape;\n    };\n    ExpandOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ExpandOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n        };\n    };\n    ExpandOperation.prototype.getInputInfoString = function (input) {\n        return input.input.shape + \"-\" + input.outputShape;\n    };\n    return ExpandOperation;\n}(Operation));\nexport { ExpandOperation };\n//# sourceMappingURL=expand.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { computeStrides, getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar GatherOperation = /** @class */ (function (_super) {\n    __extends(GatherOperation, _super);\n    function GatherOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.gatherMaxIxSize = 10;\n        return _this;\n    }\n    GatherOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('axis') + \" int axis;\\n    \" + this.getVarModifier('indexValues') + \" int indexValues[\" + this.gatherMaxIxSize + \"];\\n    \" + this.getVarModifier('mappedIndexStrides') + \" int mappedIndexStrides[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('mappedInputStrides') + \" int mappedInputStrides[\" + this.maxRank + \"];\\n    \";\n    };\n    GatherOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'axis' },\n            { name: 'indexValues', length: this.gatherMaxIxSize },\n            { name: 'mappedInputStrides', length: this.maxRank },\n            { name: 'mappedIndexStrides', length: this.maxRank },\n        ];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    GatherOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputPos = 0;\\n      int indexPos = 0;\\n\\n      int strideAxis = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n        if (i == axis) {\\n          strideAxis = stridesX[i];\\n        }\\n        inputPos += mappedInputStrides[i]*index[i];\\n        indexPos += mappedIndexStrides[i]*index[i];\\n      }\\n\\n      for (int i = 0; i < \" + this.gatherMaxIxSize + \"; i++) {\\n        if (i == indexPos) {\\n          inputPos += indexValues[i]*strideAxis;\\n          break;\\n        }\\n      }\\n\\n      return getValueAtPos(inputPos, widthX, heightX, X);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GatherOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    GatherOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        if (input.indices.size > this.gatherMaxIxSize) {\n            throw new Error(\"Gather on GPU can deal with at most \" + this.gatherMaxIxSize + \" indices, input had \" + input.indices.size);\n        }\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var inputStrides = computeStrides(input.X.shape);\n        var indexStrides = computeStrides(input.indices.shape);\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        var mappedInputStrides = new Array(resultRank).fill(0);\n        var mappedIndexStrides = new Array(resultRank).fill(0);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n            mappedInputStrides[i] = inputStrides[i];\n            mappedIndexStrides[i] = 0;\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n            mappedIndexStrides[i + input.axis] = indexStrides[i];\n            mappedInputStrides[i + input.axis] = 0;\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n            mappedInputStrides[i + q - 1] = inputStrides[i];\n            mappedIndexStrides[i + q - 1] = 0;\n        }\n        return this.compute(resultShape, { X: input.X }, {\n            axis: input.axis,\n            indexValues: this.pad(Array.from(input.indices.values), this.gatherMaxIxSize),\n            mappedInputStrides: this.pad(mappedInputStrides),\n            mappedIndexStrides: this.pad(mappedIndexStrides),\n        });\n    };\n    GatherOperation.prototype.getOutputShape = function (input) {\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n        }\n        return resultShape;\n    };\n    GatherOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n            if (info.indices !== undefined && info.axis !== undefined) {\n                var r = info.shapeX.length;\n                var q = info.indices.shape.length;\n                var inputStrides = computeStrides(info.shapeX);\n                var indexStrides = computeStrides(info.indices.shape);\n                var resultRank = r + q - 1;\n                var resultShape = new Array(resultRank);\n                var mappedInputStrides = new Array(resultRank).fill(0);\n                var mappedIndexStrides = new Array(resultRank).fill(0);\n                for (var i = 0; i < info.axis; i++) {\n                    resultShape[i] = info.shapeX[i];\n                    mappedInputStrides[i] = inputStrides[i];\n                    mappedIndexStrides[i] = 0;\n                }\n                for (var i = 0; i < q; i++) {\n                    resultShape[i + info.axis] = info.indices.shape[i];\n                    mappedIndexStrides[i + info.axis] = indexStrides[i];\n                    mappedInputStrides[i + info.axis] = 0;\n                }\n                for (var i = info.axis + 1; i < r; i++) {\n                    resultShape[i + q - 1] = info.shapeX[i];\n                    mappedInputStrides[i + q - 1] = inputStrides[i];\n                    mappedIndexStrides[i + q - 1] = 0;\n                }\n                info.mappedIndexStrides = mappedIndexStrides;\n                info.mappedInputStrides = mappedInputStrides;\n                info.indexValues = Array.from(info.indices.values);\n                delete info['indices'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    GatherOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var r = input.X.shape.length;\n        var q = input.indices.shape.length;\n        var inputStrides = computeStrides(input.X.shape);\n        var indexStrides = computeStrides(input.indices.shape);\n        var resultRank = r + q - 1;\n        var resultShape = new Array(resultRank);\n        var mappedInputStrides = new Array(resultRank).fill(0);\n        var mappedIndexStrides = new Array(resultRank).fill(0);\n        for (var i = 0; i < input.axis; i++) {\n            resultShape[i] = input.X.shape[i];\n            mappedInputStrides[i] = inputStrides[i];\n            mappedIndexStrides[i] = 0;\n        }\n        for (var i = 0; i < q; i++) {\n            resultShape[i + input.axis] = input.indices.shape[i];\n            mappedIndexStrides[i + input.axis] = indexStrides[i];\n            mappedInputStrides[i + input.axis] = 0;\n        }\n        for (var i = input.axis + 1; i < r; i++) {\n            resultShape[i + q - 1] = input.X.shape[i];\n            mappedInputStrides[i + q - 1] = inputStrides[i];\n            mappedIndexStrides[i + q - 1] = 0;\n        }\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            axis: input.axis,\n            indexValues: Array.from(input.indices.values),\n            mappedIndexStrides: mappedIndexStrides,\n            mappedInputStrides: mappedInputStrides,\n        };\n    };\n    GatherOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axis + \"-\" + Array.from(input.indices.values) + \"-\" + input.indices.shape;\n    };\n    return GatherOperation;\n}(Operation));\nexport { GatherOperation };\n//# sourceMappingURL=gather.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nvar GemmOperation = /** @class */ (function (_super) {\n    __extends(GemmOperation, _super);\n    function GemmOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    GemmOperation.prototype.getMainBody = function () {\n        return \"\\n      int ixA[\" + this.maxRank + \"];\\n      \" + this.initIndex('ixA') + \"\\n      int ixB[\" + this.maxRank + \"];\\n      \" + this.initIndex('ixA') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i >= rank - 2) {\\n          break;\\n        }\\n        ixA[i] = index[i];\\n        ixB[i] = index[i];\\n      }\\n\\n      int m = 0;\\n      int o = 0;\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (i == rank-2) {\\n          m = index[i];\\n          o = index[i+1];\\n\\n          if (aTranspose == 0) {\\n            ixA[i] = m;\\n          } else {\\n            ixA[i+1] = m;\\n          }\\n\\n          if (bTranspose == 0) {\\n            ixB[i+1] = o;\\n          } else {\\n            ixB[i] = o;\\n          }\\n\\n          break;\\n        }\\n      }\\n\\n      float res = 0.0;\\n\\n      for (int n = 0; n < \" + this.maxIterations + \"; n++) {\\n        if (n >= N) {\\n          break;\\n        }\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (i == rank-2) {\\n            if (aTranspose == 0) {\\n              ixA[i+1] = n;\\n            } else {\\n              ixA[i] = n;\\n            }\\n\\n            if (bTranspose == 0) {\\n              ixB[i] = n;\\n            } else {\\n              ixB[i+1] = n;\\n            }\\n\\n            break;\\n          }\\n        }\\n        res += _A(ixA) * _B(ixB);\\n      }\\n\\n      res = res*alpha;\\n    \";\n    };\n    GemmOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('M') + \" int M;\\n    \" + this.getVarModifier('N') + \" int N;\\n    \" + this.getVarModifier('O') + \" int O;\\n    \" + this.getVarModifier('rank') + \" int rank;\\n    \" + this.getVarModifier('aTranspose') + \" int aTranspose;\\n    \" + this.getVarModifier('bTranspose') + \" int bTranspose;\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \" + this.getVarModifier('beta') + \" float beta;\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    GemmOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      \" + this.getMainBody() + \"\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GemmOperation.prototype.getTextureNames = function () {\n        return ['A', 'B'];\n    };\n    GemmOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'M' },\n            { name: 'N' },\n            { name: 'O' },\n            { name: 'rank' },\n            { name: 'aTranspose' },\n            { name: 'bTranspose' },\n            { name: 'alpha', type: 'float' },\n            { name: 'beta', type: 'float' },\n        ];\n    };\n    GemmOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { A: input.a, B: input.b });\n        }\n        var rank = input.a.shape.length;\n        var M = input.aTranspose\n            ? input.a.shape[rank - 1]\n            : input.a.shape[rank - 2];\n        var N = input.aTranspose\n            ? input.a.shape[rank - 2]\n            : input.a.shape[rank - 1];\n        var O = input.bTranspose\n            ? input.b.shape[rank - 2]\n            : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        var uniforms = {\n            M: M,\n            N: N,\n            O: O,\n            rank: rank,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta,\n        };\n        return this.compute(resultShape, { A: input.a, B: input.b }, uniforms);\n    };\n    GemmOperation.prototype.getOutputShape = function (input) {\n        var rank = input.a.shape.length;\n        var M = input.aTranspose\n            ? input.a.shape[rank - 1]\n            : input.a.shape[rank - 2];\n        var O = input.bTranspose\n            ? input.b.shape[rank - 2]\n            : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        return resultShape;\n    };\n    GemmOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            var rank = info.shapeA.length;\n            info.rank = rank;\n            this.maxRank = rank;\n            if (info.aTranspose !== undefined) {\n                var M = info.aTranspose\n                    ? info.shapeA[rank - 1]\n                    : info.shapeA[rank - 2];\n                var N = info.aTranspose\n                    ? info.shapeA[rank - 2]\n                    : info.shapeA[rank - 1];\n                info.M = M;\n                info.N = N;\n                info.aTranspose = info.aTranspose ? 1 : 0;\n            }\n        }\n        if (info.shapeB !== undefined && info.bTranspose !== undefined) {\n            var rank = info.shapeB.length;\n            var O = info.bTranspose ? info.shapeB[rank - 2] : info.shapeB[rank - 1];\n            info.O = O;\n            info.bTranspose = info.bTranspose ? 1 : 0;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    GemmOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.a.shape.length;\n        var M = input.aTranspose\n            ? input.a.shape[rank - 1]\n            : input.a.shape[rank - 2];\n        var N = input.aTranspose\n            ? input.a.shape[rank - 2]\n            : input.a.shape[rank - 1];\n        var O = input.bTranspose\n            ? input.b.shape[rank - 2]\n            : input.b.shape[rank - 1];\n        var info = {\n            shapeA: input.a.shape,\n            widthA: input.a.memory.width,\n            heightA: input.a.memory.height,\n            shapeB: input.b.shape,\n            widthB: input.b.memory.width,\n            heightB: input.b.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            M: M,\n            N: N,\n            O: O,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta,\n            rank: rank,\n        };\n        return info;\n    };\n    GemmOperation.prototype.getInputInfoString = function (input) {\n        //TODO: Check precision of alpha and beta\n        return input.a.shape + \"-\" + input.b.shape + \"-\" + input.aTranspose + \"-\" + input.bTranspose + \"-\" + input.alpha + \"-\" + input.beta;\n    };\n    return GemmOperation;\n}(Operation));\nexport { GemmOperation };\nvar GemmCOperation = /** @class */ (function (_super) {\n    __extends(GemmCOperation, _super);\n    function GemmCOperation() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GemmCOperation.prototype.getTextureNames = function () {\n        return ['A', 'B', 'C'];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    GemmCOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      \" + this.getMainBody() + \"\\n\\n      res += beta*_C(index);\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    GemmCOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, {\n                A: input.a,\n                B: input.b,\n                C: input.c,\n            });\n        }\n        var rank = input.a.shape.length;\n        var M = input.aTranspose\n            ? input.a.shape[rank - 1]\n            : input.a.shape[rank - 2];\n        var N = input.aTranspose\n            ? input.a.shape[rank - 2]\n            : input.a.shape[rank - 1];\n        var O = input.bTranspose\n            ? input.b.shape[rank - 2]\n            : input.b.shape[rank - 1];\n        var batchShape = input.a.shape.slice(0, rank - 2);\n        var resultShape = __spreadArrays(batchShape, [M, O]);\n        var uniforms = {\n            M: M,\n            N: N,\n            O: O,\n            rank: rank,\n            aTranspose: input.aTranspose ? 1 : 0,\n            bTranspose: input.bTranspose ? 1 : 0,\n            alpha: input.alpha,\n            beta: input.beta,\n        };\n        return this.compute(resultShape, { A: input.a, B: input.b, C: input.c }, uniforms);\n    };\n    GemmCOperation.prototype.getCompilationInfo = function (input, precision) {\n        var inf = _super.prototype.getCompilationInfo.call(this, input, precision);\n        var info = __assign(__assign({}, inf), { shapeC: input.c.shape, widthC: input.c.memory.width, heightC: input.c.memory.height });\n        return info;\n    };\n    GemmCOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.c.shape;\n    };\n    return GemmCOperation;\n}(GemmOperation));\nexport { GemmCOperation };\n//# sourceMappingURL=gemm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from './binaryOperation';\nvar PowerOperation = /** @class */ (function (_super) {\n    __extends(PowerOperation, _super);\n    function PowerOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    PowerOperation.prototype.getOp = function (a, b) {\n        return \"pow(\" + a + \", \" + b + \")\";\n    };\n    return PowerOperation;\n}(BinaryOperation));\nexport { PowerOperation };\n//# sourceMappingURL=power.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar SqrtOperation = /** @class */ (function (_super) {\n    __extends(SqrtOperation, _super);\n    function SqrtOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SqrtOperation.prototype.operation = function (input) {\n        return \"sqrt(\" + input + \")\";\n    };\n    return SqrtOperation;\n}(UnaryOperation));\nexport { SqrtOperation };\n//# sourceMappingURL=sqrt.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar LogOperation = /** @class */ (function (_super) {\n    __extends(LogOperation, _super);\n    function LogOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    LogOperation.prototype.operation = function (input) {\n        return \"log(\" + input + \")\";\n    };\n    return LogOperation;\n}(UnaryOperation));\nexport { LogOperation };\n//# sourceMappingURL=log.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { computeStrides, getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar TransposeOperation = /** @class */ (function (_super) {\n    __extends(TransposeOperation, _super);\n    function TransposeOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    TransposeOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('mappedStrides') + \" int mappedStrides[\" + this.maxRank + \"];\\n    \";\n    };\n    TransposeOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'mappedStrides', length: this.maxRank }];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    TransposeOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      return getValueAt(index, mappedStrides, widthA, heightA, A);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    TransposeOperation.prototype.getTextureNames = function () {\n        return ['A'];\n    };\n    TransposeOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { A: input.A });\n        }\n        var rank = input.A.shape.length;\n        var outputShape = this.getOutputShape(input);\n        var inputStrides = computeStrides(input.A.shape);\n        var mappedStrides = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            mappedStrides[i] = inputStrides[input.permutation[i]];\n        }\n        return this.compute(outputShape, { A: input.A }, { mappedStrides: this.pad(mappedStrides) });\n    };\n    TransposeOperation.prototype.getOutputShape = function (input) {\n        var rank = input.A.shape.length;\n        var outputShape = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            outputShape[i] = input.A.shape[input.permutation[i]];\n        }\n        return outputShape;\n    };\n    TransposeOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n            if (info.permutation !== undefined) {\n                var rank = info.shapeA.length;\n                var inputStrides = computeStrides(info.shapeA);\n                var mappedStrides = new Array(rank);\n                for (var i = 0; i < rank; i++) {\n                    mappedStrides[i] = inputStrides[info.permutation[i]];\n                }\n                info.mappedStrides = mappedStrides;\n                delete info['permutation'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    TransposeOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.A.shape.length;\n        var inputStrides = computeStrides(input.A.shape);\n        var mappedStrides = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            mappedStrides[i] = inputStrides[input.permutation[i]];\n        }\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            mappedStrides: mappedStrides,\n        };\n    };\n    TransposeOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.permutation;\n    };\n    return TransposeOperation;\n}(Operation));\nexport { TransposeOperation };\n//# sourceMappingURL=transpose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar RepeatOperation = /** @class */ (function (_super) {\n    __extends(RepeatOperation, _super);\n    function RepeatOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    RepeatOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('repeats') + \" int repeats[\" + this.maxRank + \"];\\n    \";\n    };\n    RepeatOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'repeats', length: this.maxRank }];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    RepeatOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIndex[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIndex') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (repeats[i] == -1) {\\n          break;\\n        }\\n        int d = index[i] / shapeA[i];\\n        inIndex[i] = index[i] - d*shapeA[i];\\n      }\\n\\n      return _A(inIndex);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    RepeatOperation.prototype.getOutputShape = function (input) {\n        var rank = input.A.shape.length;\n        var outputShape = new Array(rank);\n        for (var i = 0; i < rank; i++) {\n            outputShape[i] = input.A.shape[i] * input.repeats[i];\n        }\n        return outputShape;\n    };\n    RepeatOperation.prototype.getTextureNames = function () {\n        return ['A'];\n    };\n    RepeatOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { A: input.A });\n        }\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A }, { repeats: this.copyPad(input.repeats) });\n    };\n    RepeatOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    RepeatOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            repeats: input.repeats,\n        };\n    };\n    RepeatOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.repeats;\n    };\n    return RepeatOperation;\n}(Operation));\nexport { RepeatOperation };\n//# sourceMappingURL=repeat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar PadOperation = /** @class */ (function (_super) {\n    __extends(PadOperation, _super);\n    function PadOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    PadOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inputIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inputIx') + \"\\n      if (mode == 0) {\\n        float res = value;\\n\\n        int outOfBounds = 0;\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0 || inputIx[i] >= shapeX[i]) {\\n            outOfBounds = 1;\\n            break;\\n          }\\n        }\\n\\n        if (outOfBounds == 0) {\\n          res = _X(inputIx);\\n        }\\n\\n        return res;\\n      } else if (mode == 1) {\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0) {\\n            inputIx[i] = -inputIx[i];\\n          } else if (inputIx[i] >= shapeX[i]) {\\n            inputIx[i] = 2*shapeX[i] - inputIx[i] - 2;\\n          }\\n        }\\n\\n        return _X(inputIx);\\n      } else {\\n        for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n          if (index[i] == -1) {\\n            break;\\n          }\\n          inputIx[i] = index[i] - pads[i];\\n          if (inputIx[i] < 0) {\\n            inputIx[i] = 0;\\n          } else if (inputIx[i] >= shapeX[i]) {\\n            inputIx[i] = shapeX[i] - 1;\\n          }\\n        }\\n\\n        return _X(inputIx);\\n      }\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    PadOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    PadOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank * 2 + \"];\\n    \" + this.getVarModifier('value') + \" float value;\\n    \" + this.getVarModifier('mode') + \" int mode;\\n    \";\n    };\n    PadOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'value', type: 'float' },\n            { name: 'pads', length: this.maxRank * 2 },\n            { name: 'mode' },\n        ];\n    };\n    PadOperation.prototype.getModeFlag = function (mode) {\n        return mode === 'constant' ? 0 : mode === 'reflect' ? 1 : 2;\n    };\n    PadOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.input });\n        }\n        var resultShape = this.getOutputShape(input);\n        return this.compute(resultShape, { X: input.input }, {\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            value: input.value,\n            mode: this.getModeFlag(input.mode),\n        });\n    };\n    PadOperation.prototype.getOutputShape = function (input) {\n        var rank = input.input.shape.length;\n        var resultShape = __spreadArrays(input.input.shape);\n        for (var i = 0; i < rank; i++) {\n            resultShape[i] += input.pads[i] + input.pads[i + rank];\n        }\n        return resultShape;\n    };\n    PadOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        if (info.mode !== undefined && typeof info.mode === 'string') {\n            info.mode = this.getModeFlag(info.mode);\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    PadOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            mode: this.getModeFlag(input.mode),\n            value: input.value,\n        };\n    };\n    PadOperation.prototype.getInputInfoString = function (input) {\n        //TODO: Format value with enough precision?\n        return input.input.shape + \"-\" + input.pads + \"-\" + input.mode + \"-\" + input.value;\n    };\n    return PadOperation;\n}(Operation));\nexport { PadOperation };\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar SliceOperation = /** @class */ (function (_super) {\n    __extends(SliceOperation, _super);\n    function SliceOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    SliceOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIx') + \"\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n\\n        inIx[i] = index[i] + offsets[i];\\n      }\\n\\n      return _X(inIx);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    SliceOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    SliceOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('offsets') + \" int offsets[\" + this.maxRank + \"];\\n    \";\n    };\n    SliceOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'offsets', length: this.maxRank }];\n    };\n    SliceOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var offsets = new Array(rank).fill(0);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i === input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                offsets[i] = input.starts[axIx];\n                axIx++;\n            }\n        }\n        return this.compute(resultShape, { X: input.X }, {\n            offsets: this.pad(offsets),\n        });\n    };\n    SliceOperation.prototype.getOutputShape = function (input) {\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i === input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                axIx++;\n            }\n        }\n        return resultShape;\n    };\n    SliceOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n            if (info.axes !== undefined &&\n                info.starts !== undefined &&\n                info.starts !== undefined) {\n                var rank = info.shapeX.length;\n                var offsets = new Array(rank).fill(0);\n                var axIx = 0;\n                for (var i = 0; i < rank && axIx < info.axes.length; i++) {\n                    if (i === info.axes[axIx]) {\n                        offsets[i] = info.starts[axIx];\n                        axIx++;\n                    }\n                }\n                info.offsets = offsets;\n                delete info['starts'];\n                delete info['ends'];\n                delete info['axes'];\n            }\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    SliceOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        var offsets = new Array(rank).fill(0);\n        var axIx = 0;\n        for (var i = 0; i < rank && axIx < input.axes.length; i++) {\n            if (i === input.axes[axIx]) {\n                resultShape[i] = input.ends[axIx] - input.starts[axIx];\n                offsets[i] = input.starts[axIx];\n                axIx++;\n            }\n        }\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            offsets: offsets,\n        };\n    };\n    SliceOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.axes + \"-\" + input.starts + \"-\" + input.ends;\n    };\n    return SliceOperation;\n}(Operation));\nexport { SliceOperation };\n//# sourceMappingURL=slice.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar UpsampleOperation = /** @class */ (function (_super) {\n    __extends(UpsampleOperation, _super);\n    function UpsampleOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UpsampleOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int inIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('inIx') + \"\\n\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n\\n        inIx[i] = int(floor(float(index[i]) / scales[i]));\\n      }\\n\\n      return _X(inIx);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    UpsampleOperation.prototype.getTextureNames = function () {\n        return ['X'];\n    };\n    UpsampleOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('scales') + \" float scales[\" + this.maxRank + \"];\\n    \";\n    };\n    UpsampleOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'scales', length: this.maxRank, type: 'float' }];\n    };\n    UpsampleOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X });\n        }\n        var resultShape = this.getOutputShape(input);\n        return this.compute(resultShape, { X: input.X }, {\n            scales: this.copyPad(input.scales),\n        });\n    };\n    UpsampleOperation.prototype.getOutputShape = function (input) {\n        var rank = input.X.shape.length;\n        var resultShape = __spreadArrays(input.X.shape);\n        for (var i = 0; i < rank; i++) {\n            resultShape[i] = Math.floor(resultShape[i] * input.scales[i]);\n        }\n        return resultShape;\n    };\n    UpsampleOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UpsampleOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            scales: input.scales,\n        };\n    };\n    UpsampleOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.scales;\n    };\n    return UpsampleOperation;\n}(Operation));\nexport { UpsampleOperation };\n//# sourceMappingURL=upsample.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar NormalizeOperation = /** @class */ (function (_super) {\n    __extends(NormalizeOperation, _super);\n    function NormalizeOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    NormalizeOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('epsilon') + \" float epsilon;\\n    \";\n    };\n    NormalizeOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'epsilon', type: 'float' }];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    NormalizeOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int[\" + this.maxRank + \"] index) {\\n      float result = _X(index) - _Mean(index);\\n      result = result / sqrt(_Variance(index) + epsilon);\\n      result = result * _Scale(index) + _Bias(index);\\n      return result;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    NormalizeOperation.prototype.getOutputShape = function (input) {\n        return input.X.shape;\n    };\n    NormalizeOperation.prototype.getTextureNames = function () {\n        return ['X', 'Mean', 'Variance', 'Scale', 'Bias'];\n    };\n    NormalizeOperation.prototype.calc = function (input) {\n        return this.compute(input.X.shape, {\n            X: input.X,\n            Mean: input.Mean,\n            Variance: input.Variance,\n            Scale: input.Scale,\n            Bias: input.Bias,\n        }, { epsilon: input.epsilon });\n    };\n    NormalizeOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    NormalizeOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeBias: input.Bias.shape,\n            widthBias: input.Bias.memory.width,\n            heightBias: input.Bias.memory.height,\n            shapeMean: input.Mean.shape,\n            widthMean: input.Mean.memory.width,\n            heightMean: input.Mean.memory.height,\n            shapeScale: input.Scale.shape,\n            widthScale: input.Scale.memory.width,\n            heightScale: input.Scale.memory.height,\n            shapeVariance: input.Variance.shape,\n            widthVariance: input.Variance.memory.width,\n            heightVariance: input.Variance.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            epsilon: input.epsilon,\n        };\n    };\n    NormalizeOperation.prototype.getInputInfoString = function (input) {\n        // TODO: Format epsilon with enough precision?\n        return input.X.shape + \"-\" + input.Mean.shape + \"-\" + input.Variance.shape + \"-\" + input.Scale.shape + \"-\" + input.Bias.shape + \"-\" + input.epsilon;\n    };\n    return NormalizeOperation;\n}(Operation));\nexport { NormalizeOperation };\n//# sourceMappingURL=normalize.js.map","var Dispatcher = /** @class */ (function () {\n    function Dispatcher(getOp, minCallsToCompile) {\n        if (minCallsToCompile === void 0) { minCallsToCompile = 2; }\n        this.getOp = getOp;\n        this.minCallsToCompile = minCallsToCompile;\n        this.opDict = {};\n    }\n    Dispatcher.prototype.getDefault = function (precision) {\n        var str = \"default-\" + precision;\n        if (this.opDict[str] === undefined) {\n            var op = this.getOp();\n            op.compile({}, precision);\n            this.opDict[str] = {\n                infoString: str,\n                numCalls: 0,\n                operation: op,\n            };\n        }\n        return this.opDict[str];\n    };\n    Dispatcher.prototype.calc = function (input, precision) {\n        var defaultOp = this.getDefault(precision);\n        //@ts-ignore\n        var compileInfoString = defaultOp.operation.getInputInfoString(input);\n        if (this.opDict[compileInfoString] === undefined) {\n            this.opDict[compileInfoString] = {\n                infoString: compileInfoString,\n                numCalls: 0,\n            };\n        }\n        var opInfo = this.opDict[compileInfoString];\n        opInfo.numCalls++;\n        if (opInfo.numCalls >= this.minCallsToCompile) {\n            if (opInfo.operation === undefined) {\n                opInfo.operation = this.getOp();\n                //@ts-ignore\n                var compileInfo = defaultOp.operation.getCompilationInfo(input, precision);\n                opInfo.operation.compile(compileInfo, precision);\n            }\n            return opInfo.operation.calc(input);\n        }\n        else {\n            defaultOp.numCalls++;\n            //@ts-ignore\n            return defaultOp.operation.calc(input);\n        }\n    };\n    return Dispatcher;\n}());\nexport { Dispatcher };\n//# sourceMappingURL=dispatcher.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar SignOperation = /** @class */ (function (_super) {\n    __extends(SignOperation, _super);\n    function SignOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SignOperation.prototype.operation = function (input) {\n        return \"sign(\" + input + \")\";\n    };\n    return SignOperation;\n}(UnaryOperation));\nexport { SignOperation };\n//# sourceMappingURL=sign.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar NegateOperation = /** @class */ (function (_super) {\n    __extends(NegateOperation, _super);\n    function NegateOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    NegateOperation.prototype.operation = function (input) {\n        return \"-\" + input;\n    };\n    return NegateOperation;\n}(UnaryOperation));\nexport { NegateOperation };\n//# sourceMappingURL=negate.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { Operation } from '../operation';\nvar ClipBackwardOperation = /** @class */ (function (_super) {\n    __extends(ClipBackwardOperation, _super);\n    function ClipBackwardOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ClipBackwardOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float val = _X(index);\\n      if (doMin == 1 && val < minVal) {\\n        return 0.0;\\n      }\\n      if (doMax == 1 && val > maxVal) {\\n        return 0.0;\\n      }\\n      return _Grad(index);\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ClipBackwardOperation.prototype.getTextureNames = function () {\n        return ['X', 'Grad'];\n    };\n    ClipBackwardOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('minVal') + \" float minVal;\\n    \" + this.getVarModifier('maxVal') + \" float maxVal;\\n    \" + this.getVarModifier('doMin') + \" int doMin;\\n    \" + this.getVarModifier('doMax') + \" int doMax;\\n    \";\n    };\n    ClipBackwardOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'minVal', type: 'float' },\n            { name: 'maxVal', type: 'float' },\n            { name: 'doMin' },\n            { name: 'doMax' },\n        ];\n    };\n    ClipBackwardOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.input, Grad: input.grad });\n        }\n        return this.compute(input.input.shape, { X: input.input, Grad: input.grad }, {\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0,\n        });\n    };\n    ClipBackwardOperation.prototype.getOutputShape = function (input) {\n        return input.input.shape;\n    };\n    ClipBackwardOperation.prototype.compile = function (info, precision) {\n        if (info.shapeX !== undefined) {\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ClipBackwardOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputSize = defaultAllocator.getAllocationDimensions(input.input.size, precision);\n        return {\n            shapeX: input.input.shape,\n            widthX: input.input.memory.width,\n            heightX: input.input.memory.height,\n            shapeGrad: input.grad.shape,\n            widthGrad: input.grad.memory.width,\n            heightGrad: input.grad.memory.height,\n            shapeOutput: input.input.shape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            minVal: input.minVal !== undefined ? input.minVal : 0,\n            maxVal: input.maxVal !== undefined ? input.maxVal : 0,\n            doMin: input.minVal !== undefined ? 1 : 0,\n            doMax: input.maxVal !== undefined ? 1 : 0,\n        };\n    };\n    ClipBackwardOperation.prototype.getInputInfoString = function (input) {\n        return input.input.shape + \"-\" + input.minVal + \"-\" + input.maxVal;\n    };\n    return ClipBackwardOperation;\n}(Operation));\nexport { ClipBackwardOperation };\n//# sourceMappingURL=clipBackward.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { outputDimsSize } from '../../util/convTranspose';\nimport { Operation } from '../operation';\nvar ConvTransposeOperation = /** @class */ (function (_super) {\n    __extends(ConvTransposeOperation, _super);\n    function ConvTransposeOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    ConvTransposeOperation.prototype.updateInputIx = function () {\n        return \"\\n    for (int d = 0; d < \" + (this.maxRank - 2) + \"; d++) {\\n      int stride = strides[d];\\n      int pad = pads[d];\\n      int dilation = dilations[d];\\n      if (stride == -1) {\\n        break;\\n      }\\n\\n      int trans_kernel_ix = shapeW[d + 2] - kernelIx[d + 2] - 1;\\n\\n      inputIx[d+2] = index[d + 2] - pad + trans_kernel_ix * dilation;\\n\\n      int divS = inputIx[d+2] / stride;\\n      int resS = inputIx[d+2] - divS*stride;\\n\\n      if (resS != 0) {\\n        skip = true;\\n        break;\\n      }\\n      inputIx[d+2] = divS;\\n\\n      if (inputIx[d+2] < 0 || inputIx[d+2] >= shapeX[d+2]) {\\n        skip = true;\\n        break;\\n      }\\n    }\\n    \";\n    };\n    ConvTransposeOperation.prototype.getMainBody = function () {\n        return \"\\n    int n = index[0];\\n    int m = index[1];\\n\\n    int kernelIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('kernelIx') + \"\\n    for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n      if (i >= dataRank) {\\n        break;\\n      }\\n      kernelIx[i+2] = 0;\\n    }\\n    kernelIx[0] = m;\\n    int inputIx[\" + this.maxRank + \"];\\n    \" + this.initIndex('inputIx') + \"\\n    inputIx[0] = n;\\n\\n    for (int cg = 0; cg < \" + this.maxIterations + \"; cg++) {\\n      if (cg >= CG) {\\n        break;\\n      }\\n      int c = m * CG + cg;\\n      int d = c/C;\\n      c = c - d*C;\\n      inputIx[1] = c;\\n      kernelIx[1] = cg;\\n      for (int kIx = 0; kIx < \" + this.maxIterations + \"; kIx++) {\\n        if (kIx >= kernelSize) {\\n          break;\\n        }\\n\\n        bool skip = false;\\n\\n        \" + this.updateInputIx() + \"\\n\\n        if (!skip) {\\n          res += _X(inputIx) * _W(kernelIx);\\n        }\\n\\n        \" + this.incrementIndex('kernelIx', 'shapeW') + \"\\n      }\\n    }\\n    \";\n    };\n    ConvTransposeOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('CG') + \" int CG;\\n    \" + this.getVarModifier('kernelSize') + \" int kernelSize;\\n    \" + this.getVarModifier('dataRank') + \" int dataRank;\\n    \" + this.getVarModifier('C') + \" int C;\\n    \" + this.getVarModifier('dilations') + \" int dilations[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('pads') + \" int pads[\" + this.maxRank + \"];\\n    \" + this.getVarModifier('strides') + \" int strides[\" + this.maxRank + \"];\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConvTransposeOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      float res = 0.0;\\n\\n      \" + this.getMainBody() + \"\\n\\n      return res;\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    ConvTransposeOperation.prototype.getTextureNames = function () {\n        return ['X', 'W'];\n    };\n    ConvTransposeOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'CG' },\n            { name: 'kernelSize' },\n            { name: 'C' },\n            { name: 'dataRank' },\n            { name: 'pads', length: this.maxRank * 2 },\n            { name: 'strides', length: this.maxRank },\n            { name: 'dilations', length: this.maxRank },\n        ];\n    };\n    ConvTransposeOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { X: input.X, W: input.W });\n        }\n        var N = input.X.shape[0];\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var CG = input.W.shape[1];\n        var kernelSize = getSize(W);\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return this.compute(outputShape, { X: input.X, W: input.W }, {\n            CG: CG,\n            kernelSize: kernelSize,\n            C: C,\n            dataRank: D.length,\n            pads: this.copyPad(input.pads, this.maxRank * 2),\n            strides: this.copyPad(input.strides),\n            dilations: this.copyPad(input.dilations),\n        });\n    };\n    ConvTransposeOperation.prototype.getOutputShape = function (input) {\n        var N = input.X.shape[0];\n        var D = input.X.shape.slice(2);\n        var W = input.W.shape.slice(2);\n        var M = input.W.shape[0];\n        var R = outputDimsSize(D, W, input.pads.slice(0, input.pads.length / 2), input.pads.slice(input.pads.length / 2), input.dilations, input.strides);\n        var outputShape = [N, M];\n        outputShape = outputShape.concat(R);\n        return outputShape;\n    };\n    ConvTransposeOperation.prototype.compile = function (info, precision) {\n        if (info.shapeW !== undefined) {\n            info.CG = info.shapeW[1];\n            info.kernelSize = getSize(info.shapeW.slice(2));\n            info.dataRank = info.shapeW.length - 2;\n            this.maxRank = info.shapeW.length;\n        }\n        if (info.shapeX !== undefined) {\n            info.C = info.shapeX[1];\n            info.dataRank = info.shapeX.length - 2;\n            this.maxRank = info.shapeX.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    ConvTransposeOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        var kernelSize = getSize(input.W.shape.slice(2));\n        var C = input.X.shape[1];\n        var D = input.X.shape.slice(2);\n        return {\n            shapeX: input.X.shape,\n            widthX: input.X.memory.width,\n            heightX: input.X.memory.height,\n            shapeW: input.W.shape,\n            widthW: input.W.memory.width,\n            heightW: input.W.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            pads: input.pads,\n            dilations: input.dilations,\n            strides: input.strides,\n            CG: input.W.shape[1],\n            kernelSize: kernelSize,\n            dataRank: D.length,\n            C: C,\n        };\n    };\n    ConvTransposeOperation.prototype.getInputInfoString = function (input) {\n        return input.X.shape + \"-\" + input.W.shape + \"-\" + input.dilations + \"-\" + input.pads + \"-\" + input.dilations + \"-\" + input.strides;\n    };\n    return ConvTransposeOperation;\n}(Operation));\nexport { ConvTransposeOperation };\n//# sourceMappingURL=convTranspose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryOperation } from './unaryOperation';\nvar SigmoidOperation = /** @class */ (function (_super) {\n    __extends(SigmoidOperation, _super);\n    function SigmoidOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SigmoidOperation.prototype.operation = function (input) {\n        return \"1.0/(1.0 + exp(-\" + input + \"))\";\n    };\n    return SigmoidOperation;\n}(UnaryOperation));\nexport { SigmoidOperation };\n//# sourceMappingURL=sigmoid.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { UnaryOperation } from './unaryOperation';\nvar AddMultiplyScalarOperation = /** @class */ (function (_super) {\n    __extends(AddMultiplyScalarOperation, _super);\n    function AddMultiplyScalarOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    AddMultiplyScalarOperation.prototype.operation = function (input) {\n        return \"factor*\" + input + \" + add\";\n    };\n    AddMultiplyScalarOperation.prototype.calc = function (input) {\n        return this.compute(input.input.shape, { X: input.input }, { factor: input.factor, add: input.add });\n    };\n    AddMultiplyScalarOperation.prototype.getCompilationInfo = function (input, precision) {\n        var info = _super.prototype.getCompilationInfo.call(this, input, precision);\n        return __assign(__assign({}, info), { factor: input.factor, add: input.add });\n    };\n    AddMultiplyScalarOperation.prototype.getInputInfoString = function (input) {\n        return _super.prototype.getInputInfoString.call(this, input) + \"-\" + input.factor + \"-\" + input.add;\n    };\n    AddMultiplyScalarOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('factor') + \" float factor;\\n    \" + this.getVarModifier('add') + \" float add;\\n    \";\n    };\n    AddMultiplyScalarOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'factor', type: 'float' },\n            { name: 'add', type: 'float' },\n        ];\n    };\n    return AddMultiplyScalarOperation;\n}(UnaryOperation));\nexport { AddMultiplyScalarOperation };\n//# sourceMappingURL=addMultiplyScalar.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { getSize } from '../../../util/shape';\nimport { Operation } from '../operation';\nvar SetValuesOperation = /** @class */ (function (_super) {\n    __extends(SetValuesOperation, _super);\n    function SetValuesOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    SetValuesOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('starts') + \" int starts[\" + this.maxRank + \"];\\n    \";\n    };\n    SetValuesOperation.prototype.getUniformAttrs = function () {\n        return [{ name: 'starts', length: this.maxRank }];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    SetValuesOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float process(int index[\" + this.maxRank + \"]) {\\n      int valueIx[\" + this.maxRank + \"];\\n      \" + this.initIndex('valueIx') + \"\\n\\n      int inValues = 1;\\n\\n      for (int i = 0; i < \" + this.maxRank + \"; i++) {\\n        if (index[i] == -1) {\\n          break;\\n        }\\n\\n        if (index[i] < starts[i] || index[i] >= (starts[i] + shapeValues[i])) {\\n          inValues = 0;\\n          break;\\n        } else {\\n          valueIx[i] = index[i] - starts[i];\\n        }\\n      }\\n\\n      if (inValues == 1) {\\n        return _Values(valueIx);\\n      } else {\\n        return _A(index);\\n      }\\n    }\\n\\n    \" + this.getDefaultMain() + \"\\n    \";\n    };\n    SetValuesOperation.prototype.getTextureNames = function () {\n        return ['A', 'Values'];\n    };\n    SetValuesOperation.prototype.calc = function (input) {\n        if (this.fullyStatic && this.outputShape !== undefined) {\n            return this.compute(this.outputShape, { A: input.A, Values: input.Values });\n        }\n        var outputShape = this.getOutputShape(input);\n        return this.compute(outputShape, { A: input.A, Values: input.Values }, { starts: this.pad(input.starts) });\n    };\n    SetValuesOperation.prototype.getOutputShape = function (input) {\n        return input.A.shape;\n    };\n    SetValuesOperation.prototype.compile = function (info, precision) {\n        if (info.shapeA !== undefined) {\n            this.maxRank = info.shapeA.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    SetValuesOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeA: input.A.shape,\n            widthA: input.A.memory.width,\n            heightA: input.A.memory.height,\n            shapeValues: input.Values.shape,\n            widthValues: input.Values.memory.width,\n            heightValues: input.Values.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            starts: input.starts,\n        };\n    };\n    SetValuesOperation.prototype.getInputInfoString = function (input) {\n        return input.A.shape + \"-\" + input.Values.shape + \"-\" + input.starts;\n    };\n    return SetValuesOperation;\n}(Operation));\nexport { SetValuesOperation };\n//# sourceMappingURL=setValues.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes, getSize } from '../../util/shape';\nimport { MatMulOperation } from '../../ops/gpu/matMul/matmul';\nimport { defaultAllocator, gl } from './gl';\nimport { ExpOperation } from '../../ops/gpu/unary/exp';\nimport { ConvBiasOperation, ConvOperation } from '../../ops/gpu/conv/conv';\nimport { AbsOperation } from '../../ops/gpu/unary/abs';\nimport { AddOperation } from '../../ops/gpu/binary/add';\nimport { MultiplyOperation } from '../../ops/gpu/binary/multiply';\nimport { SubtractOperation } from '../../ops/gpu/binary/subtract';\nimport { DivideOperation } from '../../ops/gpu/binary/divide';\nimport { AveragePoolOperation } from '../../ops/gpu/conv/averagePool';\nimport { ReduceMeanOperation } from '../../ops/gpu/pool/reduceMean';\nimport { ReduceMeanSquareOperation } from '../../ops/gpu/pool/reduceMeanSquare';\nimport { SumSquareOperation } from '../../ops/gpu/pool/sumSquare';\nimport { SumOperation } from '../../ops/gpu/pool/sum';\nimport { ProductOperation } from '../../ops/gpu/pool/product';\nimport { MaxOperation } from '../../ops/gpu/pool/max';\nimport { MinOperation } from '../../ops/gpu/pool/min';\nimport { CeilOperation } from '../../ops/gpu/unary/ceil';\nimport { ClipOperation } from '../../ops/gpu/unary/clip';\nimport { FloorOperation } from '../../ops/gpu/unary/floor';\nimport { ConcatOperation } from '../../ops/gpu/util/concat';\nimport { CopyOperation } from '../../ops/gpu/util/copy';\nimport { ExpandOperation } from '../../ops/gpu/util/expand';\nimport { GatherOperation } from '../../ops/gpu/util/gather';\nimport { GemmCOperation, GemmOperation } from '../../ops/gpu/matMul/gemm';\nimport { PowerOperation } from '../../ops/gpu/binary/power';\nimport { SqrtOperation } from '../../ops/gpu/unary/sqrt';\nimport { LogOperation } from '../../ops/gpu/unary/log';\nimport { TransposeOperation } from '../../ops/gpu/util/transpose';\nimport { RepeatOperation } from '../../ops/gpu/util/repeat';\nimport { PadOperation } from '../../ops/gpu/conv/pad';\nimport { SliceOperation } from '../../ops/gpu/util/slice';\nimport { UpsampleOperation } from '../../ops/gpu/conv/upsample';\nimport { NormalizeOperation } from '../../ops/gpu/conv/normalize';\nimport { Dispatcher } from '../../ops/gpu/dispatcher';\nimport { SignOperation } from '../../ops/gpu/unary/sign';\nimport { NegateOperation } from '../../ops/gpu/unary/negate';\nimport { ClipBackwardOperation } from '../../ops/gpu/util/clipBackward';\nimport { ConvTransposeOperation } from '../../ops/gpu/conv/convTranspose';\nimport { SigmoidOperation } from '../../ops/gpu/unary/sigmoid';\nimport { AddMultiplyScalarOperation } from '../../ops/gpu/unary/addMultiplyScalar';\nimport { SetValuesOperation } from '../../ops/gpu/util/setValues';\nvar GPUTensor = /** @class */ (function (_super) {\n    __extends(GPUTensor, _super);\n    function GPUTensor(values, shape, precision) {\n        var _this = _super.call(this) || this;\n        _this.shape = shape;\n        _this.precision = precision;\n        _this.deleted = false;\n        _this.size = getSize(shape);\n        if (values instanceof Float32Array) {\n            _this.memory = defaultAllocator.allocateTexture(values, precision);\n        }\n        else {\n            _this.memory = values;\n        }\n        return _this;\n    }\n    GPUTensor.fromData = function (data, precision) {\n        var texture = gl.texture({\n            data: data,\n            format: 'rgba',\n            type: precision === 32 ? 'float' : 'half float',\n        });\n        var memory = defaultAllocator.allocateFramebuffer(texture, precision);\n        var width = texture.width;\n        var height = texture.height;\n        return new GPUTensor(memory, [height, width, 4], precision);\n    };\n    GPUTensor.prototype.getValues = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            gl({ framebuffer: _this.memory.frameBuffer })(function () {\n                var result = new Float32Array(_this.memory.size);\n                result = gl.read(result);\n                resolve(result.subarray(0, _this.size));\n            });\n        });\n    };\n    GPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    GPUTensor.prototype.gpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    GPUTensor.prototype.constantLike = function (value) {\n        return new GPUTensor(new Float32Array(this.size).fill(value), this.shape, this.precision);\n    };\n    GPUTensor.prototype.singleConstant = function (value) {\n        return new GPUTensor(new Float32Array([value]), [1], this.precision);\n    };\n    GPUTensor.prototype.delete = function () {\n        if (!this.deleted) {\n            this.deleted = true;\n            defaultAllocator.deallocate(this.memory);\n            //@ts-ignore\n            this.memory = undefined;\n        }\n    };\n    GPUTensor.prototype.copy = function (precision) {\n        return defaultCopyD.calc({ input: this }, precision ? precision : this.precision);\n    };\n    GPUTensor.prototype.exp = function () {\n        return defaultExpD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.log = function () {\n        return defaultLogD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.sqrt = function () {\n        return defaultSqrtD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.abs = function () {\n        return defaultAbsD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.sigmoid = function () {\n        return defaultSigmoidD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.floor = function () {\n        return defaultFloorD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.ceil = function () {\n        return defaultCeilD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.negate = function () {\n        return defaultNegateD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.addMultiplyScalar = function (factor, add) {\n        return defaultAddMultiplyScalarD.calc({ input: this, factor: factor, add: add }, this.precision);\n    };\n    GPUTensor.prototype.sign = function () {\n        return defaultSignD.calc({ input: this }, this.precision);\n    };\n    GPUTensor.prototype.setValues = function (values, starts) {\n        if (!(values instanceof GPUTensor)) {\n            throw new Error('Can only set GPU values to GPU tensor');\n        }\n        return defaultSetValuesD.calc({ A: this, Values: values, starts: starts }, this.precision);\n    };\n    GPUTensor.prototype.add_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only add GPU tensor to GPU tensor');\n        }\n        return defaultAddD.calc({ A: th, B: tensor, outputShape: resultShape, alpha: alpha, beta: beta }, this.precision);\n    };\n    GPUTensor.prototype.subtract_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only subtract GPU tensor from GPU tensor');\n        }\n        return defaultSubtractD.calc({ A: th, B: tensor, outputShape: resultShape, alpha: alpha, beta: beta }, this.precision);\n    };\n    GPUTensor.prototype.multiply_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only multiply GPU tensor with GPU tensor');\n        }\n        return defaultMultiplyD.calc({ A: th, B: tensor, outputShape: resultShape, alpha: alpha }, this.precision);\n    };\n    GPUTensor.prototype.divide_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only divide GPU tensor by GPU tensor');\n        }\n        return defaultDivideD.calc({ A: th, B: tensor, outputShape: resultShape, alpha: alpha }, this.precision);\n    };\n    GPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only take GPU tensor to power of GPU tensor');\n        }\n        return defaultPowerD.calc({ A: th, B: tensor, outputShape: resultShape }, this.precision);\n    };\n    GPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only matrix multiply GPU tensor to GPU tensor');\n        }\n        return defaultMatMulD.calc({ A: this, B: tensor }, this.precision);\n    };\n    GPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof GPUTensor && (c === undefined || c instanceof GPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        if (c === undefined) {\n            return defaultGemmD.calc({ a: this, b: b, aTranspose: aTranspose, bTranspose: bTranspose, alpha: alpha, beta: beta }, this.precision);\n        }\n        else {\n            return defaultGemmCD.calc({ a: this, b: b, c: c, aTranspose: aTranspose, bTranspose: bTranspose, alpha: alpha, beta: beta }, this.precision);\n        }\n    };\n    GPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return defaultSumD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return defaultSumSquareD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return defaultMeanD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return defaultMeanSquareD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return defaultProductD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return defaultMaxD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return defaultMinD.calc({ X: this, axes: axes, keepDims: keepDims }, this.precision);\n    };\n    GPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, activation, bias) {\n        if (!(kernel instanceof GPUTensor) ||\n            (bias !== undefined && !(bias instanceof GPUTensor))) {\n            throw new Error('Can only do convolution of GPU tensor with GPU tensor');\n        }\n        if (bias === undefined) {\n            return defaultConvD.calc({\n                X: this,\n                W: kernel,\n                pads: pads,\n                dilations: dilations,\n                strides: strides,\n                activation: activation,\n            }, this.precision);\n        }\n        else {\n            return defaultConvBiasD.calc({\n                X: this,\n                W: kernel,\n                B: bias,\n                pads: pads,\n                dilations: dilations,\n                strides: strides,\n                activation: activation,\n            }, this.precision);\n        }\n    };\n    GPUTensor.prototype.convTranspose_impl = function (kernel, dilations, group, pads, strides) {\n        if (!(kernel instanceof GPUTensor)) {\n            throw new Error('Can only do transpose convolution of GPU tensor with GPU tensor');\n        }\n        return defaultConvTransposeD.calc({\n            X: this,\n            W: kernel,\n            pads: pads,\n            dilations: dilations,\n            strides: strides,\n        }, this.precision);\n    };\n    GPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return defaultAveragePoolD.calc({\n            X: this,\n            includePad: includePad,\n            kernelShape: kernelShape,\n            pads: pads,\n            strides: strides,\n        }, this.precision);\n    };\n    GPUTensor.prototype.reshape_impl = function (shape, _copy) {\n        if (_copy) {\n            return defaultCopyD.calc({ input: this, outputShape: shape }, this.precision);\n        }\n        else {\n            return new GPUTensor(this.memory, shape, this.precision);\n        }\n    };\n    GPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only concat GPU tensor to GPU tensor');\n        }\n        return defaultConcatD.calc({ A: this, B: tensor, axis: axis }, this.precision);\n    };\n    GPUTensor.prototype.transpose_impl = function (permutation) {\n        return defaultTransposeD.calc({ A: this, permutation: permutation }, this.precision);\n    };\n    GPUTensor.prototype.clip = function (min, max) {\n        return defaultClipD.calc({ input: this, minVal: min, maxVal: max }, this.precision);\n    };\n    GPUTensor.prototype.clipBackward = function (grad, min, max) {\n        return defaultClipBackwardD.calc({ input: this, minVal: min, maxVal: max, grad: grad }, this.precision);\n    };\n    GPUTensor.prototype.repeat = function (repeats) {\n        return defaultRepeatD.calc({ A: this, repeats: repeats }, this.precision);\n    };\n    GPUTensor.prototype.expand = function (shape) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], _o = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return defaultExpandD.calc({\n            input: this.reshape(_shape, false),\n            outputShape: resultShape,\n        }, this.precision);\n    };\n    GPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return defaultPadD.calc({ input: this, pads: pads, mode: mode, value: value }, this.precision);\n    };\n    GPUTensor.prototype.gather = function (axis, indices) {\n        return defaultGatherD.calc({ X: this, axis: axis, indices: indices }, this.precision);\n    };\n    GPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return defaultSliceD.calc({ X: this, starts: starts, ends: ends, axes: axes }, this.precision);\n    };\n    GPUTensor.prototype.upsample = function (scales) {\n        return defaultUpsampleD.calc({ X: this, scales: scales }, this.precision);\n    };\n    GPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof GPUTensor) ||\n            !(variance instanceof GPUTensor) ||\n            !(scale instanceof GPUTensor) ||\n            !(bias instanceof GPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return defaultNormalizeD.calc({\n            X: this,\n            Mean: mean,\n            Variance: variance,\n            Scale: scale,\n            Bias: bias,\n            epsilon: epsilon,\n        }, this.precision);\n    };\n    return GPUTensor;\n}(Tensor));\nexport { GPUTensor };\nexport var gpuConstructor = function (a, b, precision) { return new GPUTensor(a, b, precision); };\nvar defaultMatMulD = new Dispatcher(function () { return new MatMulOperation(gpuConstructor); });\nvar defaultGemmD = new Dispatcher(function () { return new GemmOperation(gpuConstructor); });\nvar defaultGemmCD = new Dispatcher(function () { return new GemmCOperation(gpuConstructor); });\n//Unary operations\nvar defaultExpD = new Dispatcher(function () { return new ExpOperation(gpuConstructor); });\nvar defaultAbsD = new Dispatcher(function () { return new AbsOperation(gpuConstructor); });\nvar defaultSigmoidD = new Dispatcher(function () { return new SigmoidOperation(gpuConstructor); });\nvar defaultCeilD = new Dispatcher(function () { return new CeilOperation(gpuConstructor); });\nvar defaultFloorD = new Dispatcher(function () { return new FloorOperation(gpuConstructor); });\nvar defaultClipD = new Dispatcher(function () { return new ClipOperation(gpuConstructor); });\nvar defaultClipBackwardD = new Dispatcher(function () { return new ClipBackwardOperation(gpuConstructor); });\nvar defaultSqrtD = new Dispatcher(function () { return new SqrtOperation(gpuConstructor); });\nvar defaultLogD = new Dispatcher(function () { return new LogOperation(gpuConstructor); });\nvar defaultNegateD = new Dispatcher(function () { return new NegateOperation(gpuConstructor); });\nvar defaultAddMultiplyScalarD = new Dispatcher(function () { return new AddMultiplyScalarOperation(gpuConstructor); });\nvar defaultSignD = new Dispatcher(function () { return new SignOperation(gpuConstructor); });\n//Convolutions\nvar defaultConvD = new Dispatcher(function () { return new ConvOperation(gpuConstructor); });\nvar defaultAveragePoolD = new Dispatcher(function () { return new AveragePoolOperation(gpuConstructor); });\nvar defaultConvBiasD = new Dispatcher(function () { return new ConvBiasOperation(gpuConstructor); });\nvar defaultConvTransposeD = new Dispatcher(function () { return new ConvTransposeOperation(gpuConstructor); });\nvar defaultPadD = new Dispatcher(function () { return new PadOperation(gpuConstructor); });\nvar defaultUpsampleD = new Dispatcher(function () { return new UpsampleOperation(gpuConstructor); });\n//Binary operations\nvar defaultAddD = new Dispatcher(function () { return new AddOperation(gpuConstructor); });\nvar defaultSubtractD = new Dispatcher(function () { return new SubtractOperation(gpuConstructor); });\nvar defaultMultiplyD = new Dispatcher(function () { return new MultiplyOperation(gpuConstructor); });\nvar defaultDivideD = new Dispatcher(function () { return new DivideOperation(gpuConstructor); });\nvar defaultPowerD = new Dispatcher(function () { return new PowerOperation(gpuConstructor); });\n//Reductions\nvar defaultMeanD = new Dispatcher(function () { return new ReduceMeanOperation(gpuConstructor); });\nvar defaultMeanSquareD = new Dispatcher(function () { return new ReduceMeanSquareOperation(gpuConstructor); });\nvar defaultSumSquareD = new Dispatcher(function () { return new SumSquareOperation(gpuConstructor); });\nvar defaultSumD = new Dispatcher(function () { return new SumOperation(gpuConstructor); });\nvar defaultProductD = new Dispatcher(function () { return new ProductOperation(gpuConstructor); });\nvar defaultMaxD = new Dispatcher(function () { return new MaxOperation(gpuConstructor); });\nvar defaultMinD = new Dispatcher(function () { return new MinOperation(gpuConstructor); });\n//Util\nvar defaultConcatD = new Dispatcher(function () { return new ConcatOperation(gpuConstructor); });\nvar defaultSetValuesD = new Dispatcher(function () { return new SetValuesOperation(gpuConstructor); });\nvar defaultCopyD = new Dispatcher(function () { return new CopyOperation(gpuConstructor); });\nvar defaultExpandD = new Dispatcher(function () { return new ExpandOperation(gpuConstructor); });\nvar defaultGatherD = new Dispatcher(function () { return new GatherOperation(gpuConstructor); });\nvar defaultTransposeD = new Dispatcher(function () { return new TransposeOperation(gpuConstructor); });\nvar defaultRepeatD = new Dispatcher(function () { return new RepeatOperation(gpuConstructor); });\nvar defaultSliceD = new Dispatcher(function () { return new SliceOperation(gpuConstructor); });\nvar defaultNormalizeD = new Dispatcher(function () { return new NormalizeOperation(gpuConstructor); });\n//# sourceMappingURL=tensor.js.map","var AbsBack = /** @class */ (function () {\n    function AbsBack(input) {\n        this.input = input;\n    }\n    AbsBack.prototype.backward = function (grad) {\n        var sign = this.input.value.sign();\n        var gradAbs = grad.multiply(sign);\n        sign.delete();\n        var needed = this.input.backward(gradAbs);\n        if (!needed) {\n            gradAbs.delete();\n        }\n    };\n    AbsBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return AbsBack;\n}());\nexport { AbsBack };\n//# sourceMappingURL=absBack.js.map","var ExpBack = /** @class */ (function () {\n    function ExpBack(input, exp) {\n        this.input = input;\n        this.exp = exp;\n    }\n    ExpBack.prototype.backward = function (grad) {\n        var gradExp = grad.multiply(this.exp);\n        var needed = this.input.backward(gradExp);\n        if (!needed) {\n            gradExp.delete();\n        }\n    };\n    ExpBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return ExpBack;\n}());\nexport { ExpBack };\n//# sourceMappingURL=expBack.js.map","var LogBack = /** @class */ (function () {\n    function LogBack(input) {\n        this.input = input;\n    }\n    LogBack.prototype.backward = function (grad) {\n        var gradLog = grad.divide(this.input.value);\n        var needed = this.input.backward(gradLog);\n        if (!needed) {\n            gradLog.delete();\n        }\n    };\n    LogBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return LogBack;\n}());\nexport { LogBack };\n//# sourceMappingURL=logBack.js.map","var MatMulBack = /** @class */ (function () {\n    function MatMulBack(a, b) {\n        this.a = a;\n        this.b = b;\n    }\n    MatMulBack.prototype.backward = function (grad) {\n        if (!this.b.noGrad) {\n            var gradB = this.a.value.gemm(grad, true, false);\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = grad.gemm(this.b.value, false, true);\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n    };\n    MatMulBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return MatMulBack;\n}());\nexport { MatMulBack };\n//# sourceMappingURL=matMulBack.js.map","var NegateBack = /** @class */ (function () {\n    function NegateBack(input) {\n        this.input = input;\n    }\n    NegateBack.prototype.backward = function (grad) {\n        var gradIn = grad.negate();\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    NegateBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return NegateBack;\n}());\nexport { NegateBack };\n//# sourceMappingURL=negateBack.js.map","var SqrtBack = /** @class */ (function () {\n    function SqrtBack(input, sqrt) {\n        this.input = input;\n        this.sqrt = sqrt;\n    }\n    SqrtBack.prototype.backward = function (grad) {\n        var gradSqrt = grad.divide(this.sqrt, 0.5);\n        var needed = this.input.backward(gradSqrt);\n        if (!needed) {\n            gradSqrt.delete();\n        }\n    };\n    SqrtBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return SqrtBack;\n}());\nexport { SqrtBack };\n//# sourceMappingURL=sqrtBack.js.map","var ConcatBack = /** @class */ (function () {\n    function ConcatBack(a, b, axis) {\n        this.a = a;\n        this.b = b;\n        this.axis = axis;\n    }\n    ConcatBack.prototype.backward = function (grad) {\n        if (!this.a.noGrad) {\n            var gradA = grad.slice([0], [this.a.getShape()[this.axis]], [this.axis]);\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = grad.slice([this.a.getShape()[this.axis]], [grad.getShape()[this.axis]], [this.axis]);\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    ConcatBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return ConcatBack;\n}());\nexport { ConcatBack };\n//# sourceMappingURL=concatBack.js.map","var ClipBack = /** @class */ (function () {\n    function ClipBack(input, min, max) {\n        this.input = input;\n        this.min = min;\n        this.max = max;\n    }\n    ClipBack.prototype.backward = function (grad) {\n        var gradIn = this.input.value.clipBackward(grad, this.min, this.max);\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    ClipBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return ClipBack;\n}());\nexport { ClipBack };\n//# sourceMappingURL=clipBack.js.map","var RepeatBack = /** @class */ (function () {\n    function RepeatBack(a, repeats) {\n        this.a = a;\n        this.repeats = repeats;\n    }\n    RepeatBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var gradNewShape = [];\n        var sumAxes = [];\n        for (var i = 0; i < shapeA.length; i++) {\n            gradNewShape.push(this.repeats[i], shapeA[i]);\n            sumAxes.push(i * 2);\n        }\n        var gradA = grad.reshape(gradNewShape, false).sum(sumAxes, false);\n        var needed = this.a.backward(gradA);\n        if (!needed) {\n            gradA.delete();\n        }\n    };\n    RepeatBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n    };\n    return RepeatBack;\n}());\nexport { RepeatBack };\n//# sourceMappingURL=repeatBack.js.map","var ExpandBack = /** @class */ (function () {\n    function ExpandBack(a, shape) {\n        this.a = a;\n        this.shape = shape;\n    }\n    ExpandBack.prototype.backward = function (grad) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _a = this.a.value.alignShapes(this.a.getShape(), this.shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        var sumDims = [];\n        for (var i = 0; i < _shape.length; i++) {\n            if (_shape[i] < goal[i]) {\n                sumDims.push(i);\n            }\n        }\n        var gradA = grad.sum(sumDims).reshape(this.a.getShape());\n        var needed = this.a.backward(gradA);\n        if (!needed) {\n            gradA.delete();\n        }\n    };\n    ExpandBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n    };\n    return ExpandBack;\n}());\nexport { ExpandBack };\n//# sourceMappingURL=expandBack.js.map","var ReshapeBack = /** @class */ (function () {\n    function ReshapeBack(a) {\n        this.a = a;\n    }\n    ReshapeBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        if (!this.a.noGrad) {\n            var gradA = grad.reshape(shapeA);\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n    };\n    ReshapeBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n    };\n    return ReshapeBack;\n}());\nexport { ReshapeBack };\n//# sourceMappingURL=reshapeBack.js.map","var AddBack = /** @class */ (function () {\n    function AddBack(a, b, shape, alpha, beta) {\n        this.a = a;\n        this.b = b;\n        this.shape = shape;\n        this.alpha = alpha;\n        this.beta = beta;\n    }\n    AddBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var shapeB = this.b.getShape();\n        var sumADims = [];\n        var sumBDims = [];\n        for (var i = 0; i < this.shape.length; i++) {\n            if (shapeA[i] < this.shape[i]) {\n                sumADims.push(i);\n            }\n            if (shapeB[i] < this.shape[i]) {\n                sumBDims.push(i);\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (sumADims.length === 0) {\n                if (this.alpha === 1) {\n                    gradA = grad.reshape(shapeA);\n                }\n                else {\n                    gradA = grad.multiplyScalar(this.alpha).reshape(shapeA, false);\n                }\n            }\n            else {\n                if (this.alpha === 1) {\n                    gradA = grad.sum(sumADims).reshape(shapeA, false);\n                }\n                else {\n                    var summed = grad.sum(sumADims);\n                    var scaled = summed.multiplyScalar(this.alpha);\n                    summed.delete();\n                    gradA = scaled.reshape(shapeA, false);\n                }\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (sumBDims.length === 0) {\n                if (this.beta === 1) {\n                    gradB = grad.reshape(shapeB);\n                }\n                else {\n                    gradB = grad.multiplyScalar(this.beta).reshape(shapeB, false);\n                }\n            }\n            else {\n                if (this.beta === 1) {\n                    gradB = grad.sum(sumBDims).reshape(shapeB, false);\n                }\n                else {\n                    var summed = grad.sum(sumBDims);\n                    var scaled = summed.multiplyScalar(this.beta);\n                    summed.delete();\n                    gradB = scaled.reshape(shapeB, false);\n                }\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    AddBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return AddBack;\n}());\nexport { AddBack };\n//# sourceMappingURL=addBack.js.map","var SubtractBack = /** @class */ (function () {\n    function SubtractBack(a, b, shape, alpha, beta) {\n        this.a = a;\n        this.b = b;\n        this.shape = shape;\n        this.alpha = alpha;\n        this.beta = beta;\n    }\n    SubtractBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var shapeB = this.b.getShape();\n        var sumADims = [];\n        var sumBDims = [];\n        for (var i = 0; i < this.shape.length; i++) {\n            if (shapeA[i] < this.shape[i]) {\n                sumADims.push(i);\n            }\n            if (shapeB[i] < this.shape[i]) {\n                sumBDims.push(i);\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (sumADims.length === 0) {\n                if (this.alpha === 1) {\n                    gradA = grad.reshape(shapeA);\n                }\n                else {\n                    gradA = grad.multiplyScalar(this.alpha).reshape(shapeA, false);\n                }\n            }\n            else {\n                if (this.alpha === 1) {\n                    gradA = grad.sum(sumADims).reshape(shapeA, false);\n                }\n                else {\n                    var summed = grad.sum(sumADims);\n                    var scaled = summed.multiplyScalar(this.alpha);\n                    summed.delete();\n                    gradA = scaled.reshape(shapeA, false);\n                }\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (sumBDims.length === 0) {\n                gradB = grad.multiplyScalar(-this.beta).reshape(shapeB, false);\n            }\n            else {\n                var summed = grad.sum(sumBDims);\n                var scaled = summed.multiplyScalar(-this.beta);\n                summed.delete();\n                gradB = scaled.reshape(shapeB, false);\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    SubtractBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return SubtractBack;\n}());\nexport { SubtractBack };\n//# sourceMappingURL=subtractBack.js.map","var MultiplyBack = /** @class */ (function () {\n    function MultiplyBack(a, b, shape, alpha) {\n        this.a = a;\n        this.b = b;\n        this.shape = shape;\n        this.alpha = alpha;\n    }\n    MultiplyBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var shapeB = this.b.getShape();\n        var sumADims = [];\n        var sumBDims = [];\n        for (var i = 0; i < this.shape.length; i++) {\n            if (shapeA[i] < this.shape[i]) {\n                sumADims.push(i);\n            }\n            if (shapeB[i] < this.shape[i]) {\n                sumBDims.push(i);\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (sumADims.length === 0) {\n                gradA = grad.multiply(this.b.value, this.alpha).reshape(shapeA, false);\n            }\n            else {\n                var mult = grad.multiply(this.b.value, this.alpha);\n                var summed = mult.sum(sumADims);\n                mult.delete();\n                gradA = summed.reshape(shapeA, false);\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (sumBDims.length === 0) {\n                gradB = grad.multiply(this.a.value, this.alpha).reshape(shapeB, false);\n            }\n            else {\n                var mult = grad.multiply(this.a.value, this.alpha);\n                var summed = mult.sum(sumBDims);\n                mult.delete();\n                gradB = summed.reshape(shapeB, false);\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    MultiplyBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return MultiplyBack;\n}());\nexport { MultiplyBack };\n//# sourceMappingURL=multiplyBack.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar ConvBack = /** @class */ (function () {\n    function ConvBack(x, w, strides, padding, dilations, group, b) {\n        this.x = x;\n        this.w = w;\n        this.strides = strides;\n        this.padding = padding;\n        this.dilations = dilations;\n        this.group = group;\n        this.b = b;\n    }\n    ConvBack.prototype.backward = function (grad) {\n        if (!this.w.noGrad) {\n            var gradW = this.x.value.conv(grad, undefined, this.strides, this.group, this.padding, this.dilations);\n            var needed = this.w.backward(gradW);\n            if (!needed) {\n                gradW.delete();\n            }\n        }\n        if (this.b !== undefined && !this.b.noGrad) {\n            var biasSum = [0];\n            for (var i = 0; i < this.dilations.length; i++) {\n                biasSum.push(i + 2);\n            }\n            var gradB = grad.sum(biasSum);\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n        if (!this.x.noGrad) {\n            var wShape = this.w.getShape();\n            var xPads = [];\n            for (var i = 0; i < this.dilations.length; i++) {\n                xPads.push(wShape[i + 2] - this.padding[i] + this.dilations[i] - 2);\n            }\n            xPads = __spreadArrays(xPads, xPads);\n            var gradX = grad.convTranspose(this.w.value, this.dilations, this.group, xPads, this.strides);\n            var needed = this.x.backward(gradX);\n            if (!needed) {\n                gradX.delete();\n            }\n        }\n    };\n    ConvBack.prototype.delete = function () {\n        if (!this.x.isLeaf()) {\n            this.x.delete();\n        }\n        if (!this.w.isLeaf()) {\n            this.w.delete();\n        }\n        if (this.b !== undefined && !this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return ConvBack;\n}());\nexport { ConvBack };\n//# sourceMappingURL=convBack.js.map","var DivideBack = /** @class */ (function () {\n    function DivideBack(a, b, divResult, shape, alpha) {\n        this.a = a;\n        this.b = b;\n        this.divResult = divResult;\n        this.shape = shape;\n        this.alpha = alpha;\n    }\n    DivideBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var shapeB = this.b.getShape();\n        var sumADims = [];\n        var sumBDims = [];\n        for (var i = 0; i < this.shape.length; i++) {\n            if (shapeA[i] < this.shape[i]) {\n                sumADims.push(i);\n            }\n            if (shapeB[i] < this.shape[i]) {\n                sumBDims.push(i);\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (sumADims.length === 0) {\n                gradA = grad.divide(this.b.value, this.alpha).reshape(shapeA, false);\n            }\n            else {\n                var mult = grad.divide(this.b.value, this.alpha);\n                var summed = mult.sum(sumADims);\n                mult.delete();\n                gradA = summed.reshape(shapeA, false);\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (sumBDims.length === 0) {\n                var multiplied = grad.multiply(this.divResult);\n                var divided = multiplied.divide(this.b.value, -this.alpha);\n                multiplied.delete();\n                gradB = divided.reshape(shapeB, false);\n            }\n            else {\n                var multiplied = grad.multiply(this.divResult);\n                var divided = multiplied.divide(this.b.value, -this.alpha);\n                multiplied.delete();\n                var summed = divided.sum(sumBDims);\n                divided.delete();\n                gradB = summed.reshape(shapeB, false);\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    DivideBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return DivideBack;\n}());\nexport { DivideBack };\n//# sourceMappingURL=divideBack.js.map","var PowerBack = /** @class */ (function () {\n    function PowerBack(a, b, powerResult, shape) {\n        this.a = a;\n        this.b = b;\n        this.powerResult = powerResult;\n        this.shape = shape;\n    }\n    PowerBack.prototype.backward = function (grad) {\n        var shapeA = this.a.getShape();\n        var shapeB = this.b.getShape();\n        var sumADims = [];\n        var sumBDims = [];\n        for (var i = 0; i < this.shape.length; i++) {\n            if (shapeA[i] < this.shape[i]) {\n                sumADims.push(i);\n            }\n            if (shapeB[i] < this.shape[i]) {\n                sumBDims.push(i);\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (sumADims.length === 0) {\n                var multiplied = this.powerResult.multiply(this.b.value);\n                var divided = multiplied.divide(this.a.value);\n                multiplied.delete();\n                var gradPowA = grad.multiply(divided);\n                divided.delete();\n                gradA = gradPowA.reshape(shapeA, false);\n            }\n            else {\n                var multiplied = this.powerResult.multiply(this.b.value);\n                var divided = multiplied.divide(this.a.value);\n                multiplied.delete();\n                var gradPowA = grad.multiply(divided);\n                divided.delete();\n                var summed = gradPowA.sum(sumADims);\n                gradPowA.delete();\n                gradA = summed.reshape(shapeA, false);\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (sumBDims.length === 0) {\n                var lnA = this.a.value.log();\n                var mult = this.powerResult.multiply(lnA);\n                lnA.delete();\n                gradB = grad.multiply(mult);\n                mult.delete();\n                gradB = gradB.reshape(shapeB, false);\n            }\n            else {\n                var lnA = this.a.value.log();\n                var mult = this.powerResult.multiply(lnA);\n                lnA.delete();\n                var _gradB = grad.multiply(mult);\n                mult.delete();\n                var summed = _gradB.sum(sumBDims);\n                _gradB.delete();\n                gradB = summed.reshape(shapeB, false);\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n    };\n    PowerBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n    };\n    return PowerBack;\n}());\nexport { PowerBack };\n//# sourceMappingURL=powerBack.js.map","var GemmBack = /** @class */ (function () {\n    function GemmBack(a, b, transA, transB, alpha, beta, c) {\n        this.a = a;\n        this.b = b;\n        this.transA = transA;\n        this.transB = transB;\n        this.alpha = alpha;\n        this.beta = beta;\n        this.c = c;\n    }\n    GemmBack.prototype.backward = function (grad) {\n        if (!this.b.noGrad) {\n            var gradB = void 0;\n            if (this.transB) {\n                gradB = grad.gemm(this.a.value, true, this.transA, this.alpha);\n            }\n            else {\n                gradB = this.a.value.gemm(grad, !this.transA, false, this.alpha);\n            }\n            var needed = this.b.backward(gradB);\n            if (!needed) {\n                gradB.delete();\n            }\n        }\n        if (!this.a.noGrad) {\n            var gradA = void 0;\n            if (this.transA) {\n                gradA = this.b.value.gemm(grad, this.transB, true, this.alpha);\n            }\n            else {\n                gradA = grad.gemm(this.b.value, false, !this.transB, this.alpha);\n            }\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n        if (this.c !== undefined && !this.c.noGrad) {\n            var gradShape = grad.getShape();\n            var cShape = this.c.getShape();\n            var cSumDims = [];\n            for (var i = 0; i < gradShape.length; i++) {\n                if (cShape[i] < gradShape[i]) {\n                    cSumDims.push(i);\n                }\n            }\n            var gradC = grad.sum(cSumDims).reshape(cShape, false);\n            if (this.beta !== 1) {\n                var oldGradC = gradC;\n                gradC = gradC.multiplyScalar(this.beta);\n                oldGradC.delete();\n            }\n            var needed = this.c.backward(gradC);\n            if (!needed) {\n                gradC.delete();\n            }\n        }\n    };\n    GemmBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n        if (!this.b.isLeaf()) {\n            this.b.delete();\n        }\n        if (this.c !== undefined && !this.c.isLeaf()) {\n            this.c.delete();\n        }\n    };\n    return GemmBack;\n}());\nexport { GemmBack };\n//# sourceMappingURL=gemmBack.js.map","var TransposeBack = /** @class */ (function () {\n    function TransposeBack(a, permutation) {\n        this.a = a;\n        this.permutation = permutation;\n    }\n    TransposeBack.prototype.backward = function (grad) {\n        var inversePerm = new Array(this.permutation.length);\n        for (var i = 0; i < this.permutation.length; i++) {\n            inversePerm[this.permutation[i]] = i;\n        }\n        var gradA = grad.transpose(inversePerm);\n        var needed = this.a.backward(gradA);\n        if (!needed) {\n            gradA.delete();\n        }\n    };\n    TransposeBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n    };\n    return TransposeBack;\n}());\nexport { TransposeBack };\n//# sourceMappingURL=transposeBack.js.map","var SumBack = /** @class */ (function () {\n    function SumBack(input, sumDims, keepDims) {\n        this.input = input;\n        this.sumDims = sumDims;\n        this.keepDims = keepDims;\n    }\n    SumBack.prototype.backward = function (grad) {\n        var inShape = this.input.value.getShape();\n        if (!this.keepDims) {\n            var newShape = [];\n            var sumI = 0;\n            for (var i = 0; i < inShape.length; i++) {\n                if (sumI < this.sumDims.length && this.sumDims[sumI] === i) {\n                    newShape.push(1);\n                    sumI++;\n                }\n                else {\n                    newShape.push(inShape[i]);\n                }\n            }\n            grad = grad.reshape(newShape, false);\n        }\n        grad = grad.expand(inShape);\n        var needed = this.input.backward(grad);\n        if (!needed) {\n            grad.delete();\n        }\n    };\n    SumBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return SumBack;\n}());\nexport { SumBack };\n//# sourceMappingURL=sumBack.js.map","var SumSquareBack = /** @class */ (function () {\n    function SumSquareBack(input, sumDims, keepDims) {\n        this.input = input;\n        this.sumDims = sumDims;\n        this.keepDims = keepDims;\n    }\n    SumSquareBack.prototype.backward = function (grad) {\n        var inShape = this.input.value.getShape();\n        if (!this.keepDims) {\n            var newShape = [];\n            var sumI = 0;\n            for (var i = 0; i < inShape.length; i++) {\n                if (sumI < this.sumDims.length && this.sumDims[sumI] === i) {\n                    newShape.push(1);\n                    sumI++;\n                }\n                else {\n                    newShape.push(inShape[i]);\n                }\n            }\n            grad = grad.reshape(newShape, false);\n        }\n        var expanded = grad.expand(inShape);\n        var gradIn = expanded.multiply(this.input.value, 2);\n        expanded.delete();\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    SumSquareBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return SumSquareBack;\n}());\nexport { SumSquareBack };\n//# sourceMappingURL=sumSquareBack.js.map","var AddMultiplyScalarBack = /** @class */ (function () {\n    function AddMultiplyScalarBack(input, scalar) {\n        this.input = input;\n        this.scalar = scalar;\n    }\n    AddMultiplyScalarBack.prototype.backward = function (grad) {\n        var gradIn = grad.multiplyScalar(this.scalar);\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    AddMultiplyScalarBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return AddMultiplyScalarBack;\n}());\nexport { AddMultiplyScalarBack };\n//# sourceMappingURL=addMultiplyScalarBack.js.map","var MeanBack = /** @class */ (function () {\n    function MeanBack(input, sumDims, keepDims) {\n        this.input = input;\n        this.sumDims = sumDims;\n        this.keepDims = keepDims;\n    }\n    MeanBack.prototype.backward = function (grad) {\n        var inShape = this.input.value.getShape();\n        if (!this.keepDims) {\n            var newShape = [];\n            var sumI = 0;\n            for (var i = 0; i < inShape.length; i++) {\n                if (sumI < this.sumDims.length && this.sumDims[sumI] === i) {\n                    newShape.push(1);\n                    sumI++;\n                }\n                else {\n                    newShape.push(inShape[i]);\n                }\n            }\n            grad = grad.reshape(newShape, false);\n        }\n        var sumSize = 1;\n        for (var i = 0; i < this.sumDims.length; i++) {\n            sumSize *= inShape[this.sumDims[i]];\n        }\n        var multiplied = grad.multiplyScalar(1 / sumSize);\n        var gradIn = multiplied.expand(inShape);\n        multiplied.delete;\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            grad.delete();\n        }\n    };\n    MeanBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return MeanBack;\n}());\nexport { MeanBack };\n//# sourceMappingURL=meanBack.js.map","var MeanSquareBack = /** @class */ (function () {\n    function MeanSquareBack(input, sumDims, keepDims) {\n        this.input = input;\n        this.sumDims = sumDims;\n        this.keepDims = keepDims;\n    }\n    MeanSquareBack.prototype.backward = function (grad) {\n        var inShape = this.input.value.getShape();\n        if (!this.keepDims) {\n            var newShape = [];\n            var sumI = 0;\n            for (var i = 0; i < inShape.length; i++) {\n                if (sumI < this.sumDims.length && this.sumDims[sumI] === i) {\n                    newShape.push(1);\n                    sumI++;\n                }\n                else {\n                    newShape.push(inShape[i]);\n                }\n            }\n            grad = grad.reshape(newShape, false);\n        }\n        var sumSize = 1;\n        for (var i = 0; i < this.sumDims.length; i++) {\n            sumSize *= inShape[this.sumDims[i]];\n        }\n        var expanded = grad.expand(inShape);\n        var gradIn = expanded.multiply(this.input.value, 2 / sumSize);\n        expanded.delete();\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    MeanSquareBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return MeanSquareBack;\n}());\nexport { MeanSquareBack };\n//# sourceMappingURL=meanSquareBack.js.map","var SliceBack = /** @class */ (function () {\n    function SliceBack(a, starts, ends, axes) {\n        this.a = a;\n        this.starts = starts;\n        this.ends = ends;\n        this.axes = axes;\n    }\n    SliceBack.prototype.backward = function (grad) {\n        if (!this.a.noGrad) {\n            var shapeA = this.a.getShape();\n            var rank = shapeA.length;\n            var pads = new Array(rank * 2).fill(0);\n            for (var i = 0; i < this.axes.length; i++) {\n                pads[this.axes[i]] = this.starts[i];\n                pads[rank + this.axes[i]] = shapeA[this.axes[i]] - this.ends[i];\n            }\n            var gradA = grad.pad(pads, 'constant', 0);\n            var needed = this.a.backward(gradA);\n            if (!needed) {\n                gradA.delete();\n            }\n        }\n    };\n    SliceBack.prototype.delete = function () {\n        if (!this.a.isLeaf()) {\n            this.a.delete();\n        }\n    };\n    return SliceBack;\n}());\nexport { SliceBack };\n//# sourceMappingURL=sliceBack.js.map","var AveragePoolBack = /** @class */ (function () {\n    function AveragePoolBack(x, kernelShape, pads, strides, includePad) {\n        this.x = x;\n    }\n    AveragePoolBack.prototype.backward = function (grad) {\n        throw new Error('Backward pass not implemented for average pool');\n    };\n    AveragePoolBack.prototype.delete = function () {\n        if (!this.x.isLeaf()) {\n            this.x.delete();\n        }\n    };\n    return AveragePoolBack;\n}());\nexport { AveragePoolBack };\n//# sourceMappingURL=averagePoolBack.js.map","var PadBack = /** @class */ (function () {\n    function PadBack(x, pads, mode, value) {\n        this.x = x;\n        this.pads = pads;\n        this.mode = mode;\n        this.value = value;\n    }\n    PadBack.prototype.backward = function (grad) {\n        throw new Error('Backward pass not implemented for pad');\n    };\n    PadBack.prototype.delete = function () {\n        if (!this.x.isLeaf()) {\n            this.x.delete();\n        }\n    };\n    return PadBack;\n}());\nexport { PadBack };\n//# sourceMappingURL=padBack.js.map","var ProductBack = /** @class */ (function () {\n    function ProductBack(input, product, sumDims, keepDims) {\n        this.input = input;\n        this.product = product;\n        this.sumDims = sumDims;\n        this.keepDims = keepDims;\n    }\n    ProductBack.prototype.backward = function (grad) {\n        var inShape = this.input.value.getShape();\n        var mult = grad.multiply(this.product);\n        if (!this.keepDims) {\n            var newShape = [];\n            var sumI = 0;\n            for (var i = 0; i < inShape.length; i++) {\n                if (sumI < this.sumDims.length && this.sumDims[sumI] === i) {\n                    newShape.push(1);\n                    sumI++;\n                }\n                else {\n                    newShape.push(inShape[i]);\n                }\n            }\n            mult = mult.reshape(newShape, false);\n        }\n        var expanded = mult.expand(inShape);\n        mult.delete();\n        var gradIn = expanded.divide(this.input.value);\n        expanded.delete();\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    ProductBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return ProductBack;\n}());\nexport { ProductBack };\n//# sourceMappingURL=productBack.js.map","var SigmoidBack = /** @class */ (function () {\n    function SigmoidBack(input, sigmoid) {\n        this.input = input;\n        this.sigmoid = sigmoid;\n    }\n    SigmoidBack.prototype.backward = function (grad) {\n        var oneMinus = this.sigmoid.addMultiplyScalar(-1, 1);\n        var mult = this.sigmoid.multiply(oneMinus);\n        oneMinus.delete();\n        var gradIn = mult.multiply(grad);\n        mult.delete();\n        var needed = this.input.backward(gradIn);\n        if (!needed) {\n            gradIn.delete();\n        }\n    };\n    SigmoidBack.prototype.delete = function () {\n        if (!this.input.isLeaf()) {\n            this.input.delete();\n        }\n    };\n    return SigmoidBack;\n}());\nexport { SigmoidBack };\n//# sourceMappingURL=sigmoidBack.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Tensor } from '../library';\nimport { CPUTensor } from '../tensor/cpu/tensor';\nimport { AbsBack } from './ops/unary/absBack';\nimport { ExpBack } from './ops/unary/expBack';\nimport { LogBack } from './ops/unary/logBack';\nimport { MatMulBack } from './ops/matMul/matMulBack';\nimport { NegateBack } from './ops/unary/negateBack';\nimport { SqrtBack } from './ops/unary/sqrtBack';\nimport { ConcatBack } from './ops/util/concatBack';\nimport { ClipBack } from './ops/unary/clipBack';\nimport { RepeatBack } from './ops/util/repeatBack';\nimport { ExpandBack } from './ops/util/expandBack';\nimport { ReshapeBack } from './ops/util/reshapeBack';\nimport { AddBack } from './ops/binary/addBack';\nimport { SubtractBack } from './ops/binary/subtractBack';\nimport { MultiplyBack } from './ops/binary/multiplyBack';\nimport { ConvBack } from './ops/conv/convBack';\nimport { DivideBack } from './ops/binary/divideBack';\nimport { PowerBack } from './ops/binary/powerBack';\nimport { GemmBack } from './ops/matMul/gemmBack';\nimport { TransposeBack } from './ops/util/transposeBack';\nimport { SumBack } from './ops/reduce/sumBack';\nimport { SumSquareBack } from './ops/reduce/sumSquareBack';\nimport { AddMultiplyScalarBack } from './ops/unary/addMultiplyScalarBack';\nimport { MeanBack } from './ops/reduce/meanBack';\nimport { MeanSquareBack } from './ops/reduce/meanSquareBack';\nimport { SliceBack } from './ops/util/sliceBack';\nimport { AveragePoolBack } from './ops/conv/averagePoolBack';\nimport { PadBack } from './ops/conv/padBack';\nimport { ProductBack } from './ops/reduce/productBack';\nimport { SigmoidBack } from './ops/unary/sigmoidBack';\nimport { WASMTensor } from '../tensor/wasm/tensor';\nimport { GPUTensor } from '../tensor/gpu/tensor';\n/**\n * Tensor that also has a gradient associated to it\n * When noGrad is false, a dynamic computation graph on\n * this variable will be build.\n *\n * Once backward on a scalar variable (eg. a variable with shape [1])\n * is called, the gradients for all variables will be computed\n */\nvar Variable = /** @class */ (function (_super) {\n    __extends(Variable, _super);\n    /**\n     * Creates a variable whose value is the specified value\n     */\n    function Variable(value, options) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        if (options === undefined) {\n            options = {};\n        }\n        _this.grad = options.grad;\n        if (options.backEdge !== undefined) {\n            _this.backEdge = options.backEdge;\n        }\n        _this.noGrad = options.noGrad || false;\n        return _this;\n    }\n    Variable.create = function (shape, values, backend, options, precision) {\n        var value;\n        if (backend === 'CPU') {\n            value = new CPUTensor(shape, values);\n        }\n        else if (backend === 'WASM') {\n            if (!(values instanceof Float32Array)) {\n                values = Float32Array.from(values);\n            }\n            value = new WASMTensor(values, new Uint32Array(shape));\n        }\n        else {\n            if (!(values instanceof Float32Array)) {\n                values = Float32Array.from(values);\n            }\n            value = new GPUTensor(values, shape, precision === undefined ? 32 : precision);\n        }\n        return new Variable(value, options);\n    };\n    /**\n     * Creates a GPU variable from texture data (eg. Image/Video element)\n     */\n    Variable.fromData = function (data, options, precision) {\n        var tensor = GPUTensor.fromData(data, precision === undefined ? 32 : precision);\n        return new Variable(tensor, options);\n    };\n    /**\n     * Performs a backward pass and returns wether the grad is needed or can be deleted\n     */\n    Variable.prototype.backward = function (grad) {\n        if (grad === undefined) {\n            var ownShape = this.value.getShape();\n            if (ownShape.length === 1 && ownShape[0] === 1) {\n                grad = this.value;\n            }\n            else {\n                throw new Error('Backward without an input gradient can only be done for tensors with shape [1]');\n            }\n        }\n        var needed = false;\n        if (this.grad !== undefined) {\n            var oldGrad = this.grad;\n            this.grad = this.grad.add(grad);\n            oldGrad.delete();\n        }\n        else {\n            this.grad = grad;\n            needed = true;\n        }\n        if (this.backEdge !== undefined) {\n            this.backEdge.backward(grad);\n        }\n        return needed;\n    };\n    Variable.prototype.isLeaf = function () {\n        return this.backEdge === undefined;\n    };\n    Variable.prototype.constantLike = function (value) {\n        return new Variable(this.value.constantLike(value), { noGrad: true });\n    };\n    Variable.prototype.singleConstant = function (value) {\n        return new Variable(this.value.singleConstant(value), { noGrad: true });\n    };\n    Variable.prototype.getValues = function () {\n        return this.value.getValues();\n    };\n    Variable.prototype.getShape = function () {\n        return this.value.getShape();\n    };\n    Variable.prototype.delete = function () {\n        this.value.delete();\n        if (this.grad !== undefined) {\n            this.grad.delete();\n        }\n        if (this.backEdge !== undefined) {\n            this.backEdge.delete();\n        }\n    };\n    Variable.prototype.reshape_impl = function (shape, copy) {\n        return new Variable(this.value.reshape(shape), {\n            backEdge: this.noGrad ? undefined : new ReshapeBack(this),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.exp = function () {\n        var exp = this.value.exp();\n        return new Variable(exp, {\n            backEdge: this.noGrad ? undefined : new ExpBack(this, exp),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.log = function () {\n        return new Variable(this.value.log(), {\n            backEdge: this.noGrad ? undefined : new LogBack(this),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.sqrt = function () {\n        var sqrt = this.value.sqrt();\n        return new Variable(sqrt, {\n            backEdge: this.noGrad ? undefined : new SqrtBack(this, sqrt),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.abs = function () {\n        return new Variable(this.value.abs(), {\n            backEdge: this.noGrad ? undefined : new AbsBack(this),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.sigmoid = function () {\n        var sigmoid = this.value.sigmoid();\n        return new Variable(sigmoid, {\n            backEdge: this.noGrad ? undefined : new SigmoidBack(this, sigmoid),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.sign = function () {\n        // No back edge since the gradient will be zero anyway\n        return new Variable(this.value.sqrt());\n    };\n    Variable.prototype.negate = function () {\n        return new Variable(this.value.negate(), {\n            backEdge: this.noGrad ? undefined : new NegateBack(this),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.addMultiplyScalar = function (factor, add) {\n        return new Variable(this.value.addMultiplyScalar(factor, add), {\n            backEdge: this.noGrad\n                ? undefined\n                : new AddMultiplyScalarBack(this, factor),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.setValues = function (values, starts) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof Variable)) {\n            throw new Error('MatMul can only be done with another variable');\n        }\n        var noGrad = this.noGrad && tensor.noGrad;\n        return new Variable(this.value.matMul(tensor.value), {\n            backEdge: noGrad ? undefined : new MatMulBack(this, tensor),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof Variable)) {\n            throw new Error('Concat can only be done with another variable');\n        }\n        var noGrad = this.noGrad && tensor.noGrad;\n        return new Variable(this.value.concat(tensor.value, axis), {\n            backEdge: noGrad ? undefined : new ConcatBack(this, tensor, axis),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.clip = function (min, max) {\n        return new Variable(this.value.clip(min, max), {\n            backEdge: this.noGrad ? undefined : new ClipBack(this, min, max),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.clipBackward = function (grad, min, max) {\n        throw new Error('Clip backward not implemented for Variable');\n    };\n    Variable.prototype.repeat = function (repeats) {\n        return new Variable(this.value.repeat(repeats), {\n            backEdge: this.noGrad ? undefined : new RepeatBack(this, repeats),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.expand = function (shape) {\n        return new Variable(this.value.expand(shape), {\n            backEdge: this.noGrad ? undefined : new ExpandBack(this, shape),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.copy = function () {\n        return new Variable(this.value.copy(), {\n            grad: this.grad !== undefined ? this.grad.copy() : undefined,\n        });\n    };\n    Variable.prototype.gather = function (axis, indices) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.floor = function () {\n        return new Variable(this.value.floor());\n    };\n    Variable.prototype.ceil = function () {\n        return new Variable(this.value.ceil());\n    };\n    Variable.prototype.upsample = function (scales) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.add_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof Variable) || !(th instanceof Variable)) {\n            throw new Error('Can only add Variable tensor to Variable tensor');\n        }\n        var noGrad = th.noGrad && tensor.noGrad;\n        return new Variable(th.value.add_impl(th.value, tensor.value, resultShape, alpha, beta), {\n            backEdge: noGrad\n                ? undefined\n                : new AddBack(th, tensor, resultShape, alpha, beta),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.subtract_impl = function (th, tensor, resultShape, alpha, beta) {\n        if (!(tensor instanceof Variable) || !(th instanceof Variable)) {\n            throw new Error('Can only add Variable tensor to Variable tensor');\n        }\n        var noGrad = th.noGrad && tensor.noGrad;\n        return new Variable(th.value.subtract_impl(th.value, tensor.value, resultShape, alpha, beta), {\n            backEdge: noGrad\n                ? undefined\n                : new SubtractBack(th, tensor, resultShape, alpha, beta),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.multiply_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof Variable) || !(th instanceof Variable)) {\n            throw new Error('Can only add Variable tensor to Variable tensor');\n        }\n        var noGrad = th.noGrad && tensor.noGrad;\n        return new Variable(th.value.multiply_impl(th.value, tensor.value, resultShape, alpha), {\n            backEdge: noGrad\n                ? undefined\n                : new MultiplyBack(th, tensor, resultShape, alpha),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.divide_impl = function (th, tensor, resultShape, alpha) {\n        if (!(tensor instanceof Variable) || !(th instanceof Variable)) {\n            throw new Error('Can only divide Variable tensor by Variable tensor');\n        }\n        var divResult = th.value.divide_impl(th.value, tensor.value, resultShape, alpha);\n        var noGrad = th.noGrad && tensor.noGrad;\n        return new Variable(divResult, {\n            backEdge: noGrad\n                ? undefined\n                : new DivideBack(th, tensor, divResult, resultShape, alpha),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof Variable) || !(th instanceof Variable)) {\n            throw new Error('Can only take Variable tensor to power of Variable tensor');\n        }\n        var powerResult = th.value.power_impl(th.value, tensor.value, resultShape);\n        var noGrad = th.noGrad && tensor.noGrad;\n        return new Variable(powerResult, {\n            backEdge: noGrad\n                ? undefined\n                : new PowerBack(th, tensor, powerResult, resultShape),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, C) {\n        if (!(b instanceof Variable) ||\n            (C !== undefined && !(C instanceof Variable))) {\n            throw new Error('Can only do gemm with variable tensors');\n        }\n        var noGrad = this.noGrad && b.noGrad && (C !== undefined ? C.noGrad : true);\n        return new Variable(this.value.gemm_impl(b.value, aTranspose, bTranspose, alpha, beta, C !== undefined ? C.value : undefined), {\n            backEdge: noGrad\n                ? undefined\n                : new GemmBack(this, b, aTranspose, bTranspose, alpha, beta, C),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.sum_impl = function (axes, keepDims) {\n        return new Variable(this.value.sum(axes, keepDims), {\n            backEdge: this.noGrad ? undefined : new SumBack(this, axes, keepDims),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.sumSquare_impl = function (axes, keepDims) {\n        return new Variable(this.value.sumSquare(axes, keepDims), {\n            backEdge: this.noGrad\n                ? undefined\n                : new SumSquareBack(this, axes, keepDims),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.product_impl = function (axes, keepDims) {\n        var product = this.value.product(axes, keepDims);\n        return new Variable(product, {\n            backEdge: this.noGrad\n                ? undefined\n                : new ProductBack(this, product, axes, keepDims),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.max_impl = function (axes, keepDims) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.min_impl = function (axes, keepDims) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.reduceMean_impl = function (axes, keepDims) {\n        return new Variable(this.value.reduceMean(axes, keepDims), {\n            backEdge: this.noGrad ? undefined : new MeanBack(this, axes, keepDims),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return new Variable(this.value.reduceMeanSquare(axes, keepDims), {\n            backEdge: this.noGrad\n                ? undefined\n                : new MeanSquareBack(this, axes, keepDims),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.conv_impl = function (kernel, dilations, group, pads, strides, activation, bias) {\n        if (!(kernel instanceof Variable) ||\n            (bias !== undefined && !(bias instanceof Variable))) {\n            throw new Error('Can only do convolution with variable as kernel and bias');\n        }\n        if (activation !== 'id') {\n            throw new Error('Activation has to be ID for convolution with variables');\n        }\n        var noGrad = this.noGrad && kernel.noGrad && (bias !== undefined ? bias.noGrad : true);\n        return new Variable(this.value.conv(kernel.value, bias !== undefined ? bias.value : undefined, dilations, group, pads, strides), {\n            backEdge: noGrad\n                ? undefined\n                : new ConvBack(this, kernel, strides, pads, dilations, group, bias),\n            noGrad: noGrad,\n        });\n    };\n    Variable.prototype.convTranspose_impl = function (kernel, dilations, group, pads, strides) {\n        throw new Error('Method not implemented.');\n    };\n    Variable.prototype.pad_impl = function (pads, mode, value) {\n        return new Variable(this.value.pad(pads, mode, value), {\n            backEdge: this.noGrad ? undefined : new PadBack(this, pads, mode, value),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return new Variable(this.value.averagePool(kernelShape, pads, strides, includePad), {\n            backEdge: this.noGrad\n                ? undefined\n                : new AveragePoolBack(this, kernelShape, pads, strides, includePad),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.transpose_impl = function (permutation) {\n        return new Variable(this.value.transpose(permutation), {\n            backEdge: this.noGrad ? undefined : new TransposeBack(this, permutation),\n            noGrad: this.noGrad,\n        });\n    };\n    Variable.prototype.slice_impl = function (starts, ends, axes) {\n        return new Variable(this.value.slice(starts, ends, axes), {\n            backEdge: this.noGrad\n                ? undefined\n                : new SliceBack(this, starts, ends, axes),\n            noGrad: this.noGrad,\n        });\n    };\n    return Variable;\n}(Tensor));\nexport { Variable };\n//# sourceMappingURL=variable.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Variable } from '../autograd/variable';\nimport { CPUTensor } from '../tensor/cpu/tensor';\nimport { GPUTensor } from '../tensor/gpu/tensor';\nimport { WASMTensor } from '../tensor/wasm/tensor';\nexport function toBackend(tensor, backend, precision) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (backend === 'CPU') {\n                return [2 /*return*/, toCPU(tensor)];\n            }\n            else if (backend === 'WASM') {\n                return [2 /*return*/, toWASM(tensor)];\n            }\n            else {\n                if (precision === undefined) {\n                    precision = 32;\n                }\n                return [2 /*return*/, toGPU(tensor, precision)];\n            }\n            return [2 /*return*/];\n        });\n    });\n}\nexport function toCPU(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, _c, values;\n        var _d;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!(tensor instanceof Variable)) return [3 /*break*/, 5];\n                    _a = Variable.bind;\n                    return [4 /*yield*/, toCPU(tensor.value)];\n                case 1:\n                    _b = [void 0, _e.sent()];\n                    _d = {};\n                    if (!(tensor.grad !== undefined)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, toCPU(tensor.grad)];\n                case 2:\n                    _c = _e.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    _c = undefined;\n                    _e.label = 4;\n                case 4: return [2 /*return*/, new (_a.apply(Variable, _b.concat([(_d.grad = _c,\n                            _d)])))()];\n                case 5:\n                    if (tensor instanceof CPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 6:\n                    values = _e.sent();\n                    return [2 /*return*/, new CPUTensor(tensor.getShape(), values)];\n            }\n        });\n    });\n}\nexport function toWASM(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, _c, values;\n        var _d;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!(tensor instanceof Variable)) return [3 /*break*/, 5];\n                    _a = Variable.bind;\n                    return [4 /*yield*/, toWASM(tensor.value)];\n                case 1:\n                    _b = [void 0, _e.sent()];\n                    _d = {};\n                    if (!(tensor.grad !== undefined)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, toWASM(tensor.grad)];\n                case 2:\n                    _c = _e.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    _c = undefined;\n                    _e.label = 4;\n                case 4: return [2 /*return*/, new (_a.apply(Variable, _b.concat([(_d.grad = _c,\n                            _d)])))()];\n                case 5:\n                    if (tensor instanceof WASMTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 6:\n                    values = _e.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new WASMTensor(values, new Uint32Array(tensor.getShape()))];\n            }\n        });\n    });\n}\nexport function toGPU(tensor, precision) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, _c, values;\n        var _d;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!(tensor instanceof Variable)) return [3 /*break*/, 5];\n                    _a = Variable.bind;\n                    return [4 /*yield*/, toGPU(tensor.value, precision)];\n                case 1:\n                    _b = [void 0, _e.sent()];\n                    _d = {};\n                    if (!(tensor.grad !== undefined)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, toGPU(tensor.grad, precision)];\n                case 2:\n                    _c = _e.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    _c = undefined;\n                    _e.label = 4;\n                case 4: return [2 /*return*/, new (_a.apply(Variable, _b.concat([(_d.grad = _c,\n                            _d)])))()];\n                case 5:\n                    if (tensor instanceof GPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 6:\n                    values = _e.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new GPUTensor(values, tensor.getShape(), precision)];\n            }\n        });\n    });\n}\nexport function sameType(a, b) {\n    if (a instanceof Variable && b instanceof Variable) {\n        return sameType(a.value, b.value);\n    }\n    if (a instanceof CPUTensor && b instanceof CPUTensor) {\n        return true;\n    }\n    if (a instanceof WASMTensor && b instanceof WASMTensor) {\n        return true;\n    }\n    if (a instanceof GPUTensor && b instanceof GPUTensor) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=convert.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Variable } from '../autograd/variable';\nimport Tensor from '../types';\nimport { toCPU, toWASM, toGPU } from '../util/convert';\n/**\n * A module is a self contained unit that transforms\n * a list of inputs when forward is called.\n *\n * It can be in two modes, training and inference.\n * In training mode, gradients will be tracked, while\n * in inference mode, only the forward pass will be calculated\n */\nvar Module = /** @class */ (function () {\n    function Module() {\n        this.backend = 'CPU';\n        this.mode = 'train';\n    }\n    Module.prototype.getSubModules = function () {\n        var modules = [];\n        for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {\n            var k = _a[_i];\n            //@ts-ignore\n            if (this[k] instanceof Module) {\n                //@ts-ignore\n                modules.push(this[k]);\n            }\n        }\n        return modules;\n    };\n    Module.prototype.getParameters = function () {\n        var parameters = [];\n        for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {\n            var k = _a[_i];\n            //@ts-ignore\n            if (this[k] instanceof Variable) {\n                //@ts-ignore\n                parameters.push(this[k]);\n            }\n        }\n        var modules = this.getSubModules();\n        for (var _b = 0, modules_1 = modules; _b < modules_1.length; _b++) {\n            var module_1 = modules_1[_b];\n            var params = module_1.getParameters();\n            parameters = parameters.concat(params);\n        }\n        return parameters;\n    };\n    Module.prototype.toBackend = function (backend) {\n        if (backend === 'CPU') {\n            return this.toCPU();\n        }\n        else if (backend === 'WASM') {\n            return this.toWASM();\n        }\n        else {\n            return this.toGPU(32);\n        }\n    };\n    Module.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var submodules, _i, submodules_1, submodule, _a, _b, k, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        submodules = this.getSubModules();\n                        _i = 0, submodules_1 = submodules;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < submodules_1.length)) return [3 /*break*/, 4];\n                        submodule = submodules_1[_i];\n                        return [4 /*yield*/, submodule.toCPU()];\n                    case 2:\n                        _e.sent();\n                        _e.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _a = 0, _b = Object.keys(this);\n                        _e.label = 5;\n                    case 5:\n                        if (!(_a < _b.length)) return [3 /*break*/, 8];\n                        k = _b[_a];\n                        if (!(this[k] instanceof Tensor)) return [3 /*break*/, 7];\n                        //@ts-ignore\n                        _c = this;\n                        _d = k;\n                        return [4 /*yield*/, toCPU(this[k])];\n                    case 6:\n                        //@ts-ignore\n                        _c[_d] = _e.sent();\n                        _e.label = 7;\n                    case 7:\n                        _a++;\n                        return [3 /*break*/, 5];\n                    case 8:\n                        this.backend = 'CPU';\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Module.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var submodules, _i, submodules_2, submodule, _a, _b, k, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        submodules = this.getSubModules();\n                        _i = 0, submodules_2 = submodules;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < submodules_2.length)) return [3 /*break*/, 4];\n                        submodule = submodules_2[_i];\n                        return [4 /*yield*/, submodule.toWASM()];\n                    case 2:\n                        _e.sent();\n                        _e.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _a = 0, _b = Object.keys(this);\n                        _e.label = 5;\n                    case 5:\n                        if (!(_a < _b.length)) return [3 /*break*/, 8];\n                        k = _b[_a];\n                        if (!(this[k] instanceof Tensor)) return [3 /*break*/, 7];\n                        //@ts-ignore\n                        _c = this;\n                        _d = k;\n                        return [4 /*yield*/, toWASM(this[k])];\n                    case 6:\n                        //@ts-ignore\n                        _c[_d] = _e.sent();\n                        _e.label = 7;\n                    case 7:\n                        _a++;\n                        return [3 /*break*/, 5];\n                    case 8:\n                        this.backend = 'WASM';\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Module.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var submodules, _i, submodules_3, submodule, _a, _b, k, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        submodules = this.getSubModules();\n                        _i = 0, submodules_3 = submodules;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < submodules_3.length)) return [3 /*break*/, 4];\n                        submodule = submodules_3[_i];\n                        return [4 /*yield*/, submodule.toGPU(precision)];\n                    case 2:\n                        _e.sent();\n                        _e.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _a = 0, _b = Object.keys(this);\n                        _e.label = 5;\n                    case 5:\n                        if (!(_a < _b.length)) return [3 /*break*/, 8];\n                        k = _b[_a];\n                        if (!(this[k] instanceof Tensor)) return [3 /*break*/, 7];\n                        //@ts-ignore\n                        _c = this;\n                        _d = k;\n                        return [4 /*yield*/, toGPU(this[k], precision)];\n                    case 6:\n                        //@ts-ignore\n                        _c[_d] = _e.sent();\n                        _e.label = 7;\n                    case 7:\n                        _a++;\n                        return [3 /*break*/, 5];\n                    case 8:\n                        this.backend = 'GPU';\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Module;\n}());\nexport { Module };\n//# sourceMappingURL=module.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// eslint-disable-next-line node/no-extraneous-import\nimport Long from 'long';\nimport { Module } from '../model/module';\nvar OnnxNode = /** @class */ (function (_super) {\n    __extends(OnnxNode, _super);\n    function OnnxNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this) || this;\n        _this.attributes = {};\n        _this.mode = mode;\n        for (var i = 0; i < attributes.length; i++) {\n            _this.attributes[attributes[i].name] = attributes[i];\n        }\n        _this.inputs = inputs;\n        _this.outputs = outputs;\n        _this.onnxVersion = onnxVersion;\n        _this.variableInputs = 0;\n        for (var i = 0; i < _this.inputs.length; i++) {\n            if (constants[_this.inputs[i]] === undefined) {\n                _this.variableInputs++;\n            }\n        }\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    OnnxNode.prototype.initialize = function (resolveConstant) { };\n    OnnxNode.prototype.getAttribute = function (name) {\n        return this.attributes[name];\n    };\n    OnnxNode.prototype.getAttributeString = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var str = attr.s;\n            if (str !== undefined && str !== null) {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                return new TextDecoder('utf-8').decode(str);\n            }\n            return undefined;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInts = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = this.attributes[name].ints;\n            if (result !== undefined && result !== null) {\n                for (var i = 0; i < result.length; i++) {\n                    if (Long.isLong(result[i])) {\n                        result[i] = result[i].toNumber();\n                    }\n                }\n                return result;\n            }\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInt = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.i;\n            if (Long.isLong(result)) {\n                result = result.toNumber();\n            }\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeFloat = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.f;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeFloats = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.floats;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeTensor = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.t;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    OnnxNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    OnnxNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    return OnnxNode;\n}(Module));\nexport { OnnxNode };\n//# sourceMappingURL=node.js.map","import { CPUTensor } from '../tensor/cpu/tensor';\nimport { TENSOR_FLOAT, TENSOR_INT64 } from './definitions';\n// eslint-disable-next-line node/no-extraneous-import\nimport Long from 'long';\nimport { getSize } from '../util/shape';\nexport function createTensor(tensorProto) {\n    if (tensorProto.segment !== undefined && tensorProto.segment !== null) {\n        throw new Error('Handling of tensor proto segment not yet implemented');\n    }\n    var shape = tensorProto.dims;\n    if (shape === undefined || shape === null) {\n        throw new Error('Tensor shape must be specified');\n    }\n    for (var i = 0; i < shape.length; i++) {\n        if (Long.isLong(shape[i])) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            shape[i] = shape[i].toNumber();\n        }\n    }\n    if (shape.length === 0) {\n        shape = [1];\n    }\n    var size = getSize(shape);\n    if (tensorProto.dataType === TENSOR_FLOAT) {\n        if (tensorProto.floatData && tensorProto.floatData.length > 0) {\n            return new CPUTensor(shape, tensorProto.floatData);\n        }\n        else if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var buffer = tensorProto.rawData.buffer.slice(tensorProto.rawData.byteOffset, tensorProto.rawData.byteOffset + tensorProto.rawData.byteLength);\n            var values = new Float32Array(buffer);\n            return new CPUTensor(shape, values);\n        }\n        else if (size === 0) {\n            return new CPUTensor(shape);\n        }\n        else {\n            throw new Error('Cant process float tensor without float or raw data');\n        }\n    }\n    else if (tensorProto.dataType === TENSOR_INT64) {\n        if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var values = new Int32Array(tensorProto.rawData.length / 8);\n            for (var i = 0; i < tensorProto.rawData.length; i += 8) {\n                var value = Long.fromBytesLE(Array.from(tensorProto.rawData.slice(i, i + 8))).toNumber();\n                values[i / 8] = value;\n            }\n            return new CPUTensor(shape, values, 'int');\n        }\n        else {\n            throw new Error('Cant process int64 tensor without raw data');\n        }\n    }\n    else {\n        throw new Error(\"Handling of tensor type \" + tensorProto.dataType + \" not yet implemented\");\n    }\n}\n//# sourceMappingURL=util.js.map","// Attribute types\nexport var ATTRIBUTE_UNDEFINED = 0;\nexport var ATTRIBUTE_FLOAT = 1; // Float32\nexport var ATTRIBUTE_INT = 2; // Int64\nexport var ATTRIBUTE_STRING = 3;\nexport var ATTRIBUTE_TENSOR = 4;\nexport var ATTRIBUTE_GRAPH = 5;\nexport var ATTRIBUTE_SPARSE_TENSOR = 11;\nexport var ATTRIBUTE_FLOATS = 6;\nexport var ATTRIBUTE_INTS = 7;\nexport var ATTRIBUTE_STRINGS = 8;\nexport var ATTRIBUTE_TENSORS = 9;\nexport var ATTRIBUTE_GRAPHS = 10;\nexport var ATTRIBUTE_SPARSE_TENSORS = 12;\n// Tensor types\nexport var TENSOR_FLOAT = 1; // float  (32 bits)\nexport var TENSOR_UINT8 = 2; // uint8_t\nexport var TENSOR_INT8 = 3; // int8_t\nexport var TENSOR_UINT16 = 4; // uint16_t\nexport var TENSOR_INT16 = 5; // int16_t\nexport var TENSOR_INT32 = 6; // int32_t\nexport var TENSOR_INT64 = 7; // int64_t\nexport var TENSOR_STRING = 8; // string\nexport var TENSOR_BOOL = 9; // bool\nexport var TENSOR_FLOAT16 = 10;\nexport var TENSOR_DOUBLE = 11;\nexport var TENSOR_UINT32 = 12;\nexport var TENSOR_UINT64 = 13;\nexport var TENSOR_COMPLEX64 = 14; // complex with float32 real and imaginary components\nexport var TENSOR_COMPLEX128 = 15; // complex with float64 real and imaginary components\n// Non-IEEE floating-point format based on IEEE754 single-precision\n// floating-point number truncated to 16 bits.\n// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.\nexport var TENSOR_BFLOAT16 = 16;\n//# sourceMappingURL=definitions.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Variable } from '../../autograd';\nimport { toCPU, toGPU, toWASM } from '../../util/convert';\nimport { OnnxNode } from '../node';\nimport { createTensor } from '../util';\nvar ConstantNode = /** @class */ (function (_super) {\n    __extends(ConstantNode, _super);\n    function ConstantNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor('value');\n            if (tensor !== undefined && tensor !== null) {\n                _this.tensor = createTensor(tensor);\n                if (mode === 'train') {\n                    _this.tensor = new Variable(_this.tensor);\n                }\n            }\n        }\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConstantNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11 && this.tensor !== undefined) {\n                    return [2 /*return*/, [this.tensor]];\n                }\n                throw new Error('Constant with onnx version >= 11 not yet implemented');\n            });\n        });\n    };\n    ConstantNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this.tensor !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        _b.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this.tensor !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        _b.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this.tensor !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.tensor, precision)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        _b.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.getType = function () {\n        return 'Constant';\n    };\n    ConstantNode.prototype.delete = function () {\n        if (this.tensor !== undefined) {\n            this.tensor.delete();\n        }\n    };\n    return ConstantNode;\n}(OnnxNode));\nexport { ConstantNode };\n//# sourceMappingURL=constant.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Variable } from '../../autograd';\nimport { toCPU, toGPU, toWASM } from '../../util/convert';\nimport { OnnxNode } from '../node';\nvar ConvNode = /** @class */ (function (_super) {\n    __extends(ConvNode, _super);\n    function ConvNode(attributes, inputs, outputs, constants, onnxVersion, mode, kernel, bias, activation) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        var autoPad = _this.getAttributeString('autoPad');\n        if (autoPad !== undefined) {\n            throw new Error('Autopad in conv not supported yet');\n        }\n        if (activation === undefined) {\n            activation = 'id';\n        }\n        _this.activation = activation;\n        _this.group = _this.getAttributeInt('group') || 1;\n        _this.dilations = _this.getAttributeInts('dilations');\n        _this.pads = _this.getAttributeInts('pads');\n        _this.strides = _this.getAttributeInts('strides');\n        _this.kernel = kernel;\n        _this.bias = bias;\n        if (mode === 'train' && _this.kernel !== undefined) {\n            _this.kernel = new Variable(_this.kernel);\n        }\n        if (mode === 'train' && _this.bias !== undefined) {\n            _this.bias = new Variable(_this.bias);\n        }\n        return _this;\n    }\n    ConvNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, w, b;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                w = this.kernel !== undefined ? this.kernel : inputs[1];\n                b = inputs.length > 2 ? inputs[2] : this.bias;\n                return [2 /*return*/, [\n                        x.conv(w, b, this.dilations, this.group, this.pads, this.strides, this.activation),\n                    ]];\n            });\n        });\n    };\n    ConvNode.prototype.getDilations = function (rank) {\n        if (this.dilations !== undefined) {\n            return this.dilations;\n        }\n        return new Array(rank).fill(1);\n    };\n    ConvNode.prototype.getPads = function (rank) {\n        if (this.pads !== undefined) {\n            return this.pads;\n        }\n        return new Array(rank * 2).fill(0);\n    };\n    ConvNode.prototype.getStrides = function (rank) {\n        if (this.strides !== undefined) {\n            return this.strides;\n        }\n        return new Array(rank).fill(1);\n    };\n    ConvNode.prototype.getType = function () {\n        return 'Conv';\n    };\n    ConvNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.kernel)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toCPU(this.bias)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.kernel)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toWASM(this.bias)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (precision === undefined) {\n                            precision = 32;\n                        }\n                        if (!(this.kernel !== undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.kernel, precision)];\n                    case 1:\n                        _a.kernel = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        if (!(this.bias !== undefined)) return [3 /*break*/, 4];\n                        _b = this;\n                        return [4 /*yield*/, toGPU(this.bias, precision)];\n                    case 3:\n                        _b.bias = _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConvNode.prototype.delete = function () {\n        if (this.kernel !== undefined) {\n            this.kernel.delete();\n        }\n        if (this.bias !== undefined) {\n            this.bias.delete();\n        }\n    };\n    return ConvNode;\n}(OnnxNode));\nexport { ConvNode };\n//# sourceMappingURL=conv.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Optimization = /** @class */ (function () {\n    function Optimization() {\n    }\n    return Optimization;\n}());\nexport { Optimization };\nvar SequenceOptimization = /** @class */ (function (_super) {\n    __extends(SequenceOptimization, _super);\n    function SequenceOptimization(nodeTypes) {\n        var _this = _super.call(this) || this;\n        _this.nodeTypes = nodeTypes;\n        return _this;\n    }\n    SequenceOptimization.prototype.findApplications = function (model) {\n        var results = [];\n        var nodes = model.getNodes();\n        for (var nodeId in Object.keys(nodes)) {\n            var node = nodes[nodeId];\n            if (node !== undefined && node.getType() === this.nodeTypes[0]) {\n                var app = this.checkApplication(model, nodeId);\n                if (app !== undefined) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    results.push(app);\n                }\n            }\n        }\n        return results;\n    };\n    SequenceOptimization.prototype.checkApplication = function (model, nodeId) {\n        var nodes = model.getNodes();\n        var nodeSeq = [nodeId];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var lastNode = nodes[nodeId];\n        var nodeInstances = [lastNode];\n        for (var i = 1; i < this.nodeTypes.length; i++) {\n            var nextNodeId = model.getNodeWithInput(lastNode.outputs[0]);\n            if (nextNodeId !== undefined) {\n                var nextNode = nodes[nextNodeId];\n                if (nextNode.getType() === this.nodeTypes[i]) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    nodeSeq.push(nextNodeId);\n                    lastNode = nextNode;\n                    nodeInstances.push(lastNode);\n                }\n                else {\n                    return undefined;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        if (this.canApply(nodeInstances)) {\n            return nodeSeq;\n        }\n        else {\n            return undefined;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    SequenceOptimization.prototype.canApply = function (nodes) {\n        return true;\n    };\n    return SequenceOptimization;\n}(Optimization));\nexport { SequenceOptimization };\n//# sourceMappingURL=optimization.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { ConvNode } from '../nodes/conv';\nimport { SequenceOptimization } from './optimization';\nvar ConvBatchNorm = /** @class */ (function (_super) {\n    __extends(ConvBatchNorm, _super);\n    function ConvBatchNorm() {\n        return _super.call(this, ['Conv', 'BatchNormalization']) || this;\n    }\n    ConvBatchNorm.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var batchNorm = nodes[1];\n        var kernelConv = resolveConstant(conv.inputs[1]);\n        var biasConv = resolveConstant(conv.inputs[2]);\n        var scaleBN = resolveConstant(batchNorm.inputs[1]);\n        var biasBN = resolveConstant(batchNorm.inputs[2]);\n        var meanBN = resolveConstant(batchNorm.inputs[3]);\n        var varianceBN = resolveConstant(batchNorm.inputs[4]);\n        var varSqrt = varianceBN.add(batchNorm.epsTensor).sqrt();\n        var scale = scaleBN.divide(varSqrt);\n        varSqrt.delete();\n        var bias = biasBN.subtract(meanBN.multiply(scale));\n        var newShape = __spreadArrays(scale.getShape(), new Array(kernelConv.getShape().length - scale.getShape().length).fill(1));\n        var newKernel = kernelConv.multiply(scale.reshape(newShape, false));\n        var newBias = bias;\n        if (biasConv !== undefined) {\n            var scaledBias = biasConv.multiply(scale);\n            newBias = newBias.add(scaledBias);\n            scaledBias.delete();\n        }\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), [conv.inputs[0]], batchNorm.outputs, constants, onnxVersion, conv.mode, newKernel, newBias);\n    };\n    return ConvBatchNorm;\n}(SequenceOptimization));\nexport { ConvBatchNorm };\n//# sourceMappingURL=convBatchnorm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ConvNode } from '../nodes/conv';\nimport { SequenceOptimization } from './optimization';\nvar ConvRelu = /** @class */ (function (_super) {\n    __extends(ConvRelu, _super);\n    function ConvRelu() {\n        return _super.call(this, ['Conv', 'Relu']) || this;\n    }\n    ConvRelu.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var relu = nodes[1];\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), conv.inputs, relu.outputs, constants, onnxVersion, conv.mode, conv.kernel, conv.bias, 'relu');\n    };\n    return ConvRelu;\n}(SequenceOptimization));\nexport { ConvRelu };\n//# sourceMappingURL=convRelu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ConvNode } from '../nodes/conv';\nimport { SequenceOptimization } from './optimization';\nvar ConvRelu6 = /** @class */ (function (_super) {\n    __extends(ConvRelu6, _super);\n    function ConvRelu6() {\n        return _super.call(this, ['Conv', 'Clip']) || this;\n    }\n    ConvRelu6.prototype.apply = function (nodes, resolveConstant, constants, onnxVersion) {\n        var conv = nodes[0];\n        var clip = nodes[1];\n        return new ConvNode(Object.entries(conv.attributes).map(function (x) { return x[1]; }), conv.inputs, clip.outputs, constants, onnxVersion, conv.mode, conv.kernel, conv.bias, 'relu6');\n    };\n    ConvRelu6.prototype.canApply = function (nodes) {\n        var clip = nodes[1];\n        return clip.min === 0 && clip.max === 6;\n    };\n    return ConvRelu6;\n}(SequenceOptimization));\nexport { ConvRelu6 };\n//# sourceMappingURL=convRelu6.js.map","import { ConvBatchNorm } from './convBatchnorm';\nimport { ConvRelu } from './convRelu';\nimport { ConvRelu6 } from './convRelu6';\nexport var defaultOptimizations = [\n    new ConvBatchNorm(),\n    new ConvRelu(),\n    new ConvRelu6(),\n];\n//# sourceMappingURL=default.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../../node';\nvar BinaryNode = /** @class */ (function (_super) {\n    __extends(BinaryNode, _super);\n    function BinaryNode(attributes, inputs, outputs, constants, onnxVersion, name, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.name = name;\n        return _this;\n    }\n    BinaryNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [this.compute(a, b)]];\n                }\n                throw new Error(this.name + \" not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    BinaryNode.prototype.getType = function () {\n        return this.name;\n    };\n    BinaryNode.prototype.delete = function () { };\n    return BinaryNode;\n}(OnnxNode));\nexport { BinaryNode };\n//# sourceMappingURL=binaryNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from './binaryNode';\nvar AddNode = /** @class */ (function (_super) {\n    __extends(AddNode, _super);\n    function AddNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Add', mode) || this;\n    }\n    AddNode.prototype.compute = function (a, b) {\n        return a.add(b);\n    };\n    return AddNode;\n}(BinaryNode));\nexport { AddNode };\n//# sourceMappingURL=add.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { Variable } from '../../autograd/variable';\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { toCPU, toGPU, toWASM } from '../../util/convert';\nimport { OnnxNode } from '../node';\nvar BatchNormalizationNode = /** @class */ (function (_super) {\n    __extends(BatchNormalizationNode, _super);\n    function BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-5;\n        _this.momentum = _this.getAttributeFloat('momentum') || 0.9;\n        _this.epsTensor = new CPUTensor([1], [_this.epsilon]);\n        if (mode === 'train') {\n            _this.epsTensor = new Variable(_this.epsTensor);\n        }\n        return _this;\n        //TODO: Handle lower onnxversions here\n    }\n    BatchNormalizationNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, B, mean, variance, C, newShape, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                scale = inputs[1];\n                B = inputs[2];\n                mean = inputs[3];\n                variance = inputs[4];\n                C = scale.getShape()[0];\n                newShape = __spreadArrays([1, C], new Array(x.getShape().length - 2).fill(1));\n                scale = scale.reshape(newShape, false);\n                B = B.reshape(newShape, false);\n                mean = mean.reshape(newShape, false);\n                variance = variance.reshape(newShape, false);\n                result = x.normalize(mean, variance, this.epsilon, scale, B);\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.getType = function () {\n        return 'BatchNormalization';\n    };\n    BatchNormalizationNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.epsTensor)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.epsTensor)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toGPU = function (precision) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.epsTensor, precision)];\n                    case 1:\n                        _a.epsTensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.delete = function () {\n        this.epsTensor.delete();\n    };\n    return BatchNormalizationNode;\n}(OnnxNode));\nexport { BatchNormalizationNode };\n//# sourceMappingURL=batchNormalization.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nexport function cast(a, to) {\n    if (a.type === to) {\n        return a;\n    }\n    else if (to === 'float') {\n        var arr = new Float32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n    else {\n        var arr = new Int32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n}\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { cast } from '../../ops/cpu/cast';\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar CastNode = /** @class */ (function (_super) {\n    __extends(CastNode, _super);\n    function CastNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        //@ts-ignore\n        _this.to = _this.getAttributeString('to');\n        return _this;\n    }\n    CastNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (x instanceof CPUTensor) {\n                    return [2 /*return*/, [cast(x, this.to)]];\n                }\n                throw new Error('Can only cast CPU tensors right now');\n            });\n        });\n    };\n    CastNode.prototype.getType = function () {\n        return 'Cast';\n    };\n    CastNode.prototype.delete = function () { };\n    return CastNode;\n}(OnnxNode));\nexport { CastNode };\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../../node';\nvar UnaryNode = /** @class */ (function (_super) {\n    __extends(UnaryNode, _super);\n    function UnaryNode(attributes, inputs, outputs, constants, onnxVersion, name, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.name = name;\n        return _this;\n    }\n    UnaryNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                return [2 /*return*/, [this.compute(x)]];\n            });\n        });\n    };\n    UnaryNode.prototype.getType = function () {\n        return this.name;\n    };\n    UnaryNode.prototype.delete = function () { };\n    return UnaryNode;\n}(OnnxNode));\nexport { UnaryNode };\n//# sourceMappingURL=unaryNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from './unaryNode';\nvar CeilNode = /** @class */ (function (_super) {\n    __extends(CeilNode, _super);\n    function CeilNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Ceil', mode) || this;\n    }\n    CeilNode.prototype.compute = function (x) {\n        return x.ceil();\n    };\n    return CeilNode;\n}(UnaryNode));\nexport { CeilNode };\n//# sourceMappingURL=ceil.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar ClipNode = /** @class */ (function (_super) {\n    __extends(ClipNode, _super);\n    function ClipNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        if (onnxVersion < 11) {\n            //@ts-ignore\n            _this.min = _this.getAttributeFloat('min');\n            //@ts-ignore\n            _this.max = _this.getAttributeFloat('max');\n        }\n        return _this;\n    }\n    ClipNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, min, max;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [x.clip(this.min, this.max)]];\n                }\n                else {\n                    min = inputs.length > 1 ? inputs[1] : undefined;\n                    max = inputs.length > 2 ? inputs[2] : undefined;\n                    if (min === undefined && max === undefined) {\n                        return [2 /*return*/, [x.copy()]];\n                    }\n                    throw new Error('Clip with onnx version >= 11 not yet implemented');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    ClipNode.prototype.getType = function () {\n        return 'Clip';\n    };\n    ClipNode.prototype.delete = function () { };\n    return ClipNode;\n}(OnnxNode));\nexport { ClipNode };\n//# sourceMappingURL=clip.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar ConcatNode = /** @class */ (function (_super) {\n    __extends(ConcatNode, _super);\n    function ConcatNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        if (onnxVersion < 13) {\n            //@ts-ignore\n            _this.axis = _this.getAttributeInt('axis');\n        }\n        return _this;\n    }\n    ConcatNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, i, newRes;\n            return __generator(this, function (_a) {\n                if (inputs.length > 2) {\n                    // This logging seems to slow down the operation more than the operation itself\n                    //console.warn(`Concat with more than 2 tensors is currently slow. Doing concat with ${inputs.length} tensors`);\n                }\n                if (this.onnxVersion < 13 && this.axis !== undefined) {\n                    result = inputs[0];\n                    for (i = 1; i < inputs.length; i++) {\n                        newRes = result.concat(inputs[i], this.axis);\n                        if (i > 1) {\n                            result.delete();\n                        }\n                        result = newRes;\n                    }\n                    return [2 /*return*/, [result]];\n                }\n                throw new Error(\"Concat not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ConcatNode.prototype.getType = function () {\n        return 'Concat';\n    };\n    ConcatNode.prototype.delete = function () { };\n    return ConcatNode;\n}(OnnxNode));\nexport { ConcatNode };\n//# sourceMappingURL=concat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize } from '../../util/shape';\nimport { OnnxNode } from '../node';\nimport { createTensor } from '../util';\n// This does not support gradients right now, mainly because\n// the forward pass needs to directly access the constant value\nvar ConstantOfShapeNode = /** @class */ (function (_super) {\n    __extends(ConstantOfShapeNode, _super);\n    function ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor('value');\n            if (tensor !== null && tensor !== undefined) {\n                _this.tensor = createTensor(tensor);\n            }\n        }\n        return _this;\n    }\n    ConstantOfShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _shape, shape, i, size, values;\n            return __generator(this, function (_a) {\n                _shape = inputs[0];\n                if (this.onnxVersion < 11 && this.tensor !== undefined) {\n                    if (!(_shape instanceof CPUTensor)) {\n                        throw new Error('ConstantOfShape needs cpu tensor as shape tensor');\n                    }\n                    shape = new Array(_shape.size);\n                    for (i = 0; i < _shape.size; i++) {\n                        shape[i] = _shape.get(i);\n                    }\n                    size = getSize(shape);\n                    values = new Float32Array(size).fill(this.tensor.get(0));\n                    return [2 /*return*/, [new CPUTensor(shape, values, this.tensor.type)]];\n                }\n                throw new Error(\"ConstantOfShape not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ConstantOfShapeNode.prototype.getType = function () {\n        return 'ConstantOfShape';\n    };\n    ConstantOfShapeNode.prototype.delete = function () {\n        if (this.tensor !== undefined) {\n            this.tensor.delete();\n        }\n    };\n    return ConstantOfShapeNode;\n}(OnnxNode));\nexport { ConstantOfShapeNode };\n//# sourceMappingURL=constantOfShape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from './binaryNode';\nvar DivNode = /** @class */ (function (_super) {\n    __extends(DivNode, _super);\n    function DivNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Div', mode) || this;\n    }\n    DivNode.prototype.compute = function (a, b) {\n        return a.divide(b);\n    };\n    return DivNode;\n}(BinaryNode));\nexport { DivNode };\n//# sourceMappingURL=div.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from './unaryNode';\nvar ExpNode = /** @class */ (function (_super) {\n    __extends(ExpNode, _super);\n    function ExpNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Exp', mode) || this;\n    }\n    ExpNode.prototype.compute = function (x) {\n        return x.exp();\n    };\n    return ExpNode;\n}(UnaryNode));\nexport { ExpNode };\n//# sourceMappingURL=exp.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar ExpandNode = /** @class */ (function (_super) {\n    __extends(ExpandNode, _super);\n    function ExpandNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    ExpandNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tensor, _shape, shape, i;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    tensor = inputs[0];\n                    _shape = inputs[1];\n                    if (!(_shape instanceof CPUTensor)) {\n                        throw new Error('Expand needs cpu tensor as shape tensor');\n                    }\n                    shape = new Array(_shape.size);\n                    for (i = 0; i < _shape.size; i++) {\n                        shape[i] = _shape.get(i);\n                    }\n                    return [2 /*return*/, [tensor.expand(shape)]];\n                }\n                throw new Error(\"Expand not yet implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ExpandNode.prototype.getType = function () {\n        return 'Expand';\n    };\n    ExpandNode.prototype.delete = function () { };\n    return ExpandNode;\n}(OnnxNode));\nexport { ExpandNode };\n//# sourceMappingURL=expand.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { UnaryNode } from './unaryNode';\nvar FloorNode = /** @class */ (function (_super) {\n    __extends(FloorNode, _super);\n    function FloorNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Floor', mode) || this;\n    }\n    FloorNode.prototype.compute = function (x) {\n        return x.floor();\n    };\n    return FloorNode;\n}(UnaryNode));\nexport { FloorNode };\n//# sourceMappingURL=floor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar GatherNode = /** @class */ (function (_super) {\n    __extends(GatherNode, _super);\n    function GatherNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.axis = _this.getAttributeInt('axis') || 0;\n        return _this;\n    }\n    GatherNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, indices;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                indices = inputs[1];\n                if (!(indices instanceof CPUTensor)) {\n                    throw new Error('Gather requires CPU tensor for the indices');\n                }\n                return [2 /*return*/, [x.gather(this.axis, indices)]];\n            });\n        });\n    };\n    GatherNode.prototype.getType = function () {\n        return 'Gather';\n    };\n    GatherNode.prototype.delete = function () { };\n    return GatherNode;\n}(OnnxNode));\nexport { GatherNode };\n//# sourceMappingURL=gather.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar GemmNode = /** @class */ (function (_super) {\n    __extends(GemmNode, _super);\n    function GemmNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.alpha = _this.getAttributeFloat('alpha') || 1.0;\n        _this.beta = _this.getAttributeFloat('beta') || 1.0;\n        var transA = _this.getAttributeInt('transA');\n        var transB = _this.getAttributeInt('transB');\n        _this.transA = transA === 1;\n        _this.transB = transB === 1;\n        return _this;\n    }\n    GemmNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b, c;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion >= 7 && this.onnxVersion < 11) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    c = inputs[2];\n                    return [2 /*return*/, [a.gemm(b, this.transA, this.transB, this.alpha, c, this.beta)]];\n                }\n                throw new Error(\"Gemm is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    GemmNode.prototype.getType = function () {\n        return 'Gemm';\n    };\n    GemmNode.prototype.delete = function () { };\n    return GemmNode;\n}(OnnxNode));\nexport { GemmNode };\n//# sourceMappingURL=gemm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { glContext } from '../../tensor/gpu/gl';\nimport { OnnxNode } from '../node';\nvar InstanceNormalizationNode = /** @class */ (function (_super) {\n    __extends(InstanceNormalizationNode, _super);\n    function InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-5;\n        return _this;\n        //TODO: Handle onnx versions < 6 here\n    }\n    InstanceNormalizationNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, B, dataRank, C, newShape, reduceAxes, i, mean, diff, variance, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                scale = inputs[1];\n                B = inputs[2];\n                dataRank = x.getShape().length - 2;\n                C = scale.getShape()[0];\n                newShape = __spreadArrays([1, C], new Array(dataRank).fill(1));\n                scale = scale.reshape(newShape, false);\n                B = B.reshape(newShape, false);\n                reduceAxes = new Array(x.getShape().length - 2);\n                for (i = 0; i < dataRank; i++) {\n                    reduceAxes[i] = i + 2;\n                }\n                mean = x.reduceMean(reduceAxes, true);\n                glContext.flush();\n                diff = x.subtract(mean);\n                glContext.flush();\n                variance = diff.reduceMeanSquare(reduceAxes, true);\n                glContext.flush();\n                result = x.normalize(mean, variance, this.epsilon, scale, B);\n                mean.delete();\n                diff.delete();\n                variance.delete();\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    InstanceNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    InstanceNormalizationNode.prototype.getType = function () {\n        return 'InstanceNormalization';\n    };\n    InstanceNormalizationNode.prototype.delete = function () { };\n    return InstanceNormalizationNode;\n}(OnnxNode));\nexport { InstanceNormalizationNode };\n//# sourceMappingURL=instanceNormalization.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar MatMulNode = /** @class */ (function (_super) {\n    __extends(MatMulNode, _super);\n    function MatMulNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    MatMulNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var A, B;\n            return __generator(this, function (_a) {\n                A = inputs[0];\n                B = inputs[1];\n                if (this.onnxVersion < 13) {\n                    if (A.getShape().length !== B.getShape().length) {\n                        throw new Error('Automatic broadcasting in MatMul not supported yet');\n                    }\n                    return [2 /*return*/, [A.gemm(B)]];\n                }\n                throw new Error(\"Matmul with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    MatMulNode.prototype.getType = function () {\n        return 'MatMul';\n    };\n    MatMulNode.prototype.delete = function () { };\n    return MatMulNode;\n}(OnnxNode));\nexport { MatMulNode };\n//# sourceMappingURL=matMul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from './binaryNode';\nvar MulNode = /** @class */ (function (_super) {\n    __extends(MulNode, _super);\n    function MulNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Mul', mode) || this;\n    }\n    MulNode.prototype.compute = function (a, b) {\n        return a.multiply(b);\n    };\n    return MulNode;\n}(BinaryNode));\nexport { MulNode };\n//# sourceMappingURL=mul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar PadNode = /** @class */ (function (_super) {\n    __extends(PadNode, _super);\n    function PadNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.padMode = (_this.getAttributeString('mode') || 'constant');\n        //@ts-ignore\n        _this.pads = _this.getAttributeInts('pads');\n        _this.value = _this.getAttributeFloat('value') || 0;\n        return _this;\n    }\n    PadNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].pad(this.pads, this.padMode, this.value)]];\n                }\n                throw new Error(\"Pad not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    PadNode.prototype.getType = function () {\n        return 'Pad';\n    };\n    PadNode.prototype.delete = function () { };\n    return PadNode;\n}(OnnxNode));\nexport { PadNode };\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../../node';\nvar ReduceNode = /** @class */ (function (_super) {\n    __extends(ReduceNode, _super);\n    function ReduceNode(attributes, inputs, outputs, constants, onnxVersion, name, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.axes = _this.getAttributeInts('axes');\n        var keep = _this.getAttributeInt('keepdims');\n        _this.keepDims = keep === 1 || keep === undefined;\n        _this.name = name;\n        return _this;\n    }\n    ReduceNode.prototype.getAxes = function (input) {\n        if (this.axes !== undefined) {\n            return this.axes;\n        }\n        else {\n            var rank = input.getShape().length;\n            var res = new Array(rank);\n            for (var i = 0; i < rank; i++) {\n                res[i] = i;\n            }\n            return res;\n        }\n    };\n    ReduceNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [this.calc(inputs[0])]];\n                }\n                throw new Error(this.name + \" is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ReduceNode.prototype.getType = function () {\n        return this.name;\n    };\n    ReduceNode.prototype.delete = function () { };\n    return ReduceNode;\n}(OnnxNode));\nexport { ReduceNode };\n//# sourceMappingURL=reduceNode.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from './reduceNode';\nvar ReduceMaxNode = /** @class */ (function (_super) {\n    __extends(ReduceMaxNode, _super);\n    function ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'ReduceMax', mode) || this;\n    }\n    ReduceMaxNode.prototype.calc = function (input) {\n        return input.max(this.axes, this.keepDims);\n    };\n    return ReduceMaxNode;\n}(ReduceNode));\nexport { ReduceMaxNode };\n//# sourceMappingURL=reduceMax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from './reduceNode';\nvar ReduceMeanNode = /** @class */ (function (_super) {\n    __extends(ReduceMeanNode, _super);\n    function ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'ReduceMean', mode) || this;\n    }\n    ReduceMeanNode.prototype.calc = function (input) {\n        return input.reduceMean(this.axes, this.keepDims);\n    };\n    return ReduceMeanNode;\n}(ReduceNode));\nexport { ReduceMeanNode };\n//# sourceMappingURL=reduceMean.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from './reduceNode';\nvar ReduceSumNode = /** @class */ (function (_super) {\n    __extends(ReduceSumNode, _super);\n    function ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'ReduceSum', mode) || this;\n    }\n    ReduceSumNode.prototype.calc = function (input) {\n        return input.sum(this.axes, this.keepDims);\n    };\n    return ReduceSumNode;\n}(ReduceNode));\nexport { ReduceSumNode };\n//# sourceMappingURL=reduceSum.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ReduceNode } from './reduceNode';\nvar ReduceSumSquareNode = /** @class */ (function (_super) {\n    __extends(ReduceSumSquareNode, _super);\n    function ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'ReduceSumSquare', mode) || this;\n    }\n    ReduceSumSquareNode.prototype.calc = function (input) {\n        return input.sumSquare(this.axes, this.keepDims);\n    };\n    return ReduceSumSquareNode;\n}(ReduceNode));\nexport { ReduceSumSquareNode };\n//# sourceMappingURL=reduceSumSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ClipNode } from './clip';\nvar ReluNode = /** @class */ (function (_super) {\n    __extends(ReluNode, _super);\n    function ReluNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.max = undefined;\n        _this.min = 0;\n        return _this;\n    }\n    ReluNode.prototype.getType = function () {\n        return 'Relu';\n    };\n    return ReluNode;\n}(ClipNode));\nexport { ReluNode };\n//# sourceMappingURL=relu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar ReshapeNode = /** @class */ (function (_super) {\n    __extends(ReshapeNode, _super);\n    function ReshapeNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    ReshapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shape, _shape, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shape = inputs[1];\n                if (!(shape instanceof CPUTensor)) {\n                    throw new Error('Reshape only works with CPU tensor as shape tensor');\n                }\n                if (this.onnxVersion < 13) {\n                    _shape = new Array(shape.size);\n                    for (i = 0; i < shape.size; i++) {\n                        _shape[i] = shape.get(i);\n                    }\n                    return [2 /*return*/, [x.reshape(_shape)]];\n                }\n                throw new Error(\"Reshape with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    ReshapeNode.prototype.getType = function () {\n        return 'Reshape';\n    };\n    ReshapeNode.prototype.delete = function () { };\n    return ReshapeNode;\n}(OnnxNode));\nexport { ReshapeNode };\n//# sourceMappingURL=reshape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar ShapeNode = /** @class */ (function (_super) {\n    __extends(ShapeNode, _super);\n    function ShapeNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    ShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, shape;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    a = inputs[0];\n                    shape = a.getShape();\n                    return [2 /*return*/, [new CPUTensor([shape.length], __spreadArrays(shape), 'int')]];\n                }\n                throw new Error(\"Shape not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    ShapeNode.prototype.getType = function () {\n        return 'Shape';\n    };\n    ShapeNode.prototype.delete = function () { };\n    return ShapeNode;\n}(OnnxNode));\nexport { ShapeNode };\n//# sourceMappingURL=shape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar SliceNode = /** @class */ (function (_super) {\n    __extends(SliceNode, _super);\n    function SliceNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.axes = _this.getAttributeInts('axes');\n        //@ts-ignore\n        _this.starts = _this.getAttributeInts('starts');\n        //@ts-ignore\n        _this.ends = _this.getAttributeInts('ends');\n        return _this;\n    }\n    SliceNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 10) {\n                    x = inputs[0];\n                    return [2 /*return*/, [x.slice(this.starts, this.ends, this.axes)]];\n                }\n                throw new Error(\"Slice not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    SliceNode.prototype.getType = function () {\n        return 'Slice';\n    };\n    SliceNode.prototype.delete = function () { };\n    return SliceNode;\n}(OnnxNode));\nexport { SliceNode };\n//# sourceMappingURL=slice.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar SoftmaxNode = /** @class */ (function (_super) {\n    __extends(SoftmaxNode, _super);\n    function SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        //@ts-ignore\n        _this.axis = _this.getAttributeInt('axis');\n        return _this;\n    }\n    SoftmaxNode.prototype.defaultForward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shapeX, ax, sh1, reshaped, max, normalized, exp, sum, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shapeX = x.getShape();\n                ax = this.axis;\n                if (ax === undefined) {\n                    if (this.onnxVersion < 13) {\n                        ax = 1;\n                    }\n                    else {\n                        ax = shapeX.length - 1;\n                    }\n                }\n                sh1 = shapeX.slice(0, ax).reduce(function (x, y) { return x * y; }, 1);\n                reshaped = x.reshape([sh1, -1], false);\n                max = reshaped.max(1, true);\n                normalized = reshaped.subtract(max);\n                exp = normalized.exp();\n                sum = exp.sum(1, true);\n                result = exp.divide(sum);\n                max.delete();\n                normalized.delete();\n                exp.delete();\n                sum.delete();\n                return [2 /*return*/, [result.reshape(shapeX, false)]];\n            });\n        });\n    };\n    SoftmaxNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.defaultForward(inputs)];\n            });\n        });\n    };\n    SoftmaxNode.prototype.getType = function () {\n        return 'Softmax';\n    };\n    SoftmaxNode.prototype.delete = function () { };\n    return SoftmaxNode;\n}(OnnxNode));\nexport { SoftmaxNode };\n//# sourceMappingURL=softmax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryNode } from './binaryNode';\nvar SubNode = /** @class */ (function (_super) {\n    __extends(SubNode, _super);\n    function SubNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, 'Sub', mode) || this;\n    }\n    SubNode.prototype.compute = function (a, b) {\n        return a.subtract(b);\n    };\n    return SubNode;\n}(BinaryNode));\nexport { SubNode };\n//# sourceMappingURL=sub.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { OnnxNode } from '../node';\nvar TileNode = /** @class */ (function (_super) {\n    __extends(TileNode, _super);\n    function TileNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    TileNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, repeats, _repeats, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                repeats = inputs[1];\n                if (!(repeats instanceof CPUTensor)) {\n                    throw new Error('Tile only works with CPU tensor as repeats');\n                }\n                if (this.onnxVersion < 13 && this.onnxVersion >= 6) {\n                    _repeats = new Array(repeats.size);\n                    for (i = 0; i < repeats.size; i++) {\n                        _repeats[i] = repeats.get(i);\n                    }\n                    return [2 /*return*/, [x.repeat(_repeats)]];\n                }\n                throw new Error(\"Tile with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    TileNode.prototype.getType = function () {\n        return 'Tile';\n    };\n    TileNode.prototype.delete = function () { };\n    return TileNode;\n}(OnnxNode));\nexport { TileNode };\n//# sourceMappingURL=tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar TransposeNode = /** @class */ (function (_super) {\n    __extends(TransposeNode, _super);\n    function TransposeNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        _this.permutation = _this.getAttributeInts('perm');\n        return _this;\n    }\n    TransposeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.transpose(this.permutation)]];\n            });\n        });\n    };\n    TransposeNode.prototype.getType = function () {\n        return 'Transpose';\n    };\n    TransposeNode.prototype.delete = function () { };\n    return TransposeNode;\n}(OnnxNode));\nexport { TransposeNode };\n//# sourceMappingURL=transpose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar UnsqueezeNode = /** @class */ (function (_super) {\n    __extends(UnsqueezeNode, _super);\n    function UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        if (onnxVersion < 13) {\n            _this.axes = _this.getAttributeInts('axes');\n        }\n        return _this;\n    }\n    UnsqueezeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, currShape, newShape, axIx, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 13 && this.axes !== undefined) {\n                    currShape = x.getShape();\n                    newShape = [];\n                    axIx = 0;\n                    for (i = 0; i < currShape.length; i++) {\n                        if (axIx < this.axes.length && this.axes[axIx] === i) {\n                            newShape.push(1);\n                            axIx++;\n                        }\n                        newShape.push(currShape[i]);\n                    }\n                    if (this.axes[this.axes.length - 1] === currShape.length) {\n                        newShape.push(1);\n                    }\n                    return [2 /*return*/, [x.reshape(newShape)]];\n                }\n                throw new Error(\"Unsqueeze with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    UnsqueezeNode.prototype.getType = function () {\n        return 'Unsqueeze';\n    };\n    UnsqueezeNode.prototype.delete = function () { };\n    return UnsqueezeNode;\n}(OnnxNode));\nexport { UnsqueezeNode };\n//# sourceMappingURL=unsqueeze.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { toCPU } from '../../util/convert';\nimport { OnnxNode } from '../node';\nvar UpsampleNode = /** @class */ (function (_super) {\n    __extends(UpsampleNode, _super);\n    function UpsampleNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n        //@ts-ignore\n        _this.sampleMode = _this.getAttributeString('mode');\n        if (_this.sampleMode !== 'nearest') {\n            throw new Error('Upsampling only supported with nearest neighbor sampling');\n        }\n        if (_this.onnxVersion < 9) {\n            var scales = _this.getAttributeFloats('scales');\n            if (scales !== undefined && scales !== null) {\n                _this.scales = scales;\n            }\n            else {\n                throw new Error(\"Upsample node with onnx version \" + _this.onnxVersion + \" is missing scales attribute\");\n            }\n        }\n        return _this;\n    }\n    UpsampleNode.prototype.getScales = function (scale) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sc, scales, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.onnxVersion < 9) {\n                            return [2 /*return*/, this.scales];\n                        }\n                        if (!!(scale instanceof CPUTensor)) return [3 /*break*/, 2];\n                        console.warn('Scales tensor for upsample not on CPU, need to transfer!');\n                        return [4 /*yield*/, toCPU(scale)];\n                    case 1:\n                        scale = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        sc = scale;\n                        scales = new Array(sc.size);\n                        for (i = 0; i < sc.size; i++) {\n                            scales[i] = sc.get(i);\n                        }\n                        return [2 /*return*/, scales];\n                }\n            });\n        });\n    };\n    UpsampleNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, scales;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        x = inputs[0];\n                        scale = inputs[1];\n                        return [4 /*yield*/, this.getScales(scale)];\n                    case 1:\n                        scales = _a.sent();\n                        return [2 /*return*/, [x.upsample(scales)]];\n                }\n            });\n        });\n    };\n    UpsampleNode.prototype.getType = function () {\n        return 'Upsample';\n    };\n    UpsampleNode.prototype.delete = function () { };\n    return UpsampleNode;\n}(OnnxNode));\nexport { UpsampleNode };\n//# sourceMappingURL=upsample.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from '../node';\nvar GlobalAveragePoolNode = /** @class */ (function (_super) {\n    __extends(GlobalAveragePoolNode, _super);\n    function GlobalAveragePoolNode(attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion, mode) || this;\n    }\n    GlobalAveragePoolNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, axes, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                axes = new Array(x.getShape().length - 2);\n                for (i = 0; i < x.getShape().length - 2; i++) {\n                    axes[i] = i + 2;\n                }\n                return [2 /*return*/, [x.reduceMean(axes, true)]];\n            });\n        });\n    };\n    GlobalAveragePoolNode.prototype.getType = function () {\n        return 'GlobalAveragePool';\n    };\n    GlobalAveragePoolNode.prototype.delete = function () { };\n    return GlobalAveragePoolNode;\n}(OnnxNode));\nexport { GlobalAveragePoolNode };\n//# sourceMappingURL=globalAveragePool.js.map","import { AddNode } from './nodes/binary/add';\nimport { BatchNormalizationNode } from './nodes/batchNormalization';\nimport { CastNode } from './nodes/cast';\nimport { CeilNode } from './nodes/unary/ceil';\nimport { ClipNode } from './nodes/clip';\nimport { ConcatNode } from './nodes/concat';\nimport { ConstantNode } from './nodes/constant';\nimport { ConstantOfShapeNode } from './nodes/constantOfShape';\nimport { ConvNode } from './nodes/conv';\nimport { DivNode } from './nodes/binary/div';\nimport { ExpNode } from './nodes/unary/exp';\nimport { ExpandNode } from './nodes/expand';\nimport { FloorNode } from './nodes/unary/floor';\nimport { GatherNode } from './nodes/gather';\nimport { GemmNode } from './nodes/gemm';\nimport { InstanceNormalizationNode } from './nodes/instanceNormalization';\nimport { MatMulNode } from './nodes/matMul';\nimport { MulNode } from './nodes/binary/mul';\nimport { PadNode } from './nodes/pad';\nimport { ReduceMaxNode } from './nodes/reduce/reduceMax';\nimport { ReduceMeanNode } from './nodes/reduce/reduceMean';\nimport { ReduceSumNode } from './nodes/reduce/reduceSum';\nimport { ReduceSumSquareNode } from './nodes/reduce/reduceSumSquare';\nimport { ReluNode } from './nodes/relu';\nimport { ReshapeNode } from './nodes/reshape';\nimport { ShapeNode } from './nodes/shape';\nimport { SliceNode } from './nodes/slice';\nimport { SoftmaxNode } from './nodes/softmax';\nimport { SubNode } from './nodes/binary/sub';\nimport { TileNode } from './nodes/tile';\nimport { TransposeNode } from './nodes/transpose';\nimport { UnsqueezeNode } from './nodes/unsqueeze';\nimport { UpsampleNode } from './nodes/upsample';\nimport { GlobalAveragePoolNode } from './nodes/globalAveragePool';\nexport var nodeResolve = {\n    Conv: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ConvNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    BatchNormalization: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Clip: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ClipNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Add: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new AddNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    ReduceMean: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Gemm: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new GemmNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Constant: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ConstantNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Reshape: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReshapeNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Tile: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new TileNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    MatMul: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new MatMulNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Exp: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ExpNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    ReduceSum: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    ReduceMax: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    ReduceSumSquare: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Sub: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new SubNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Mul: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new MulNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Div: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new DivNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Unsqueeze: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Concat: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ConcatNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    ConstantOfShape: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Expand: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ExpandNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    InstanceNormalization: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Pad: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new PadNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Relu: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ReluNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Shape: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new ShapeNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Gather: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new GatherNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Cast: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new CastNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Floor: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new FloorNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Ceil: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new CeilNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Slice: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new SliceNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Upsample: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new UpsampleNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Transpose: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new TransposeNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    Softmax: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n    GlobalAveragePool: function (attributes, inputs, outputs, constants, onnxVersion, mode) {\n        return new GlobalAveragePoolNode(attributes, inputs, outputs, constants, onnxVersion, mode);\n    },\n};\n//# sourceMappingURL=resolve.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n// eslint-disable-next-line node/no-extraneous-import\nimport Long from 'long';\nimport { onnx } from 'onnx-proto';\nimport { Variable } from '../autograd/variable';\nimport { Module } from '../model/module';\nimport { glContext } from '../tensor/gpu/gl';\nimport { toCPU, toGPU, toWASM } from '../util/convert';\nimport { ConstantNode } from './nodes/constant';\nimport { defaultOptimizations } from './optimizations/default';\nimport { nodeResolve } from './resolve';\nimport { createTensor } from './util';\nvar OnnxModel = /** @class */ (function (_super) {\n    __extends(OnnxModel, _super);\n    /**\n     * Builds a new onnx model\n     *\n     * @param buffer Onnx model\n     * @param args Optional arguments for the model\n     */\n    function OnnxModel(buffer, args) {\n        var _this = _super.call(this) || this;\n        _this.inputSet = new Set();\n        _this.nodes = {};\n        _this.nodeIds = [];\n        _this.defaultReady = [];\n        _this.intermediaries = {};\n        _this.constants = {};\n        _this.nodeIdCounter = 10000;\n        if (args === undefined) {\n            args = {};\n        }\n        _this.noConvertConstants = new Set(args.noConvertConstants !== undefined ? args.noConvertConstants : []);\n        _this.noConvertNodes = new Set(args.noConvertNodes !== undefined ? args.noConvertNodes : []);\n        _this.mode = args.mode || 'inference';\n        _this.precision = args.precision || 32;\n        var arr;\n        if (buffer instanceof ArrayBuffer) {\n            arr = new Uint8Array(buffer);\n        }\n        else {\n            arr = buffer;\n        }\n        _this.modelProto = onnx.ModelProto.decode(arr);\n        var ver = _this.modelProto.opsetImport[0].version;\n        if (Long.isLong(ver)) {\n            ver = ver.toNumber();\n        }\n        _this.version = ver;\n        //@ts-ignore\n        _this.inputs = _this.modelProto.graph.input;\n        for (var i = 0; i < _this.inputs.length; i++) {\n            _this.inputSet.add(_this.inputs[i].name);\n        }\n        //@ts-ignore\n        _this.outputs = _this.modelProto.graph.output.map(function (x) { return x.name; });\n        //@ts-ignore\n        _this.initializer(_this.modelProto.graph.initializer);\n        _this.initNodes(_this.modelProto);\n        return _this;\n    }\n    OnnxModel.prototype.initNodes = function (modelProto) {\n        var _this = this;\n        //@ts-ignore\n        for (var i = 0; i < modelProto.graph.node.length; i++) {\n            //@ts-ignore\n            var nodeData = modelProto.graph.node[i];\n            //@ts-ignore\n            var cls = nodeResolve[nodeData.opType];\n            if (cls === undefined) {\n                throw new Error(\"Node operator \" + nodeData.opType + \" can not be resolved\");\n            }\n            var attributes = nodeData.attribute || [];\n            var inputs = nodeData.input || [];\n            var outputs = nodeData.output || [];\n            var node = cls(attributes, inputs, outputs, this.constants, this.version, this.mode);\n            this.nodes[i] = node;\n            this.nodeIds.push(i);\n            for (var j = 0; j < inputs.length; j++) {\n                var input = inputs[j];\n                if (this.intermediaries[input] === undefined) {\n                    this.intermediaries[input] = {\n                        to: [],\n                        deletable: true,\n                    };\n                }\n                this.intermediaries[input].to.push(i);\n            }\n            if (node.variableInputs === 0) {\n                this.defaultReady.push(i);\n            }\n            if (nodeData.opType === 'Constant') {\n                //@ts-ignore\n                if (this.intermediaries[nodeData.output[0]] === undefined) {\n                    //@ts-ignore\n                    this.intermediaries[nodeData.output[0]] = {\n                        to: [],\n                        deletable: false,\n                    };\n                }\n                else {\n                    //@ts-ignore\n                    this.intermediaries[nodeData.output[0]].deletable = false;\n                }\n            }\n        }\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            this.nodes[nodeId].initialize(function (name) { return _this.resolveConstant(name); });\n        }\n    };\n    OnnxModel.prototype.initializer = function (initializer) {\n        for (var i = 0; i < initializer.length; i++) {\n            var tensorProto = initializer[i];\n            var tensor = createTensor(tensorProto);\n            if (this.mode === 'train') {\n                tensor = new Variable(tensor);\n            }\n            //@ts-ignore\n            this.constants[tensorProto.name] = tensor;\n        }\n    };\n    /**\n     * Do a forward pass for the specified inputs\n     *\n     * @param wait Number of milliseconds to wait between each layer. This\n     *             is especially useful, if your model is complex and\n     *             you dont want your model to block your whole application.\n     * @param returnIntermediary return after the given intermediary result\n     *                           has been computed.\n     */\n    OnnxModel.prototype.forward = function (inputs, wait) {\n        return __awaiter(this, void 0, void 0, function () {\n            var intermediaryRes, nodes, _i, _a, i, nodesReady, nodeId, node, _b, inputs_1, toDelete, outputs_1, e_1, i, inter, outputs, i;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        intermediaryRes = {};\n                        nodes = {};\n                        for (_i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n                            i = _a[_i];\n                            nodes[i] = {\n                                variableInputs: 0,\n                            };\n                        }\n                        nodesReady = __spreadArrays(this.defaultReady);\n                        this.initializeForward(inputs, intermediaryRes, nodes, nodesReady);\n                        _c.label = 1;\n                    case 1:\n                        if (!(nodesReady.length > 0)) return [3 /*break*/, 8];\n                        nodeId = nodesReady.shift();\n                        node = this.nodes[nodeId];\n                        _b = this.getInputsToNode(node, intermediaryRes), inputs_1 = _b.inputs, toDelete = _b.toDelete;\n                        outputs_1 = void 0;\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, node.forward(inputs_1)];\n                    case 3:\n                        outputs_1 = _c.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _c.sent();\n                        console.error(\"Error occurred in node \" + nodeId + \" with inputs \" + node.inputs + \" from nodes \" + node.inputs.map(function (x) {\n                            return _this.getNodeWithOutput(x);\n                        }));\n                        throw e_1;\n                    case 5:\n                        glContext.flush();\n                        this.propagateResults(node, intermediaryRes, outputs_1, nodes, nodesReady);\n                        for (i = 0; i < toDelete.length; i++) {\n                            if (!this.inputSet.has(toDelete[i])) {\n                                inter = intermediaryRes[toDelete[i]];\n                                inter.value.delete();\n                                delete intermediaryRes[toDelete[i]];\n                            }\n                        }\n                        if (!(wait !== undefined)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                setTimeout(resolve, wait);\n                            })];\n                    case 6:\n                        _c.sent();\n                        _c.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8:\n                        outputs = [];\n                        for (i = 0; i < this.outputs.length; i++) {\n                            outputs.push(intermediaryRes[this.outputs[i]].value);\n                        }\n                        return [2 /*return*/, outputs];\n                }\n            });\n        });\n    };\n    OnnxModel.prototype.initializeForward = function (inputs, intermediaryRes, nodes, nodesReady) {\n        for (var i = 0; i < inputs.length; i++) {\n            //@ts-ignore\n            intermediaryRes[this.inputs[i].name] = {\n                value: inputs[i],\n                used: 0,\n            };\n            //@ts-ignore\n            var inter = this.intermediaries[this.inputs[i].name];\n            for (var j = 0; j < inter.to.length; j++) {\n                var id = inter.to[j];\n                nodes[id].variableInputs++;\n                if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                    nodesReady.push(id);\n                    delete nodes[id];\n                }\n            }\n        }\n    };\n    OnnxModel.prototype.getInputsToNode = function (node, intermediaryRes) {\n        var inputs = [];\n        var toDelete = [];\n        for (var i = 0; i < node.inputs.length; i++) {\n            var input = node.inputs[i];\n            if (this.constants[input] !== undefined) {\n                inputs.push(this.constants[input]);\n            }\n            else {\n                var inter = intermediaryRes[input];\n                inter.used++;\n                if (inter.used >= this.intermediaries[input].to.length &&\n                    this.intermediaries[input].deletable) {\n                    toDelete.push(input);\n                }\n                inputs.push(inter.value);\n            }\n        }\n        return { inputs: inputs, toDelete: toDelete };\n    };\n    OnnxModel.prototype.propagateResults = function (node, intermediaryRes, outputs, nodes, nodesReady) {\n        for (var i = 0; i < node.outputs.length; i++) {\n            var output = node.outputs[i];\n            intermediaryRes[output] = {\n                value: outputs[i],\n                used: 0,\n            };\n            var inter = this.intermediaries[output];\n            if (inter !== undefined) {\n                for (var j = 0; j < inter.to.length; j++) {\n                    var id = inter.to[j];\n                    nodes[id].variableInputs++;\n                    if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                        nodesReady.push(id);\n                        delete nodes[id];\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Transfer the model to the CPU\n     */\n    OnnxModel.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toCPU(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toCPU()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Transfer the model to WASM\n     */\n    OnnxModel.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toWASM(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toWASM()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Transfer the model to the GPU\n     */\n    OnnxModel.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toGPU(this.constants[i], this.precision)];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toGPU(this.precision)];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Optimize the model.\n     */\n    OnnxModel.prototype.optimize = function () {\n        var _this = this;\n        for (var _i = 0, defaultOptimizations_1 = defaultOptimizations; _i < defaultOptimizations_1.length; _i++) {\n            var optimization = defaultOptimizations_1[_i];\n            //@ts-ignore\n            var applications = optimization.findApplications(this);\n            for (var _a = 0, applications_1 = applications; _a < applications_1.length; _a++) {\n                var nodeIds = applications_1[_a];\n                var nodes = nodeIds.map(function (x) { return _this.nodes[x]; });\n                var newNode = optimization.apply(nodes, function (name) { return _this.resolveConstant(name); }, this.constants, this.version);\n                var outputs = new Set(newNode.outputs);\n                for (var _b = 0, nodeIds_1 = nodeIds; _b < nodeIds_1.length; _b++) {\n                    var nodeId = nodeIds_1[_b];\n                    this.removeNode(nodeId, outputs);\n                }\n                this.insertNode(newNode);\n            }\n        }\n        this.prune();\n    };\n    OnnxModel.prototype.prune = function (intermediariesToDelete) {\n        var _this = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            var nodesToDelete = this.pruneIntermediaries(intermediariesToDelete);\n            intermediariesToDelete = [];\n            if (nodesToDelete.size > 0) {\n                nodesToDelete.forEach(function (id) {\n                    var interToDelete = _this.removeNode(id, new Set());\n                    intermediariesToDelete = intermediariesToDelete === null || intermediariesToDelete === void 0 ? void 0 : intermediariesToDelete.concat(interToDelete);\n                });\n            }\n            else {\n                break;\n            }\n        }\n    };\n    OnnxModel.prototype.pruneIntermediaries = function (intermediariesToDelete) {\n        var nodesToDelete = new Set();\n        if (intermediariesToDelete === undefined) {\n            intermediariesToDelete = [];\n        }\n        for (var i = 0; i < intermediariesToDelete.length; i++) {\n            var id = intermediariesToDelete[i];\n            var nodeOutputId = this.getNodeWithOutput(id);\n            if (nodeOutputId !== undefined) {\n                nodesToDelete.add(nodeOutputId);\n            }\n            var nodeInputId = this.getNodeWithInput(id);\n            if (nodeInputId !== undefined) {\n                nodesToDelete.add(nodeInputId);\n            }\n        }\n        var _loop_1 = function (id) {\n            var intermediary = this_1.intermediaries[id];\n            if (intermediary.to.length === 0 &&\n                this_1.outputs.find(function (x) { return x === id; }) === undefined) {\n                intermediariesToDelete.push(id);\n                var nodeOutputId = this_1.getNodeWithOutput(id);\n                if (nodeOutputId !== undefined) {\n                    nodesToDelete.add(nodeOutputId);\n                }\n                var nodeInputId = this_1.getNodeWithInput(id);\n                if (nodeInputId !== undefined) {\n                    nodesToDelete.add(nodeInputId);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var id in this.intermediaries) {\n            _loop_1(id);\n        }\n        for (var _i = 0, intermediariesToDelete_1 = intermediariesToDelete; _i < intermediariesToDelete_1.length; _i++) {\n            var id = intermediariesToDelete_1[_i];\n            delete this.intermediaries[id];\n        }\n        return nodesToDelete;\n    };\n    OnnxModel.prototype.removeNode = function (nodeId, preserveIntermediaries) {\n        var node = this.nodes[nodeId];\n        for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n            if (this.intermediaries[input] !== undefined) {\n                this.intermediaries[input].to = this.intermediaries[input].to.filter(function (x) { return x.toString() !== nodeId.toString(); });\n            }\n        }\n        var intermediariesToDelete = [];\n        if (!preserveIntermediaries.has(node.outputs[0])) {\n            intermediariesToDelete.push(node.outputs[0]);\n        }\n        this.nodeIds = this.nodeIds.filter(function (x) { return x.toString() !== nodeId.toString(); });\n        this.nodes[nodeId].delete();\n        delete this.nodes[nodeId];\n        this.defaultReady = this.defaultReady.filter(function (x) { return x !== nodeId; });\n        return intermediariesToDelete;\n    };\n    OnnxModel.prototype.insertNode = function (node) {\n        var id = this.nodeIdCounter++;\n        this.nodeIds.push(id);\n        this.nodes[id] = node;\n        for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n            this.intermediaries[input].to.push(id);\n        }\n    };\n    // Utility functions\n    OnnxModel.prototype.getNodeWithOutput = function (output) {\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var id = _a[_i];\n            if (this.nodes[id].outputs.findIndex(function (x) { return x === output; }) !== -1) {\n                return id;\n            }\n        }\n        return undefined;\n    };\n    OnnxModel.prototype.getNodeWithInput = function (output) {\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var id = _a[_i];\n            if (this.nodes[id].inputs.findIndex(function (x) { return x === output; }) !== -1) {\n                return id;\n            }\n        }\n        return undefined;\n    };\n    OnnxModel.prototype.resolveConstant = function (name) {\n        if (this.constants[name] !== undefined) {\n            return this.constants[name];\n        }\n        var nodeIdOut = this.getNodeWithOutput(name);\n        //@ts-ignore\n        var nodeOut = this.nodes[nodeIdOut];\n        if (nodeOut instanceof ConstantNode) {\n            return nodeOut.tensor;\n        }\n        return undefined;\n    };\n    OnnxModel.prototype.getNodes = function () {\n        return this.nodes;\n    };\n    /**\n     * Deletes the model\n     *\n     * This will release the memory/framebuffers (depending on the backend)\n     */\n    OnnxModel.prototype.delete = function () {\n        for (var c in this.constants) {\n            this.constants[c].delete();\n        }\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            this.nodes[nodeId].delete();\n        }\n    };\n    OnnxModel.prototype.getSubModules = function () {\n        var modules = _super.prototype.getSubModules.call(this);\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            modules.push(this.nodes[nodeId]);\n        }\n        return modules;\n    };\n    OnnxModel.prototype.getParameters = function () {\n        var parameters = _super.prototype.getParameters.call(this);\n        for (var c in this.constants) {\n            if (this.constants[c] instanceof Variable) {\n                parameters.push(this.constants[c]);\n            }\n        }\n        return parameters;\n    };\n    return OnnxModel;\n}(Module));\nexport { OnnxModel };\n//# sourceMappingURL=model.js.map","var Optimizer = /** @class */ (function () {\n    function Optimizer(model) {\n        this.model = model;\n        this.parameters = model.getParameters();\n    }\n    Optimizer.prototype.zeroGrads = function () {\n        for (var _i = 0, _a = this.parameters; _i < _a.length; _i++) {\n            var parameter = _a[_i];\n            if (parameter.grad !== undefined) {\n                parameter.grad.delete();\n                parameter.grad = undefined;\n            }\n        }\n    };\n    return Optimizer;\n}());\nexport { Optimizer };\n//# sourceMappingURL=optimizer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Variable } from '../autograd/variable';\nimport { CPUTensor } from '../tensor/cpu/tensor';\nimport { normal } from '../util/math';\nimport { Module } from './module';\n/**\n * Linear layer calculates y=xW + b\n *\n * W is initialized with Xavier initialization, while the bias is\n * initialized to zeros\n */\nvar Linear = /** @class */ (function (_super) {\n    __extends(Linear, _super);\n    /**\n     * Creates a linear layer\n     * @param dimIn Feature dimension of the input\n     * @param dimOut Feature dimension of the output\n     * @param bias Wether a bias should be added or not. Defaults to true\n     */\n    function Linear(dimIn, dimOut, bias) {\n        var _this = _super.call(this) || this;\n        bias = bias === undefined ? true : bias;\n        var weightVals = normal(dimIn * dimOut, 0, 2 / (dimIn + dimOut));\n        var tensor = new CPUTensor([dimIn, dimOut], weightVals);\n        _this.weights = new Variable(tensor);\n        if (bias) {\n            var biasVals = new Array(dimOut).fill(0);\n            var tensorBias = new CPUTensor([1, dimOut], biasVals);\n            _this.bias = new Variable(tensorBias);\n        }\n        return _this;\n    }\n    Linear.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, [inputs[0].gemm(this.weights, false, false, 1, this.bias)]];\n            });\n        });\n    };\n    return Linear;\n}(Module));\nexport { Linear };\n/**\n * Rectified linear unit, calculates y = max(x,0)\n */\nvar Relu = /** @class */ (function (_super) {\n    __extends(Relu, _super);\n    function Relu() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Relu.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, [inputs[0].clip(0)]];\n            });\n        });\n    };\n    return Relu;\n}(Module));\nexport { Relu };\n/**\n * Sequence of modules. Passes the input sequentially into the specified modules\n */\nvar Sequential = /** @class */ (function (_super) {\n    __extends(Sequential, _super);\n    function Sequential(modules) {\n        var _this = _super.call(this) || this;\n        _this.modules = modules;\n        return _this;\n    }\n    Sequential.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, i, oldX, j;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        x = inputs;\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < this.modules.length)) return [3 /*break*/, 4];\n                        oldX = x;\n                        return [4 /*yield*/, this.modules[i].forward(x)];\n                    case 2:\n                        x = _a.sent();\n                        if (this.mode === 'inference' && i > 0) {\n                            for (j = 0; j < oldX.length; j++) {\n                                oldX[j].delete();\n                            }\n                        }\n                        _a.label = 3;\n                    case 3:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, x];\n                }\n            });\n        });\n    };\n    Sequential.prototype.getSubModules = function () {\n        var modules = _super.prototype.getSubModules.call(this);\n        return modules.concat(this.modules);\n    };\n    return Sequential;\n}(Module));\nexport { Sequential };\n/**\n * Dictionary of modules. Use this if you want to store submodules in a list\n */\nvar ModuleDict = /** @class */ (function (_super) {\n    __extends(ModuleDict, _super);\n    function ModuleDict(modules) {\n        if (modules === void 0) { modules = {}; }\n        var _this = _super.call(this) || this;\n        _this.modules = modules;\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ModuleDict.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Module dict does not support forward');\n            });\n        });\n    };\n    ModuleDict.prototype.getSubModules = function () {\n        var modules = [];\n        for (var k in this.modules) {\n            modules.push(this.modules[k]);\n        }\n        return modules;\n    };\n    ModuleDict.prototype.get = function (key) {\n        return this.modules[key];\n    };\n    ModuleDict.prototype.set = function (key, module) {\n        this.modules[key] = module;\n    };\n    return ModuleDict;\n}(Module));\nexport { ModuleDict };\n/**\n * Dictionary of modules. Use this if you want to store submodules in a list\n */\nvar ModuleList = /** @class */ (function (_super) {\n    __extends(ModuleList, _super);\n    function ModuleList(modules) {\n        if (modules === void 0) { modules = []; }\n        var _this = _super.call(this) || this;\n        _this.modules = modules;\n        return _this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ModuleList.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Module list does not support forward');\n            });\n        });\n    };\n    ModuleList.prototype.getSubModules = function () {\n        return this.modules;\n    };\n    ModuleList.prototype.get = function (index) {\n        return this.modules[index];\n    };\n    ModuleList.prototype.set = function (index, module) {\n        this.modules[index] = module;\n    };\n    ModuleList.prototype.push = function (module) {\n        this.modules.push(module);\n    };\n    ModuleList.prototype.pop = function () {\n        return this.modules.pop();\n    };\n    return ModuleList;\n}(Module));\nexport { ModuleList };\n//# sourceMappingURL=basic.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getSize } from '../../../util/shape';\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { Operation } from '../../../ops/gpu/operation';\nimport { Dispatcher } from '../../../ops/gpu/dispatcher';\nimport { gpuConstructor } from '../../../tensor/gpu/tensor';\nvar UpdateMomentOperation = /** @class */ (function (_super) {\n    __extends(UpdateMomentOperation, _super);\n    function UpdateMomentOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    UpdateMomentOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('beta1') + \" float beta1;\\n    \" + this.getVarModifier('beta2') + \" float beta2;\\n    \" + this.getVarModifier('t') + \" int t;\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UpdateMomentOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    void main() {\\n      initVars();\\n\\n      int pos = coordinateToPos(uv, widthOutput, heightOutput);\\n\\n      float m1 = getValueAtPos(pos, widthMoments, heightMoments, Moments);\\n      float m2 = getValueAtPos(pos+2, widthMoments, heightMoments, Moments);\\n      float grad = getValueAtPos(pos/4, widthGrad, heightGrad, Grad);\\n\\n      m1 = beta1*m1 + (1.0-beta1)*grad;\\n      m2 = beta2*m2 + (1.0-beta2)*grad*grad;\\n\\n      float m1Corr = m1/(1.0-pow(beta1, float(t)));\\n      float m2Corr = m2/(1.0-pow(beta2, float(t)));\\n\\n      gl_FragColor = vec4(m1,m1Corr,m2,m2Corr);\\n    }\\n    \";\n    };\n    UpdateMomentOperation.prototype.getTextureNames = function () {\n        return ['Grad', 'Moments'];\n    };\n    UpdateMomentOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'beta1', type: 'float' },\n            { name: 'beta2', type: 'float' },\n            { name: 't', type: 'int' },\n        ];\n    };\n    UpdateMomentOperation.prototype.calc = function (input) {\n        return this.compute(input.Moments.shape, { Grad: input.Grad, Moments: input.Moments }, {\n            beta1: input.beta1,\n            beta2: input.beta2,\n            t: input.t,\n        });\n    };\n    UpdateMomentOperation.prototype.getOutputShape = function (input) {\n        return input.Moments.shape;\n    };\n    UpdateMomentOperation.prototype.compile = function (info, precision) {\n        if (info.shapeMoments !== undefined) {\n            this.maxRank = info.shapeMoments.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UpdateMomentOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeGrad: input.Grad.shape,\n            widthGrad: input.Grad.memory.width,\n            heightGrad: input.Grad.memory.height,\n            shapeMoments: input.Moments.shape,\n            widthMoments: input.Moments.memory.width,\n            heightMoments: input.Moments.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            beta1: input.beta1,\n            beta2: input.beta2,\n        };\n    };\n    UpdateMomentOperation.prototype.getInputInfoString = function (input) {\n        return input.Grad.shape + \"-\" + input.Moments.shape + \"-\" + input.beta1 + \"-\" + input.beta2;\n    };\n    return UpdateMomentOperation;\n}(Operation));\nexport { UpdateMomentOperation };\nexport var defaultUpdateMomentsD = new Dispatcher(function () { return new UpdateMomentOperation(gpuConstructor); });\n//# sourceMappingURL=updateMoments.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getSize } from '../../../util/shape';\nimport { defaultAllocator } from '../../../tensor/gpu/gl';\nimport { Operation } from '../../../ops/gpu/operation';\nimport { Dispatcher } from '../../../ops/gpu/dispatcher';\nimport { gpuConstructor } from '../../../tensor/gpu/tensor';\nvar UpdateValueOperation = /** @class */ (function (_super) {\n    __extends(UpdateValueOperation, _super);\n    function UpdateValueOperation(tensorConstructor, allocator) {\n        var _this = _super.call(this, tensorConstructor, allocator) || this;\n        _this.maxIterations = 1000000;\n        return _this;\n    }\n    UpdateValueOperation.prototype.getVariables = function () {\n        return \"\\n    \" + this.getVarModifier('alpha') + \" float alpha;\\n    \" + this.getVarModifier('epsilon') + \" float epsilon;\\n    \";\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UpdateValueOperation.prototype.getFragmentShader = function (info) {\n        return \"\\n    float newVal(float m1Corr, float m2Corr, float value) {\\n      return value - alpha*(m1Corr/(sqrt(m2Corr)+epsilon));\\n    }\\n\\n    void main() {\\n      initVars();\\n\\n      int pos = coordinateToPos(uv, widthOutput, heightOutput);\\n\\n      vec4 result = vec4(0,0,0,0);\\n\\n      float m1Corr = getValueAtPos(pos*4+1, widthMoments, heightMoments, Moments);\\n      float m2Corr = getValueAtPos(pos*4+3, widthMoments, heightMoments, Moments);\\n      float value = getValueAtPos(pos, widthValue, heightValue, Value);\\n      result.r = newVal(m1Corr, m2Corr, value);\\n\\n      pos++;\\n      m1Corr = getValueAtPos(pos*4+1, widthMoments, heightMoments, Moments);\\n      m2Corr = getValueAtPos(pos*4+3, widthMoments, heightMoments, Moments);\\n      value = getValueAtPos(pos, widthValue, heightValue, Value);\\n      result.g = newVal(m1Corr, m2Corr, value);\\n\\n      pos++;\\n      m1Corr = getValueAtPos(pos*4+1, widthMoments, heightMoments, Moments);\\n      m2Corr = getValueAtPos(pos*4+3, widthMoments, heightMoments, Moments);\\n      value = getValueAtPos(pos, widthValue, heightValue, Value);\\n      result.b = newVal(m1Corr, m2Corr, value);\\n\\n      pos++;\\n      m1Corr = getValueAtPos(pos*4+1, widthMoments, heightMoments, Moments);\\n      m2Corr = getValueAtPos(pos*4+3, widthMoments, heightMoments, Moments);\\n      value = getValueAtPos(pos, widthValue, heightValue, Value);\\n      result.a = newVal(m1Corr, m2Corr, value);\\n\\n\\n      gl_FragColor = result;\\n    }\\n    \";\n    };\n    UpdateValueOperation.prototype.getTextureNames = function () {\n        return ['Value', 'Moments'];\n    };\n    UpdateValueOperation.prototype.getUniformAttrs = function () {\n        return [\n            { name: 'alpha', type: 'float' },\n            { name: 'epsilon', type: 'float' },\n        ];\n    };\n    UpdateValueOperation.prototype.calc = function (input) {\n        return this.compute(input.Value.shape, { Value: input.Value, Moments: input.Moments }, {\n            alpha: input.alpha,\n            epsilon: input.epsilon,\n        });\n    };\n    UpdateValueOperation.prototype.getOutputShape = function (input) {\n        return input.Value.shape;\n    };\n    UpdateValueOperation.prototype.compile = function (info, precision) {\n        if (info.shapeMoments !== undefined) {\n            this.maxRank = info.shapeMoments.length;\n        }\n        _super.prototype.compile.call(this, info, precision);\n    };\n    UpdateValueOperation.prototype.getCompilationInfo = function (input, precision) {\n        var outputShape = this.getOutputShape(input);\n        var outputSize = defaultAllocator.getAllocationDimensions(getSize(outputShape), precision);\n        return {\n            shapeValue: input.Value.shape,\n            widthValue: input.Value.memory.width,\n            heightValue: input.Value.memory.height,\n            shapeMoments: input.Moments.shape,\n            widthMoments: input.Moments.memory.width,\n            heightMoments: input.Moments.memory.height,\n            shapeOutput: outputShape,\n            widthOutput: outputSize.width,\n            heightOutput: outputSize.height,\n            alpha: input.alpha,\n            epsilon: input.epsilon,\n        };\n    };\n    UpdateValueOperation.prototype.getInputInfoString = function (input) {\n        return input.Value.shape + \"-\" + input.Moments.shape + \"-\" + input.alpha + \"-\" + input.epsilon;\n    };\n    return UpdateValueOperation;\n}(Operation));\nexport { UpdateValueOperation };\nexport var defaultUpdateValueD = new Dispatcher(function () { return new UpdateValueOperation(gpuConstructor); });\n//# sourceMappingURL=updateParams.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { GPUTensor } from '../../../tensor/gpu/tensor';\nimport { Optimizer } from '../optimizer';\nimport { defaultUpdateMomentsD } from './updateMoments';\nimport { defaultUpdateValueD } from './updateParams';\n/**\n * Implements the Adam optimizer\n *\n * This is currently quite slow on the CPU and WASM backends. On the GPU\n * backend, one update step is only slightly slower than an update step of SGD\n * and will converge a lot quicker.\n */\nvar Adam = /** @class */ (function (_super) {\n    __extends(Adam, _super);\n    function Adam(model, lr, beta1, beta2, epsilon) {\n        if (lr === void 0) { lr = 0.001; }\n        if (beta1 === void 0) { beta1 = 0.9; }\n        if (beta2 === void 0) { beta2 = 0.999; }\n        if (epsilon === void 0) { epsilon = 10e-8; }\n        var _this = _super.call(this, model) || this;\n        _this.lr = lr;\n        _this.beta1 = beta1;\n        _this.beta2 = beta2;\n        _this.epsilon = epsilon;\n        _this.t = 0;\n        var params = _this.parameters;\n        if (params[0].value instanceof GPUTensor) {\n            _this.moments = new Array(params.length);\n            for (var i = 0; i < params.length; i++) {\n                _this.moments[i] = new GPUTensor(new Float32Array(params[i].value.size * 4).fill(0), __spreadArrays(params[i].getShape(), [4]), params[i].value.precision);\n            }\n        }\n        else {\n            _this.moment1 = new Array(params.length).fill(undefined);\n            _this.moment2 = new Array(params.length).fill(undefined);\n        }\n        return _this;\n    }\n    Adam.prototype.step = function () {\n        this.t++;\n        if (this.moment1 !== undefined && this.moment2 !== undefined) {\n            for (var i = 0; i < this.parameters.length; i++) {\n                var parameter = this.parameters[i];\n                if (parameter.grad !== undefined) {\n                    var oldValue = parameter.value;\n                    var _a = this.paramStep(parameter.value, parameter.grad, this.moment1[i], this.moment2[i]), newValue = _a.newValue, moment1 = _a.moment1, moment2 = _a.moment2;\n                    parameter.value = newValue;\n                    this.moment1[i] = moment1;\n                    this.moment2[i] = moment2;\n                    oldValue.delete();\n                }\n            }\n        }\n        else if (this.moments !== undefined) {\n            for (var i = 0; i < this.parameters.length; i++) {\n                var parameter = this.parameters[i];\n                if (parameter.grad !== undefined) {\n                    var oldValue = parameter.value;\n                    var _b = this.gpuParamStep(parameter.value, parameter.grad, this.moments[i]), newValue = _b.newValue, moments = _b.moments;\n                    parameter.value = newValue;\n                    this.moments[i] = moments;\n                    oldValue.delete();\n                }\n            }\n        }\n    };\n    Adam.prototype.updateMoments = function (grad, moment1, moment2) {\n        var moment1New;\n        if (moment1 === undefined) {\n            moment1New = grad.multiplyScalar(1 - this.beta1);\n        }\n        else {\n            var oldMoment1 = moment1;\n            moment1New = moment1.add(grad, this.beta1, 1 - this.beta1);\n            oldMoment1.delete();\n        }\n        var moment2New;\n        if (moment2 === undefined) {\n            moment2New = grad.multiply(grad, 1 - this.beta2);\n        }\n        else {\n            var gradSquared = grad.multiply(grad);\n            var oldMoment2 = moment2;\n            moment2New = moment2.add(gradSquared, this.beta2, 1 - this.beta2);\n            gradSquared.delete();\n            oldMoment2.delete();\n        }\n        return { moment1New: moment1New, moment2New: moment2New };\n    };\n    Adam.prototype.getCorrectedMoments = function (moment1, moment2) {\n        var correctMoment1 = moment1.addMultiplyScalar(1 / (1 - Math.pow(this.beta1, this.t)), 0);\n        var correctMoment2 = moment2.addMultiplyScalar(1 / (1 - Math.pow(this.beta2, this.t)), 0);\n        return { correctMoment1: correctMoment1, correctMoment2: correctMoment2 };\n    };\n    Adam.prototype.paramStep = function (value, grad, moment1, moment2) {\n        var _a = this.updateMoments(grad, moment1, moment2), moment1New = _a.moment1New, moment2New = _a.moment2New;\n        // This is not 100% correct, in the original paper\n        // the epsilon occurs outside of the square root\n        // It does not make much of a difference though\n        // and is slightly faster\n        var correctMoment2 = moment2New.addMultiplyScalar(1 / (1 - Math.pow(this.beta2, this.t)), this.epsilon);\n        var moment2Sqrt = correctMoment2.sqrt();\n        correctMoment2.delete();\n        var step = moment1New.divide(moment2Sqrt, -this.lr / (1 - Math.pow(this.beta1, this.t)));\n        moment2Sqrt.delete();\n        var newValue = value.add(step);\n        step.delete();\n        return { newValue: newValue, moment1: moment1, moment2: moment2 };\n    };\n    Adam.prototype.gpuParamStep = function (value, grad, moments) {\n        var newMoments = defaultUpdateMomentsD.calc({\n            Grad: grad,\n            Moments: moments,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            t: this.t,\n        }, value.precision);\n        moments.delete();\n        var newValue = defaultUpdateValueD.calc({\n            Value: value,\n            Moments: newMoments,\n            alpha: this.lr,\n            epsilon: this.epsilon,\n        }, value.precision);\n        return { newValue: newValue, moments: newMoments };\n    };\n    return Adam;\n}(Optimizer));\nexport { Adam };\n//# sourceMappingURL=Adam.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Optimizer } from './optimizer';\nvar SGD = /** @class */ (function (_super) {\n    __extends(SGD, _super);\n    function SGD(model, lr) {\n        if (lr === void 0) { lr = 0.001; }\n        var _this = _super.call(this, model) || this;\n        _this.lr = lr;\n        return _this;\n    }\n    SGD.prototype.step = function () {\n        for (var _i = 0, _a = this.parameters; _i < _a.length; _i++) {\n            var parameter = _a[_i];\n            if (parameter.grad !== undefined) {\n                var oldValue = parameter.value;\n                parameter.value = parameter.value.subtract(parameter.grad, 1, this.lr);\n                oldValue.delete();\n            }\n        }\n    };\n    return SGD;\n}(Optimizer));\nexport { SGD };\n//# sourceMappingURL=SGD.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from '../../../../ops/gpu/binary/binaryOperation';\nimport { Dispatcher } from '../../../../ops/gpu/dispatcher';\nimport { gpuConstructor } from '../../../../tensor/gpu/tensor';\nvar BCEBackOperation = /** @class */ (function (_super) {\n    __extends(BCEBackOperation, _super);\n    function BCEBackOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    BCEBackOperation.prototype.getOp = function (a, b) {\n        return b + \" == 1.0 ? -1.0/\" + a + \" : 1.0/(1.0-\" + a + \")\";\n    };\n    return BCEBackOperation;\n}(BinaryOperation));\nexport { BCEBackOperation };\nexport var defaultBCEBackD = new Dispatcher(function () { return new BCEBackOperation(gpuConstructor); });\n//# sourceMappingURL=gpu.js.map","import { CPUTensor } from '../../../../tensor/cpu/tensor';\nimport { WASMTensor } from '../../../../tensor/wasm/tensor';\nimport { bceBack } from './cpu';\nimport { defaultBCEBackD } from './gpu';\nvar BCEBack = /** @class */ (function () {\n    function BCEBack(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    BCEBack.prototype.backward = function (grad) {\n        var gradX;\n        if (grad instanceof CPUTensor) {\n            var back = bceBack(this.x.value, this.y.value);\n            gradX = grad.multiply(back);\n            back.delete();\n        }\n        else if (grad instanceof WASMTensor) {\n            var back = this.x.value.wasmTensor.bce_back(this.y.value.wasmTensor);\n            gradX = new WASMTensor(grad.wasmTensor.multiply(back, 1.0));\n            back.free();\n        }\n        else {\n            var back = defaultBCEBackD.calc({\n                A: this.x.value,\n                B: this.y.value,\n                outputShape: this.x.getShape(),\n            }, this.x.value.precision);\n            gradX = grad.multiply(back);\n            back.delete();\n        }\n        var needed = this.x.backward(gradX);\n        if (!needed) {\n            gradX.delete();\n        }\n    };\n    BCEBack.prototype.delete = function () {\n        if (!this.x.isLeaf()) {\n            this.x.delete();\n        }\n        if (!this.y.isLeaf()) {\n            this.y.delete();\n        }\n    };\n    return BCEBack;\n}());\nexport { BCEBack };\n//# sourceMappingURL=back.js.map","import { positionWiseBinaryOp } from '../../../../ops/cpu/basic';\nexport function bceBack(x, y) {\n    return positionWiseBinaryOp(x, y, function (x, y) {\n        if (y === 1) {\n            return -1 / x;\n        }\n        else {\n            return 1 / (1 - x);\n        }\n    }, x.shape);\n}\n//# sourceMappingURL=cpu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinaryOperation } from '../../../ops/gpu/binary/binaryOperation';\nimport { Dispatcher } from '../../../ops/gpu/dispatcher';\nimport { gpuConstructor } from '../../../tensor/gpu/tensor';\nvar BCEOperation = /** @class */ (function (_super) {\n    __extends(BCEOperation, _super);\n    function BCEOperation(tensorConstructor, allocator) {\n        return _super.call(this, tensorConstructor, allocator) || this;\n    }\n    BCEOperation.prototype.getOp = function (a, b) {\n        return b + \" == 1.0 ? -log(\" + a + \") : -log(1.0-\" + a + \")\";\n    };\n    return BCEOperation;\n}(BinaryOperation));\nexport { BCEOperation };\nexport var defaultBCED = new Dispatcher(function () { return new BCEOperation(gpuConstructor); });\n//# sourceMappingURL=gpu.js.map","var L2Regularization = /** @class */ (function () {\n    function L2Regularization(model, gamma) {\n        this.model = model;\n        this.gamma = gamma;\n        this.parameters = model.getParameters();\n    }\n    L2Regularization.prototype.getLoss = function () {\n        var loss = this.parameters[0].sumSquare();\n        var factor = this.gamma;\n        for (var i = 1; i < this.parameters.length; i++) {\n            loss = loss.add(this.parameters[i].sumSquare(), factor, this.gamma);\n            factor = factor / factor;\n        }\n        return loss;\n    };\n    return L2Regularization;\n}());\nexport { L2Regularization };\nvar L1Regularization = /** @class */ (function () {\n    function L1Regularization(model, gamma) {\n        this.model = model;\n        this.gamma = gamma;\n        this.parameters = model.getParameters();\n    }\n    L1Regularization.prototype.getLoss = function () {\n        var loss = this.parameters[0].abs().sum();\n        var factor = this.gamma;\n        for (var i = 1; i < this.parameters.length; i++) {\n            loss = loss.add(this.parameters[i].abs().sum(), factor, this.gamma);\n            factor = factor / factor;\n        }\n        return loss;\n    };\n    return L1Regularization;\n}());\nexport { L1Regularization };\n//# sourceMappingURL=regularization.js.map","import * as tjs from '@hoff97/tensor-js';\n\n\nexport async function loadModel(name: string) {\n    const res = await fetch(`models/${name}.onnx`);\n    const buffer = await res.arrayBuffer();\n\n    const model = new tjs.onnx.model.OnnxModel(buffer, {\n        noConvertNodes: [69, 98],\n        precision: 16\n    });\n    await model.toGPU();\n\n    return model;\n}","import React from 'react';\nimport './App.css';\nimport { loadModel } from './inference';\n\nimport * as tjs from '@hoff97/tensor-js';\n\ninterface AppState {\n  img: any;\n  scale: number;\n  croppedSize: number;\n  showResult: boolean;\n  model: string;\n}\n\nconst models = [\n  \"mosaic\",\n  \"candy\",\n  \"pointilism\",\n  \"udnie\",\n  \"rain-princess\"\n];\n\nconst imgs = [\n  \"n01440764_tench.JPEG\",\n  \"n03160309_dam.JPEG\",\n  \"n03216828_dock.JPEG\",\n  \"n03670208_limousine.JPEG\",\n  \"n04548280_wall_clock.JPEG\",\n  \"n04552348_warplane.JPEG\",\n  \"n04599235_wool.JPEG\",\n  \"n06874185_traffic_light.JPEG\",\n  \"n07873807_pizza.JPEG\",\n  \"n07920052_espresso.JPEG\",\n  \"n09193705_alp.JPEG\",\n  \"n12620546_hip.JPEG\",\n];\n\nclass App extends React.Component<{}, AppState> {\n  private model?: tjs.onnx.model.OnnxModel = undefined;\n\n  private scale = new tjs.tensor.gpu.GPUTensor(new Float32Array([255]), [1], 16);\n\n  constructor(props: {}) {\n    super(props);\n\n    loadModel('mosaic').then(x => {\n      this.model = x;\n      console.log('Got model');\n    });\n\n    this.setState({\n      scale: 50,\n      model: 'mosaic'\n    });\n  }\n\n  getImageData() {\n    const el = document.getElementById(\"img\") as HTMLImageElement;\n\n    console.log('Reading pixels');\n    const tensor = tjs.tensor.gpu.GPUTensor.fromData(el, 16);\n\n    let [height, width] = tensor.shape.slice(0,2);\n\n    const cropSize = Math.min(width, height);\n    const halfSize = Math.floor(cropSize/2);\n\n    const widthSliceStart = Math.floor(width/2) - halfSize;\n    const heightSliceStart = Math.floor(height/2) - halfSize;\n\n    const sliced = tensor.slice([heightSliceStart, widthSliceStart,0], [heightSliceStart + cropSize,widthSliceStart + cropSize,3], [0,1,2]);\n    tensor.delete();\n\n    const showWidth = this.getImageWidth(this.state.scale);\n    const scale = showWidth/width;\n    const scaled = sliced.upsample([scale,scale,1]);\n    sliced.delete();\n\n    const croppedSize = scaled.getShape()[0];\n\n    this.setState({\n      ...this.state,\n      croppedSize: croppedSize,\n    });\n\n    const transposed = scaled.transpose([2, 0, 1]);\n    scaled.delete();\n    const multiplied = transposed.multiply(this.scale)\n    transposed.delete();\n    const reshaped = multiplied.reshape([1,3,croppedSize,croppedSize], false);\n\n    console.log('Doing forward pass');\n    this.model?.forward([reshaped], 100).then(result => this.handleResult(result[0]));\n  }\n\n  handleResult(tensor: tjs.Tensor) {\n    console.log('Got result', tensor);\n\n    this.setState({\n      ...this.state,\n      showResult: true\n    })\n\n    const sh = tensor.getShape();\n\n    tensor = tensor.reshape(sh.slice(1), false);\n    const transposed = tensor.transpose([1,2,0]);\n    console.log(transposed.getShape());\n    tensor.delete();\n\n    const t = (transposed as tjs.tensor.gpu.GPUTensor).copy(32) as tjs.tensor.gpu.GPUTensor;\n    transposed.delete();\n\n    t.getValues().then(x => {\n      const canv = document.getElementById(\"canvas\") as HTMLCanvasElement;\n      const context = canv.getContext(\"2d\");\n\n      if (context) {\n        var id = context.createImageData(t.shape[0],t.shape[1]);\n        var d  = id.data;\n        console.log(d.length, x.length);\n\n        for (let i = 0; i < x.length; i++) {\n          const pos = Math.floor(i/3);\n          const offset = i%3;\n          d[pos*4+offset] = Math.round(x[i]);\n          d[pos*4+3] = 255;\n        }\n        context.putImageData(id, 0, 0);\n      }\n\n      t.delete();\n    });\n  }\n\n  fileSelected(ev: React.ChangeEvent<HTMLInputElement>) {\n    //@ts-ignore\n    this.setState({\n      ...this.state,\n      scale: 50,\n      //@ts-ignore\n      img: URL.createObjectURL(ev.target.files[0]),\n      showResult: false\n    });\n  }\n\n  setImage(img: string) {\n    this.setState({\n      ...this.state,\n      //@ts-ignore\n      img: \"img/\" + img,\n      scale: 50,\n      showResult: false\n    });\n  }\n\n  getImageWidth(scale: number) {\n    const width = Math.round(400*(scale/50) + 50);\n\n    return Math.floor(width/32)*32;\n  }\n\n  async setModel(name: string) {\n    this.setState({\n      ...this.state,\n      model: name\n    })\n    this.model = await loadModel(name);\n  }\n\n  render() {\n    let img;\n    let scale = 50;\n    let croppedSize = 50;\n    let showResult = false;\n    if (this.state) {\n      img = this.state.img;\n      scale = this.state.scale || 50;\n      croppedSize = this.state.croppedSize;\n      showResult = this.state.showResult;\n    }\n\n    const width = this.getImageWidth(scale);\n\n    return (\n      <div className=\"App\">\n        <h1>Style transfer</h1>\n        <label htmlFor=\"model\">Choose a style:</label> <select id=\"model\" onChange={x => this.setModel(x.target.value)}>\n          {\n            models.map(x => (\n              <option value={x} key={x}>{x}</option>\n            ))\n          }\n        </select><br/>\n        <label htmlFor=\"file\">Choose an image:</label> <input type='file' id=\"file\" onChange={x => this.fileSelected(x)}/><br/>\n        Or use one of the examples:\n        <table>\n          <tr>\n            {imgs.map(img => (\n              <td>\n                <img src={\"img/\" + img}\n                  height={50} onClick={() => this.setImage(img)}\n                  className=\"exampleImage\" alt=\"Example\"></img>\n              </td>\n            ))}\n          </tr>\n        </table>\n        { img !== undefined ? (<>\n            <div className=\"slidecontainer\">\n              Scale: <input type=\"range\" min=\"1\" max=\"100\" defaultValue={scale}\n                className=\"slider\" id=\"myRange\"\n                //@ts-ignore\n                onChange={ev => this.setState({...this.state, showResult: false, scale: parseInt(ev.currentTarget.value)})}/>\n            </div>\n            <img id=\"img\" src={this.state.img} alt=\"Your upload\" width={width}/><br/>\n\n            <button onClick={() => this.getImageData()}>Run</button><br/>\n\n            {\n              showResult ? (\n                <canvas id=\"canvas\" width={croppedSize} height={croppedSize}></canvas>\n              ) : (<></>)\n            }\n          </>) : (<></>)}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}