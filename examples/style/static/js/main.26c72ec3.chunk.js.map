{"version":3,"sources":["../../../../lib/util/shape.ts","../../../lib/types.ts","../../../../../lib/ops/util/conv.ts","../../../../../lib/ops/cpu/basic.ts","../../../../../lib/ops/util/pool.ts","../../../../../lib/ops/cpu/pool.ts","../../../../../lib/ops/cpu/pad.ts","../../../../../lib/tensor/cpu/tensor.ts","../../../../../lib/ops/cpu/matMul.ts","../../../../../lib/ops/cpu/gemm.ts","../../../../../lib/ops/cpu/sum.ts","../../../../../lib/ops/cpu/sumSquare.ts","../../../../../lib/ops/cpu/product.ts","../../../../../lib/ops/cpu/max.ts","../../../../../lib/ops/cpu/min.ts","../../../../../lib/ops/cpu/reduceMean.ts","../../../../../lib/ops/cpu/reduceMeanSquare.ts","../../../../../lib/ops/cpu/conv.ts","../../../../../lib/ops/cpu/averagePool.ts","../../../../../lib/ops/cpu/concat.ts","../../../../../lib/ops/cpu/transpose.ts","../../../../../lib/ops/cpu/repeat.ts","../../../../../lib/ops/cpu/expand.ts","../../../../../lib/ops/cpu/gather.ts","../../../../../lib/ops/cpu/slice.ts","../../../../../lib/ops/cpu/upsample.ts","../../../../../lib/ops/cpu/normalize.ts","../../../../lib/util/bst.ts","../../../../lib/util/avl.ts","../../../../lib/util/math.ts","../../../../../lib/tensor/gpu/memory.ts","../../../../../lib/tensor/gpu/gl.ts","../../../../../lib/ops/gpu/util.ts","../../../../../lib/ops/gpu/exp.ts","../../../../../lib/ops/gpu/log.ts","../../../../../lib/ops/gpu/sqrt.ts","../../../../../lib/ops/gpu/add.ts","../../../../../lib/ops/gpu/subtract.ts","../../../../../lib/ops/gpu/multiply.ts","../../../../../lib/ops/gpu/divide.ts","../../../../../lib/ops/gpu/matmul.ts","../../../../../lib/ops/gpu/sum.ts","../../../../../lib/ops/gpu/pool.ts","../../../../../lib/ops/gpu/product.ts","../../../../../lib/ops/gpu/max.ts","../../../../../lib/ops/gpu/min.ts","../../../../../lib/ops/gpu/conv.ts","../../../../../lib/ops/gpu/concat.ts","../../../../../lib/ops/gpu/gemm.ts","../../../../../lib/ops/gpu/abs.ts","../../../../../lib/ops/gpu/transpose.ts","../../../../../lib/ops/gpu/power.ts","../../../../../lib/ops/gpu/averagePool.ts","../../../../../lib/ops/gpu/clip.ts","../../../../../lib/ops/gpu/reduceMean.ts","../../../../../lib/ops/gpu/repeat.ts","../../../../../lib/ops/gpu/expand.ts","../../../../../lib/ops/gpu/copy.ts","../../../../../lib/ops/gpu/reduceMeanSquare.ts","../../../../../lib/ops/gpu/sumSquare.ts","../../../../../lib/ops/gpu/pad.ts","../../../../../lib/ops/gpu/gather.ts","../../../../../lib/ops/gpu/floor.ts","../../../../../lib/ops/gpu/ceil.ts","../../../../../lib/ops/gpu/slice.ts","../../../../../lib/ops/gpu/upsample.ts","../../../../../lib/ops/gpu/toTexture.ts","../../../../../lib/ops/gpu/normalize.ts","../../../../../lib/tensor/wasm/tensor.ts","../../../../../lib/tensor/gpu/tensor.ts","../../../../lib/util/convert.ts","../../../../lib/onnx/node.ts","../../../../lib/onnx/util.ts","../../../../lib/onnx/definitions.ts","../../../../../lib/onnx/nodes/constant.ts","../../../../../lib/onnx/nodes/add.ts","../../../../../lib/onnx/nodes/batchNormalization.ts","../../../../../lib/ops/cpu/cast.ts","../../../../../lib/onnx/nodes/cast.ts","../../../../../lib/onnx/nodes/ceil.ts","../../../../../lib/onnx/nodes/clip.ts","../../../../../lib/onnx/nodes/concat.ts","../../../../../lib/onnx/nodes/constantOfShape.ts","../../../../../lib/onnx/nodes/conv.ts","../../../../../lib/onnx/nodes/div.ts","../../../../../lib/onnx/nodes/exp.ts","../../../../../lib/onnx/nodes/expand.ts","../../../../../lib/onnx/nodes/floor.ts","../../../../../lib/onnx/nodes/gather.ts","../../../../../lib/onnx/nodes/gemm.ts","../../../../../lib/onnx/nodes/instanceNormalization.ts","../../../../../lib/onnx/nodes/matMul.ts","../../../../../lib/onnx/nodes/mul.ts","../../../../../lib/onnx/nodes/pad.ts","../../../../../lib/onnx/nodes/reduceMax.ts","../../../../../lib/onnx/nodes/reduceMean.ts","../../../../../lib/onnx/nodes/reduceSum.ts","../../../../../lib/onnx/nodes/reduceSumSquare.ts","../../../../../lib/onnx/nodes/relu.ts","../../../../../lib/onnx/nodes/reshape.ts","../../../../../lib/onnx/nodes/shape.ts","../../../../../lib/onnx/nodes/slice.ts","../../../../../lib/onnx/nodes/softmax.ts","../../../../../lib/onnx/nodes/sub.ts","../../../../../lib/onnx/nodes/tile.ts","../../../../../lib/onnx/nodes/transpose.ts","../../../../../lib/onnx/nodes/unsqueeze.ts","../../../../../lib/onnx/nodes/upsample.ts","../../../../lib/onnx/resolve.ts","../../../../lib/onnx/model.ts","inference.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["getSize","shape","i","this","Tensor","prototype","subtract","permutation","outputDimSize","inSize","kernel","a","poolResultShape","inputShape","resultShape","sumShape","ixMap","index","CPUTensor","k","M","aTranspose","bTranspose","cMMult","cOMult","n","result","ix","indexY","outputShape","incrementIndex","res","AVLTree","_AVLTree","left","currentNode","primeFactors","num","x","GPUTensor","upsample","WASMTensor","wasmTensor","to","arr","input","deletable","nodeId","node","inter","loadModel","name","fetch","arrayBuffer","buffer","model","tjs","OnnxModel","noConvertNodes","toGPU","models","App","props","undefined","scale","gpu","Float32Array","then","setState","el","document","getElementById","console","log","tensor","fromData","slice","height","width","cropSize","Math","min","halfSize","floor","widthSliceStart","heightSliceStart","sliced","delete","getImageWidth","state","scaled","croppedSize","getShape","transposed","transpose","multiplied","multiply","reshaped","reshape","forward","handleResult","showResult","sh","t","toTexture","getValues","context","getContext","id","createImageData","d","data","length","round","putImageData","ev","img","URL","createObjectURL","target","files","className","htmlFor","onChange","setModel","value","map","type","fileSelected","max","defaultValue","parseInt","currentTarget","src","alt","onClick","getImageData","React","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.26c72ec3.chunk.js","sourcesContent":["export function getSize(shape) {\n    if (shape.length === 0) {\n        return 0;\n    }\n    var size = 1;\n    for (var i = 0; i < shape.length; i += 1) {\n        size *= shape[i];\n    }\n    return size;\n}\nexport function computeStrides(shape) {\n    var rank = shape.length;\n    if (rank === 0) {\n        return [];\n    }\n    if (rank === 1) {\n        return [1];\n    }\n    var strides = new Array(rank);\n    strides[rank - 1] = 1;\n    if (shape[rank - 1] === 1) {\n        strides[rank - 1] = 0;\n    }\n    var lastStride = 1;\n    for (var i = rank - 2; i >= 0; i -= 1) {\n        lastStride = shape[i + 1] * lastStride;\n        if (shape[i] === 1) {\n            strides[i] = 0;\n        }\n        else {\n            strides[i] = lastStride;\n        }\n    }\n    return strides;\n}\nexport function indexToPos(index, strides, shape) {\n    var ix = 0;\n    for (var i = 0; i < index.length; i += 1) {\n        if (shape) {\n            if (index[i] < 0 || (index[i] >= shape[i] && shape[i] !== 1)) {\n                throw new Error('Invalid index');\n            }\n        }\n        ix += index[i] * strides[i];\n    }\n    return ix;\n}\nexport function posToIndex(pos, strides) {\n    var res = pos;\n    var rank = strides.length;\n    var index = new Array(rank);\n    for (var i = 0; i < index.length; i += 1) {\n        index[i] = Math.floor(res / strides[i]);\n        res %= strides[i];\n    }\n    return index;\n}\nexport function compareShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function checkEquivShapes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i] && a[i] !== 1 && b[i] !== 1) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function incrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] += 1;\n        if (index[i] >= shape[i]) {\n            index[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function decrementIndex(index, shape) {\n    for (var i = index.length - 1; i >= 0; i--) {\n        index[i] -= 1;\n        if (index[i] < 0) {\n            index[i] = shape[i] - 1;\n        }\n        else {\n            break;\n        }\n    }\n}\n//# sourceMappingURL=shape.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { compareShapes, getSize } from './util/shape';\nvar Tensor = /** @class */ (function () {\n    function Tensor() {\n    }\n    Tensor.prototype.compare = function (tensor, epsilon) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arrA, arrB, i, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!compareShapes(this.getShape(), tensor.getShape())) {\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.getValues()];\n                    case 1:\n                        arrA = _a.sent();\n                        return [4 /*yield*/, tensor.getValues()];\n                    case 2:\n                        arrB = _a.sent();\n                        if (epsilon !== undefined) {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (Math.abs(arrA[i] - arrB[i]) > epsilon) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        else {\n                            for (i = 0; i < arrA.length; i += 1) {\n                                if (arrA[i] !== arrB[i]) {\n                                    return [2 /*return*/, false];\n                                }\n                            }\n                        }\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    Tensor.prototype.getAxes = function (axes) {\n        var ax;\n        var sh = this.getShape();\n        if (axes === undefined) {\n            ax = [];\n            for (var i = 0; i < sh.length; i++) {\n                ax.push(i);\n            }\n        }\n        else if (!(axes instanceof Array)) {\n            ax = [axes];\n        }\n        else {\n            ax = axes;\n        }\n        return ax;\n    };\n    Tensor.prototype.sum = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sum_impl(ax, keepDims);\n    };\n    Tensor.prototype.sumSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.sumSquare_impl(ax, keepDims);\n    };\n    Tensor.prototype.product = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.product_impl(ax, keepDims);\n    };\n    Tensor.prototype.max = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.max_impl(ax, keepDims);\n    };\n    Tensor.prototype.min = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.min_impl(ax, keepDims);\n    };\n    Tensor.prototype.reduceMean = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMean_impl(ax, keepDims);\n    };\n    Tensor.prototype.reduceMeanSquare = function (axes, keepDims) {\n        var ax = this.getAxes(axes);\n        keepDims = keepDims || false;\n        return this.reduceMeanSquare_impl(ax, keepDims);\n    };\n    Tensor.prototype.conv = function (kernel, bias, dilations, group, pads, strides) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        dilations = dilations || new Array(dataRank).fill(1);\n        group = group || 1;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        return this.conv_impl(kernel, dilations, group, pads, strides, bias);\n    };\n    Tensor.prototype.pad = function (pads, mode, value) {\n        if (mode === undefined) {\n            mode = 'constant';\n        }\n        if (value === undefined) {\n            value = 0;\n        }\n        return this.pad_impl(pads, mode, value);\n    };\n    Tensor.prototype.averagePool = function (kernelShape, pads, strides, includePad) {\n        var sh = this.getShape();\n        var dataRank = sh.length - 2;\n        pads = pads || new Array(dataRank * 2).fill(0);\n        strides = strides || new Array(dataRank).fill(1);\n        includePad = includePad || false;\n        return this.averagePool_impl(kernelShape, pads, strides, includePad);\n    };\n    Tensor.prototype.reshape = function (shape, copy) {\n        var shSize = 1;\n        var negIndex = -1;\n        for (var i = 0; i < shape.length; i++) {\n            if (shape[i] === -1) {\n                negIndex = i;\n            }\n            else {\n                shSize *= shape[i];\n            }\n        }\n        if (copy === undefined) {\n            copy = true;\n        }\n        if (negIndex !== -1) {\n            var currShape = this.getShape();\n            var currSize = getSize(currShape);\n            var _shape = __spreadArrays(shape);\n            _shape[negIndex] = currSize / shSize;\n            return this.reshape_impl(_shape, copy);\n        }\n        return this.reshape_impl(shape, copy);\n    };\n    Tensor.prototype.alignShapes = function (shape1, shape2) {\n        var _a, _b;\n        if (compareShapes(shape1, shape2)) {\n            return [shape1, shape2, shape1];\n        }\n        if (shape1.length < shape2.length) {\n            shape1 = __spreadArrays(shape1);\n            var prepend = shape2.length - shape1.length;\n            (_a = shape1).unshift.apply(_a, new Array(prepend).fill(1));\n        }\n        else if (shape2.length < shape1.length) {\n            shape2 = __spreadArrays(shape2);\n            var prepend = shape1.length - shape2.length;\n            (_b = shape2).unshift.apply(_b, new Array(prepend).fill(1));\n        }\n        var resultShape = new Array(shape1.length).fill(1);\n        for (var i = 0; i < shape1.length; i++) {\n            resultShape[i] = Math.max(shape1[i], shape2[i]);\n        }\n        return [shape1, shape2, resultShape];\n    };\n    Tensor.prototype.alignTensor = function (tensor) {\n        var _a, _b;\n        var thisShape = this.getShape();\n        var thatShape = tensor.getShape();\n        if (compareShapes(thisShape, thatShape)) {\n            return [this, tensor, thisShape];\n        }\n        var th = this;\n        if (thisShape.length < thatShape.length) {\n            thisShape = __spreadArrays(thisShape);\n            var prepend = thatShape.length - thisShape.length;\n            (_a = thisShape).unshift.apply(_a, new Array(prepend).fill(1));\n            th = this.reshape(thisShape, false);\n        }\n        else if (thatShape.length < thisShape.length) {\n            thatShape = __spreadArrays(thatShape);\n            var prepend = thisShape.length - thatShape.length;\n            (_b = thatShape).unshift.apply(_b, new Array(prepend).fill(1));\n            tensor = tensor.reshape(thatShape, false);\n        }\n        var resultShape = new Array(thisShape.length).fill(1);\n        for (var i = 0; i < thisShape.length; i++) {\n            resultShape[i] = Math.max(thisShape[i], thatShape[i]);\n        }\n        return [th, tensor, resultShape];\n    };\n    Tensor.prototype.add = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.add_impl(th, tens, resultShape);\n    };\n    Tensor.prototype.subtract = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.subtract_impl(th, tens, resultShape);\n    };\n    Tensor.prototype.multiply = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.multiply_impl(th, tens, resultShape);\n    };\n    Tensor.prototype.divide = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.divide_impl(th, tens, resultShape);\n    };\n    Tensor.prototype.power = function (tensor) {\n        var _a = this.alignTensor(tensor), th = _a[0], tens = _a[1], resultShape = _a[2];\n        return this.power_impl(th, tens, resultShape);\n    };\n    Tensor.prototype.transpose = function (permutation) {\n        if (permutation === undefined) {\n            var shape = this.getShape();\n            var rank = shape.length;\n            permutation = [];\n            for (var i = 0; i < rank; i++) {\n                permutation.push(rank - i - 1);\n            }\n        }\n        return this.transpose_impl(permutation);\n    };\n    Tensor.prototype.softmax = function (axis) {\n        var max = this.max(axis, true);\n        var normalized = this.subtract(max);\n        var exp = normalized.exp();\n        var sum = exp.sum(axis, true);\n        var result = exp.divide(sum);\n        max.delete();\n        normalized.delete();\n        exp.delete();\n        sum.delete();\n        return result;\n    };\n    Tensor.prototype.gemm = function (b, aTranspose, bTranspose, alpha, c, beta) {\n        aTranspose = aTranspose || false;\n        bTranspose = bTranspose || false;\n        alpha = alpha !== undefined ? alpha : 1;\n        beta = beta !== undefined ? beta : 1;\n        if (c !== undefined) {\n            var aShape = this.getShape();\n            var cShape = c.getShape();\n            var aRank = aShape.length;\n            var cRank = cShape.length;\n            cShape = __spreadArrays(new Array(aRank - cRank).fill(1), cShape);\n            c = c.reshape(cShape);\n        }\n        return this.gemm_impl(b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    Tensor.prototype.slice = function (starts, ends, axes) {\n        var shape = this.getShape();\n        var rank = shape.length;\n        if (axes === undefined) {\n            axes = [];\n            for (var i = 0; i < rank; i++) {\n                axes.push(i);\n            }\n        }\n        starts = __spreadArrays(starts);\n        ends = __spreadArrays(ends);\n        for (var i = 0; i < axes.length; i++) {\n            var sh = shape[axes[i]];\n            if (starts[i] < 0) {\n                starts[i] += sh;\n            }\n            else if (starts[i] >= sh) {\n                starts[i] = sh;\n            }\n            if (ends[i] < 0) {\n                ends[i] += sh;\n            }\n            else if (ends[i] >= sh) {\n                ends[i] = sh;\n            }\n        }\n        return this.slice_impl(starts, ends, axes);\n    };\n    return Tensor;\n}());\nexport default Tensor;\n//# sourceMappingURL=types.js.map","export function outputDimSize(inSize, kernel, headPad, tailPad, dilation, stride) {\n    var dkernel = dilation * (kernel - 1) + 1;\n    return Math.floor(((inSize + headPad + tailPad - dkernel) / stride) + 1);\n}\nexport function outputDimsSize(inSizes, kernels, headPads, tailPads, dilations, strides) {\n    var result = [];\n    for (var i = 0; i < inSizes.length; i++) {\n        result.push(outputDimSize(inSizes[i], kernels[i], headPads[i], tailPads[i], dilations[i], strides[i]));\n    }\n    return result;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { checkEquivShapes, incrementIndex } from '../../util/shape';\nexport function positionWiseUnaryOp(a, op) {\n    var result = new CPUTensor(a.shape);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(i, op(a.get(i)));\n    }\n    return result;\n}\nexport function positionWiseBinaryOp(a, b, op, resultShape) {\n    if (!checkEquivShapes(a.shape, b.shape)) {\n        throw new Error('The shapes of the two tensors should be the same for a binary operation');\n    }\n    var result = new CPUTensor(resultShape);\n    var index = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < result.size; i += 1) {\n        result.set(index, op(a.get(index), b.get(index)));\n        incrementIndex(index, resultShape);\n    }\n    return result;\n}\nexport function exp(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.exp(o1); });\n}\nexport function log(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.log(o1); });\n}\nexport function sqrt(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.sqrt(o1); });\n}\nexport function abs(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.abs(o1); });\n}\nexport function floor(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.floor(o1); });\n}\nexport function ceil(a) {\n    return positionWiseUnaryOp(a, function (o1) { return Math.ceil(o1); });\n}\nexport function clip(a, min, max) {\n    var f = function (o1) { return o1; };\n    if (min !== undefined && max !== undefined) {\n        f = function (o1) { return Math.min(max, Math.max(min, o1)); };\n    }\n    else if (max !== undefined) {\n        f = function (o1) { return Math.min(max, o1); };\n    }\n    else if (min !== undefined) {\n        f = function (o1) { return Math.max(min, o1); };\n    }\n    return positionWiseUnaryOp(a, f);\n}\nexport function add(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 + o2; }, resultShape);\n}\nexport function subtract(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 - o2; }, resultShape);\n}\nexport function multiply(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 * o2; }, resultShape);\n}\nexport function divide(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return o1 / o2; }, resultShape);\n}\nexport function power(a, b, resultShape) {\n    return positionWiseBinaryOp(a, b, function (o1, o2) { return Math.pow(o1, o2); }, resultShape);\n}\n//# sourceMappingURL=basic.js.map","export function poolResultShape(inputShape, axes, keepDims) {\n    var resultShape = [];\n    var sumShape = [];\n    var ixMap = [];\n    for (var i = 0; i < inputShape.length; i++) {\n        if (!axes.includes(i)) {\n            resultShape.push(inputShape[i]);\n            ixMap.push(i);\n        }\n        else {\n            if (keepDims) {\n                resultShape.push(1);\n                ixMap.push(i);\n            }\n            sumShape.push(inputShape[i]);\n        }\n    }\n    if (resultShape.length === 0) {\n        resultShape.push(1);\n    }\n    return [resultShape, ixMap];\n}\n//# sourceMappingURL=pool.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex, indexToPos, computeStrides } from '../../util/shape';\nimport { poolResultShape } from '../util/pool';\nexport function pool(a, axes, operation, keepDims, postProcess) {\n    var inputShape = a.getShape();\n    var inputSize = getSize(inputShape);\n    var _a = poolResultShape(inputShape, axes, keepDims), resultShape = _a[0], ixMap = _a[1];\n    var resultSize = getSize(resultShape);\n    var resultStrides = computeStrides(resultShape);\n    var result = new CPUTensor(resultShape);\n    var initialized = new Array(resultSize).fill(false);\n    var index = new Array(inputShape.length).fill(0);\n    var outIndex = new Array(resultShape.length).fill(0);\n    for (var i = 0; i < inputSize; i++) {\n        for (var j = 0; j < ixMap.length; j++) {\n            outIndex[j] = index[ixMap[j]];\n        }\n        var outOffset = indexToPos(outIndex, resultStrides);\n        if (initialized[outOffset]) {\n            result.set(outIndex, operation(a.get(i), result.get(outIndex)));\n        }\n        else {\n            initialized[outOffset] = true;\n            result.set(outIndex, operation(a.get(i)));\n        }\n        incrementIndex(index, inputShape);\n    }\n    if (postProcess) {\n        for (var i = 0; i < result.size; i++) {\n            result.set(i, postProcess(result.get(i)));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=pool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function pad(x, pads, mode, value) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] += pads[i] + pads[i + rank];\n    }\n    var Y = new CPUTensor(resultShape);\n    var ix = new Array(rank).fill(0);\n    var inputIx = new Array(rank).fill(0);\n    for (var i = 0; i < Y.size; i++) {\n        var allInRange = true;\n        for (var j = 0; j < rank; j++) {\n            inputIx[j] = ix[j] - pads[j];\n            if (inputIx[j] < 0 || inputIx[j] >= x.shape[j]) {\n                allInRange = false;\n            }\n        }\n        Y.set(i, getPadValue(x, inputIx, mode, value, allInRange));\n        incrementIndex(ix, resultShape);\n    }\n    return Y;\n}\nfunction getPadValue(x, index, mode, value, allInRange) {\n    if (allInRange) {\n        return x.get(index);\n    }\n    var rank = x.shape.length;\n    if (mode === 'constant') {\n        return value;\n    }\n    else if (mode === 'edge') {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = 0;\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = x.shape[j] - 1;\n            }\n        }\n    }\n    else {\n        for (var j = 0; j < rank; j++) {\n            if (index[j] < 0) {\n                index[j] = -index[j];\n            }\n            else if (index[j] >= x.shape[j]) {\n                index[j] = 2 * x.shape[j] - index[j] - 2;\n            }\n        }\n    }\n    return x.get(index);\n}\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { averagePool } from '../../ops/cpu/averagePool';\nimport { abs, add, ceil, clip, divide, exp, floor, log, multiply, power, sqrt, subtract } from '../../ops/cpu/basic';\nimport { concat } from '../../ops/cpu/concat';\nimport { conv } from '../../ops/cpu/conv';\nimport { expand } from '../../ops/cpu/expand';\nimport { gather } from '../../ops/cpu/gather';\nimport { gemm } from '../../ops/cpu/gemm';\nimport { matMul } from '../../ops/cpu/matMul';\nimport { max } from '../../ops/cpu/max';\nimport { min } from '../../ops/cpu/min';\nimport { normalize } from '../../ops/cpu/normalize';\nimport { pad } from '../../ops/cpu/pad';\nimport { product } from '../../ops/cpu/product';\nimport { reduceMean } from '../../ops/cpu/reduceMean';\nimport { reduceMeanSquare } from '../../ops/cpu/reduceMeanSquare';\nimport { repeat } from '../../ops/cpu/repeat';\nimport { slice } from '../../ops/cpu/slice';\nimport { sum } from '../../ops/cpu/sum';\nimport { sumSquare } from '../../ops/cpu/sumSquare';\nimport { transpose } from '../../ops/cpu/transpose';\nimport { upsample } from '../../ops/cpu/upsample';\nimport Tensor from '../../types';\nimport { compareShapes, computeStrides, getSize, indexToPos } from '../../util/shape';\nvar CPUTensor = /** @class */ (function (_super) {\n    __extends(CPUTensor, _super);\n    function CPUTensor(shape, values, type) {\n        var _this = _super.call(this) || this;\n        _this.deleted = false;\n        _this.shape = shape;\n        _this.strides = computeStrides(shape);\n        _this.size = getSize(shape);\n        if (values !== undefined) {\n            if (values instanceof Float32Array || values instanceof Int32Array) {\n                _this.values = values;\n                _this.type = values instanceof Float32Array ? \"float\" : \"int\";\n            }\n            else if (type === \"int\") {\n                _this.values = Int32Array.from(values);\n                _this.type = \"int\";\n            }\n            else {\n                _this.values = Float32Array.from(values);\n                _this.type = \"float\";\n            }\n        }\n        else {\n            if (type === \"int\") {\n                _this.values = new Int32Array(_this.size);\n                _this.type = \"int\";\n            }\n            else {\n                _this.values = new Float32Array(_this.size);\n                _this.type = \"float\";\n            }\n        }\n        return _this;\n    }\n    CPUTensor.prototype.getValues = function () {\n        return Promise.resolve(this.values);\n    };\n    CPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    CPUTensor.prototype.cpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    CPUTensor.prototype.delete = function () {\n        this.values = undefined;\n        this.deleted = true;\n    };\n    CPUTensor.prototype.copy = function (newShape) {\n        if (newShape === undefined) {\n            newShape = __spreadArrays(this.shape);\n        }\n        var values = new Float32Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            values[i] = this.values[i];\n        }\n        return new CPUTensor(newShape, values);\n    };\n    CPUTensor.prototype.get = function (index) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides, this.shape);\n        }\n        else {\n            pos = index;\n        }\n        return this.values[pos];\n    };\n    CPUTensor.prototype.set = function (index, value) {\n        var pos;\n        if (Array.isArray(index)) {\n            pos = indexToPos(index, this.strides);\n        }\n        else {\n            pos = index;\n        }\n        this.values[pos] = value;\n    };\n    CPUTensor.prototype.exp = function () {\n        return exp(this);\n    };\n    CPUTensor.prototype.log = function () {\n        return log(this);\n    };\n    CPUTensor.prototype.sqrt = function () {\n        return sqrt(this);\n    };\n    CPUTensor.prototype.abs = function () {\n        return abs(this);\n    };\n    CPUTensor.prototype.floor = function () {\n        return floor(this);\n    };\n    CPUTensor.prototype.ceil = function () {\n        return ceil(this);\n    };\n    CPUTensor.prototype.clip = function (min, max) {\n        return clip(this, min, max);\n    };\n    CPUTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return add(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only subtract CPU tensor to CPU tensor');\n        }\n        return subtract(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return multiply(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return divide(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof CPUTensor) || !(th instanceof CPUTensor)) {\n            throw new Error('Can only take CPU tensor to power of CPU tensor');\n        }\n        return power(th, tensor, resultShape);\n    };\n    CPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only add CPU tensor to CPU tensor');\n        }\n        return matMul(this, tensor);\n    };\n    CPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof CPUTensor && (c === undefined || c instanceof CPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        return gemm(this, b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    CPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return sum(this, axes, keepDims);\n    };\n    CPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return sumSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return product(this, axes, keepDims);\n    };\n    CPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return max(this, axes, keepDims);\n    };\n    CPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return min(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return reduceMean(this, axes, keepDims);\n    };\n    CPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return reduceMeanSquare(this, axes, keepDims);\n    };\n    CPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias) {\n        if (!(kernel instanceof CPUTensor) || (bias !== undefined && !(bias instanceof CPUTensor))) {\n            throw new Error('Can only do convolution of CPU tensor with CPU tensor');\n        }\n        return conv(this, kernel, dilations, group, pads, strides, bias);\n    };\n    CPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return pad(this, pads, mode, value);\n    };\n    CPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return averagePool(this, kernelShape, pads, strides, includePad);\n    };\n    CPUTensor.prototype.reshape_impl = function (shape, copy) {\n        if (copy) {\n            return this.copy(shape);\n        }\n        else {\n            return new CPUTensor(shape, this.values, this.type);\n        }\n    };\n    CPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof CPUTensor)) {\n            throw new Error('Can only concat CPU tensor to CPU tensor');\n        }\n        return concat(this, tensor, axis);\n    };\n    CPUTensor.prototype.transpose_impl = function (permutation) {\n        return transpose(this, permutation);\n    };\n    CPUTensor.prototype.repeat = function (repeats) {\n        return repeat(this, repeats);\n    };\n    CPUTensor.prototype.expand = function (shape) {\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return expand(this.reshape(_shape, false), resultShape);\n    };\n    CPUTensor.prototype.gather = function (axis, indices) {\n        return gather(this, axis, indices);\n    };\n    CPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return slice(this, starts, ends, axes);\n    };\n    CPUTensor.prototype.upsample = function (scales) {\n        return upsample(this, scales);\n    };\n    CPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof CPUTensor) || !(variance instanceof CPUTensor) || !(scale instanceof CPUTensor) || !(bias instanceof CPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return normalize(this, mean, variance, epsilon, scale, bias);\n    };\n    return CPUTensor;\n}(Tensor));\nexport { CPUTensor };\n//# sourceMappingURL=tensor.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nexport function matMul(a, b) {\n    if (a.shape.length !== 2 || b.shape.length !== 2) {\n        throw new Error('Matmul expects both operands to have rank 2');\n    }\n    if (a.shape[1] !== b.shape[0]) {\n        throw new Error('Matmul expects dimension 1 of operand 1 to equal dimension 0 of operand 2');\n    }\n    var m = a.shape[0];\n    var n = a.shape[1];\n    var o = b.shape[1];\n    var result = new CPUTensor([m, o]);\n    for (var i = 0; i < m; i += 1) {\n        for (var k = 0; k < o; k += 1) {\n            var res = 0;\n            for (var j = 0; j < n; j += 1) {\n                res += a.get([i, j]) * b.get([j, k]);\n            }\n            result.set([i, k], res);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=matMul.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize } from '../../util/shape';\nexport function gemm(a, b, aTranspose, bTranspose, alpha, beta, c) {\n    var rank = a.shape.length;\n    var M = aTranspose ? a.shape[rank - 1] : a.shape[rank - 2];\n    var N = aTranspose ? a.shape[rank - 2] : a.shape[rank - 1];\n    var O = bTranspose ? b.shape[rank - 2] : b.shape[rank - 1];\n    var aBatchMult = M * N;\n    var bBatchMult = N * O;\n    var yBatchMult = M * O;\n    var aNMult = aTranspose ? M : 1;\n    var aMMult = aTranspose ? 1 : N;\n    var bNMult = bTranspose ? 1 : O;\n    var bOMult = bTranspose ? N : 1;\n    var cMMult = 0;\n    var cOMult = 0;\n    var cBatchMult = 0;\n    if (c !== undefined) {\n        cMMult = c.strides[rank - 2];\n        cOMult = c.strides[rank - 1];\n        var cBatchSize = getSize(c.shape.slice(0, rank - 2));\n        if (cBatchSize > 1) {\n            cBatchMult = c.shape[rank - 2] * c.shape[rank - 1];\n            if (cBatchMult === 1) {\n                cBatchMult = 0;\n            }\n        }\n        else {\n            cBatchMult = 0;\n        }\n    }\n    var batchShape = a.shape.slice(0, rank - 2);\n    var batchSize = getSize(batchShape);\n    if (batchSize === 0) {\n        batchSize = 1;\n    }\n    var resultShape = __spreadArrays(batchShape, [M, O]);\n    var Y = new CPUTensor(resultShape);\n    for (var i = 0; i < batchSize; i++) {\n        var aBase = i * aBatchMult;\n        var bBase = i * bBatchMult;\n        var yBase = i * yBatchMult;\n        var cBase = i * cBatchMult;\n        for (var m = 0; m < M; m++) {\n            for (var o = 0; o < O; o++) {\n                var result = 0;\n                for (var n = 0; n < N; n++) {\n                    result += a.get(aBase + m * aMMult + n * aNMult) * b.get(bBase + n * bNMult + o * bOMult);\n                }\n                result = alpha * result;\n                if (c !== undefined) {\n                    result += beta * c.get(cBase + m * cMMult + o * cOMult);\n                }\n                Y.set(yBase + m * O + o, result);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=gemm.js.map","import { pool } from './pool';\nexport function sum(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sum.js.map","import { pool } from './pool';\nexport function sumSquare(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return (a * a) + (b !== undefined ? b : 0);\n    }, keepDims);\n}\n//# sourceMappingURL=sumSquare.js.map","import { pool } from './pool';\nexport function product(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return a * (b !== undefined ? b : 1);\n    }, keepDims);\n}\n//# sourceMappingURL=product.js.map","import { pool } from './pool';\nexport function max(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.max(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=max.js.map","import { pool } from './pool';\nexport function min(a, axes, keepDims) {\n    return pool(a, axes, function (a, b) {\n        return Math.min(a, b !== undefined ? b : a);\n    }, keepDims);\n}\n//# sourceMappingURL=min.js.map","import { pool } from './pool';\nexport function reduceMean(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return a + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMean.js.map","import { pool } from './pool';\nexport function reduceMeanSquare(a, axes, keepDims) {\n    var poolSize = 1;\n    for (var i = 0; i < axes.length; i++) {\n        poolSize *= a.shape[axes[i]];\n    }\n    return pool(a, axes, function (a, b) {\n        return (a * a) + (b !== undefined ? b : 0);\n    }, keepDims, function (a) { return a / poolSize; });\n}\n//# sourceMappingURL=reduceMeanSquare.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function conv(x, w, dilations, group, pads, strides, bias) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var W = w.shape.slice(2);\n    var M = w.shape[0];\n    var CG = C / group;\n    var kernelSize = getSize(W);\n    var R = outputDimsSize(D, W, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), dilations, strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, M];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    var dataRank = R.length;\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var m = 0; m < M; m++) {\n            if (bias) {\n                var b = bias ? bias.get([m]) : 0;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    Y.set(outputIndices, b);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n            for (var cg = 0; cg < CG; cg++) {\n                var c = (m * CG + cg) % C;\n                var outputIndices = new Array(R.length).fill(0);\n                outputIndices.unshift(n, m);\n                for (var oIx = 0; oIx < outputSize; oIx++) {\n                    var result = Y.get(outputIndices);\n                    var kernelIndices = new Array(R.length).fill(0);\n                    kernelIndices.unshift(m, cg);\n                    for (var kIx = 0; kIx < kernelSize; kIx++) {\n                        var inputIx = [n, c];\n                        var skip = false;\n                        for (var axis = 0; axis < dataRank; axis++) {\n                            var stride = strides.length === 0 ? 1 : strides[axis];\n                            var pad = pads.length === 0 ? 0 : pads[axis];\n                            var dilation = dilations.length === 0 ? 1 : dilations[axis];\n                            var ix = outputIndices[axis + 2] * stride - pad + kernelIndices[axis + 2] * dilation;\n                            if (ix < 0 || ix >= D[axis]) {\n                                skip = true;\n                                break;\n                            }\n                            inputIx.push(ix);\n                        }\n                        if (!skip) {\n                            var Wi = w.get(kernelIndices);\n                            var Xi = x.get(inputIx);\n                            result += Wi * Xi;\n                        }\n                        incrementIndex(kernelIndices, w.shape);\n                    }\n                    Y.set(outputIndices, result);\n                    incrementIndex(outputIndices, Y.shape);\n                }\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=conv.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { getSize, incrementIndex } from '../../util/shape';\nimport { outputDimsSize } from '../util/conv';\nexport function averagePool(x, kernelShape, pads, strides, includePad) {\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var dataRank = D.length;\n    var kernelSize = getSize(kernelShape);\n    var R = outputDimsSize(D, kernelShape, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), new Array(dataRank).fill(1), strides);\n    var outputSize = getSize(R);\n    var outputShape = [N, C];\n    outputShape = outputShape.concat(R);\n    var Y = new CPUTensor(outputShape);\n    // Iterate over all batches\n    for (var n = 0; n < N; n++) {\n        // Iterate over all output channels\n        for (var c = 0; c < C; c++) {\n            var outputIndices = new Array(R.length).fill(0);\n            outputIndices.unshift(n, c);\n            for (var oIx = 0; oIx < outputSize; oIx++) {\n                var result = 0;\n                var kernelIndices = new Array(R.length).fill(0);\n                var count = 0;\n                for (var kIx = 0; kIx < kernelSize; kIx++) {\n                    var inputIx = [n, c];\n                    var skip = false;\n                    for (var axis = 0; axis < dataRank; axis++) {\n                        var stride = strides.length === 0 ? 1 : strides[axis];\n                        var pad = pads.length === 0 ? 0 : pads[axis];\n                        var ix = outputIndices[axis + 2] * stride - pad + kernelIndices[axis];\n                        if (ix < 0 || ix >= D[axis]) {\n                            skip = true;\n                            break;\n                        }\n                        inputIx.push(ix);\n                    }\n                    if (!skip) {\n                        var Xi = x.get(inputIx);\n                        result += Xi;\n                    }\n                    if (!skip || includePad) {\n                        count += 1;\n                    }\n                    incrementIndex(kernelIndices, kernelShape);\n                }\n                result = result / count;\n                Y.set(outputIndices, result);\n                incrementIndex(outputIndices, Y.shape);\n            }\n        }\n    }\n    return Y;\n}\n//# sourceMappingURL=averagePool.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nexport function concat(x, y, axis) {\n    var outputShape = __spreadArrays(x.shape);\n    outputShape[axis] += y.shape[axis];\n    var result = new CPUTensor(outputShape);\n    var indexX = 0;\n    var indexY = 0;\n    var ix = 0;\n    var iterXSize = result.strides[axis] * x.shape[axis];\n    var iterYSize = result.strides[axis] * y.shape[axis];\n    var outerIters = result.size / (axis > 0 ? result.strides[axis - 1] : result.size);\n    for (var i = 0; i < outerIters; i++) {\n        for (var j = 0; j < iterXSize; j++) {\n            result.set(ix, x.get(indexX));\n            ix++;\n            indexX++;\n        }\n        for (var j = 0; j < iterYSize; j++) {\n            result.set(ix, y.get(indexY));\n            ix++;\n            indexY++;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=concat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function transpose(x, permutation) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    var reversePerm = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[permutation[i]];\n        reversePerm[permutation[i]] = i;\n    }\n    var result = new CPUTensor(outputShape);\n    var resultStrides = result.strides;\n    var mappedStrides = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        mappedStrides[i] = resultStrides[reversePerm[i]];\n    }\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < x.size; i++) {\n        var outIx = 0;\n        for (var j = 0; j < rank; j++) {\n            outIx += index[j] * mappedStrides[j];\n        }\n        result.set(outIx, x.get(i));\n        incrementIndex(index, x.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=transpose.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function repeat(x, repeats) {\n    var rank = x.shape.length;\n    var outputShape = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = x.shape[i] * repeats[i];\n    }\n    var result = new CPUTensor(outputShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var inIndex = new Array(rank);\n        for (var j = 0; j < rank; j++) {\n            inIndex[j] = index[j] % x.shape[j];\n        }\n        result.set(i, x.get(inIndex));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=repeat.js.map","import { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function expand(x, resultShape) {\n    var rank = x.shape.length;\n    var result = new CPUTensor(resultShape);\n    var index = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        result.set(i, x.get(index));\n        incrementIndex(index, result.shape);\n    }\n    return result;\n}\n//# sourceMappingURL=expand.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function gather(x, axis, indices) {\n    var r = x.shape.length;\n    var q = indices.shape.length;\n    var resultRank = r + q - 1;\n    var resultShape = new Array(resultRank);\n    for (var i = 0; i < axis; i++) {\n        resultShape[i] = x.shape[i];\n    }\n    for (var i = 0; i < q; i++) {\n        resultShape[i + axis] = indices.shape[i];\n    }\n    for (var i = axis + 1; i < r; i++) {\n        resultShape[i + q - 1] = x.shape[i];\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(resultRank).fill(0);\n    var gatherIx;\n    var inputIx;\n    for (var i = 0; i < result.size; i++) {\n        gatherIx = outIx.slice(axis, axis + q);\n        var axIx = indices.get(gatherIx);\n        inputIx = __spreadArrays(outIx.slice(0, axis), [axIx], outIx.slice(axis + q));\n        result.set(i, x.get(inputIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=gather.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function slice(x, starts, ends, axis) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var axIx = 0;\n    for (var i = 0; i < rank && axIx < axis.length; i++) {\n        if (i == axis[axIx]) {\n            resultShape[i] = ends[axIx] - starts[axIx];\n            axIx++;\n        }\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx;\n    for (var i = 0; i < result.size; i++) {\n        inIx = __spreadArrays(outIx);\n        for (var j = 0; j < axis.length; j++) {\n            inIx[axis[j]] += starts[j];\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=slice.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function upsample(x, scales) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] = Math.floor(resultShape[i] * scales[i]);\n    }\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    var inIx = new Array(rank);\n    for (var i = 0; i < result.size; i++) {\n        for (var j = 0; j < rank; j++) {\n            inIx[j] = Math.floor(outIx[j] / scales[j]);\n        }\n        result.set(i, x.get(inIx));\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=upsample.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from '../../tensor/cpu/tensor';\nimport { incrementIndex } from '../../util/shape';\nexport function normalize(x, mean, variance, epsilon, scale, bias) {\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var result = new CPUTensor(resultShape, undefined, x.type);\n    var outIx = new Array(rank).fill(0);\n    for (var i = 0; i < result.size; i++) {\n        var res = (x.get(outIx) - mean.get(outIx)) / Math.sqrt(variance.get(outIx) + epsilon);\n        res = res * scale.get(outIx) + bias.get(outIx);\n        result.set(i, res);\n        incrementIndex(outIx, resultShape);\n    }\n    return result;\n}\n//# sourceMappingURL=normalize.js.map","/*\n * Default compareKeys function will work for numbers, strings and dates\n */\nexport function defaultCompareKeysFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    if (a === b) {\n        return 0;\n    }\n    var err = new Error(\"Couldn't compare elements\");\n    throw err;\n}\n// Append all elements in toAppend to array\nfunction append(array, toAppend) {\n    for (var i = 0; i < toAppend.length; i++) {\n        array.push(toAppend[i]);\n    }\n}\nvar BinarySearchTree = /** @class */ (function () {\n    function BinarySearchTree(options) {\n        options = options || {};\n        this.left = null;\n        this.right = null;\n        this.parent = options.parent !== undefined ? options.parent : null;\n        if (options.hasOwnProperty('key')) {\n            this.key = options.key;\n        }\n        this.value = options.hasOwnProperty('value') ? [options.value] : [];\n        this.unique = options.unique || false;\n        this.compareKeys = options.compareKeys || defaultCompareKeysFunction;\n        this.compareValues = options.compareValues || (function (a, b) { return a === b; });\n    }\n    BinarySearchTree.prototype.getMaxKeyDescendant = function () {\n        if (this.right) {\n            return this.right.getMaxKeyDescendant();\n        }\n        else {\n            return this;\n        }\n    };\n    BinarySearchTree.prototype.getMaxKey = function () {\n        return this.getMaxKeyDescendant().key;\n    };\n    BinarySearchTree.prototype.getMinKeyDescendant = function () {\n        if (this.left) {\n            return this.left.getMinKeyDescendant();\n        }\n        else {\n            return this;\n        }\n    };\n    BinarySearchTree.prototype.getMinKey = function () {\n        return this.getMinKeyDescendant().key;\n    };\n    BinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n        if (!this.hasOwnProperty('key')) {\n            return;\n        }\n        test(this.key, this.value);\n        if (this.left) {\n            this.left.checkAllNodesFullfillCondition(test);\n        }\n        if (this.right) {\n            this.right.checkAllNodesFullfillCondition(test);\n        }\n    };\n    BinarySearchTree.prototype.checkNodeOrdering = function () {\n        var _this = this;\n        if (!this.hasOwnProperty('key')) {\n            return;\n        }\n        if (this.left) {\n            this.left.checkAllNodesFullfillCondition(function (k, _v) {\n                if (_this.compareKeys(k, _this.key) >= 0) {\n                    throw new Error('Tree with root ' + _this.key + ' is not a binary search tree');\n                }\n                return true;\n            });\n            this.left.checkNodeOrdering();\n        }\n        if (this.right) {\n            this.right.checkAllNodesFullfillCondition(function (k, _v) {\n                if (_this.compareKeys(k, _this.key) <= 0) {\n                    throw new Error('Tree with root ' + _this.key + ' is not a binary search tree');\n                }\n                return true;\n            });\n            this.right.checkNodeOrdering();\n        }\n    };\n    BinarySearchTree.prototype.checkInternalPointers = function () {\n        if (this.left) {\n            if (this.left.parent !== this) {\n                throw new Error('Parent pointer broken for key ' + this.key);\n            }\n            this.left.checkInternalPointers();\n        }\n        if (this.right) {\n            if (this.right.parent !== this) {\n                throw new Error('Parent pointer broken for key ' + this.key);\n            }\n            this.right.checkInternalPointers();\n        }\n    };\n    BinarySearchTree.prototype.checkIsBST = function () {\n        this.checkNodeOrdering();\n        this.checkInternalPointers();\n        if (this.parent) {\n            throw new Error(\"The root shouldn't have a parent\");\n        }\n    };\n    BinarySearchTree.prototype.getNumberOfKeys = function () {\n        var res;\n        if (!this.hasOwnProperty('key')) {\n            return 0;\n        }\n        res = 1;\n        if (this.left) {\n            res += this.left.getNumberOfKeys();\n        }\n        if (this.right) {\n            res += this.right.getNumberOfKeys();\n        }\n        return res;\n    };\n    BinarySearchTree.prototype.createSimilar = function (options) {\n        options = options || {};\n        options.unique = this.unique;\n        options.compareKeys = this.compareKeys;\n        return new BinarySearchTree(options);\n    };\n    BinarySearchTree.prototype.createLeftChild = function (options) {\n        var leftChild = this.createSimilar(options);\n        leftChild.parent = this;\n        this.left = leftChild;\n        return leftChild;\n    };\n    BinarySearchTree.prototype.createRightChild = function (options) {\n        var rightChild = this.createSimilar(options);\n        rightChild.parent = this;\n        this.right = rightChild;\n        return rightChild;\n    };\n    BinarySearchTree.prototype.insert = function (key, value) {\n        // Empty tree, insert as root\n        if (!this.hasOwnProperty('key')) {\n            this.key = key;\n            this.value.push(value);\n            return;\n        }\n        // Same key as root\n        if (this.compareKeys(this.key, key) === 0) {\n            if (this.unique) {\n                var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n                throw err;\n            }\n            else {\n                this.value.push(value);\n            }\n            return;\n        }\n        if (this.compareKeys(key, this.key) < 0) {\n            // Insert in left subtree\n            if (this.left) {\n                this.left.insert(key, value);\n            }\n            else {\n                this.createLeftChild({ key: key, value: value });\n            }\n        }\n        else {\n            // Insert in right subtree\n            if (this.right) {\n                this.right.insert(key, value);\n            }\n            else {\n                this.createRightChild({ key: key, value: value });\n            }\n        }\n    };\n    BinarySearchTree.prototype.search = function (key) {\n        if (!this.hasOwnProperty('key')) {\n            return [];\n        }\n        if (this.compareKeys(this.key, key) === 0) {\n            return this.value;\n        }\n        if (this.compareKeys(key, this.key) < 0) {\n            if (this.left) {\n                return this.left.search(key);\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            if (this.right) {\n                return this.right.search(key);\n            }\n            else {\n                return [];\n            }\n        }\n    };\n    BinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n        var _this = this;\n        // No lower bound\n        if (!query.hasOwnProperty('gt') && !query.hasOwnProperty('gte')) {\n            return function () { return true; };\n        }\n        if (query.hasOwnProperty('gt') && query.hasOwnProperty('gte')) {\n            if (this.compareKeys(query.gte, query.gt) === 0) {\n                return function (key) { return _this.compareKeys(key, query.gt) > 0; };\n            }\n            if (this.compareKeys(query.gte, query.gt) > 0) {\n                return function (key) { return _this.compareKeys(key, query.gte) >= 0; };\n            }\n            else {\n                return function (key) { return _this.compareKeys(key, query.gt) > 0; };\n            }\n        }\n        if (query.hasOwnProperty('gt')) {\n            return function (key) { return _this.compareKeys(key, query.gt) > 0; };\n        }\n        else {\n            return function (key) { return _this.compareKeys(key, query.gte) >= 0; };\n        }\n    };\n    BinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n        var _this = this;\n        // No lower bound\n        if (!query.hasOwnProperty('lt') && !query.hasOwnProperty('lte')) {\n            return function () { return true; };\n        }\n        if (query.hasOwnProperty('lt') && query.hasOwnProperty('lte')) {\n            if (this.compareKeys(query.lte, query.lt) === 0) {\n                return function (key) { return _this.compareKeys(key, query.lt) < 0; };\n            }\n            if (this.compareKeys(query.lte, query.lt) < 0) {\n                return function (key) { return _this.compareKeys(key, query.lte) <= 0; };\n            }\n            else {\n                return function (key) { return _this.compareKeys(key, query.lt) < 0; };\n            }\n        }\n        if (query.hasOwnProperty('lt')) {\n            return function (key) { return _this.compareKeys(key, query.lt) < 0; };\n        }\n        else {\n            return function (key) { return _this.compareKeys(key, query.lte) <= 0; };\n        }\n    };\n    BinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n        var res = [];\n        if (!this.hasOwnProperty('key')) {\n            return [];\n        } // Empty tree\n        lbm = lbm || this.getLowerBoundMatcher(query);\n        ubm = ubm || this.getUpperBoundMatcher(query);\n        if (lbm(this.key) && this.left) {\n            append(res, this.left.betweenBounds(query, lbm, ubm));\n        }\n        if (lbm(this.key) && ubm(this.key)) {\n            for (var i = 0; i < this.value.length; i++) {\n                res.push({ key: this.key, value: this.value[i] });\n            }\n        }\n        if (ubm(this.key) && this.right) {\n            append(res, this.right.betweenBounds(query, lbm, ubm));\n        }\n        return res;\n    };\n    BinarySearchTree.prototype.betweenBoundsFirst = function (query, lbm, ubm) {\n        if (!this.hasOwnProperty('key')) {\n            return [];\n        } // Empty tree\n        lbm = lbm || this.getLowerBoundMatcher(query);\n        ubm = ubm || this.getUpperBoundMatcher(query);\n        if (lbm(this.key) && this.left) {\n            var res = this.left.betweenBoundsFirst(query, lbm, ubm);\n            if (res.length > 0) {\n                return res;\n            }\n            ;\n        }\n        if (lbm(this.key) && ubm(this.key)) {\n            if (this.value.length > 0) {\n                return [{ key: this.key, value: this.value[0] }];\n            }\n        }\n        if (ubm(this.key) && this.right) {\n            return this.right.betweenBoundsFirst(query, lbm, ubm);\n        }\n        return [];\n    };\n    BinarySearchTree.prototype.deleteIfLeaf = function () {\n        if (this.left || this.right) {\n            return false;\n        }\n        // The leaf is itself a root\n        if (!this.parent) {\n            delete this.key;\n            this.value = [];\n            return true;\n        }\n        if (this.parent.left === this) {\n            this.parent.left = null;\n        }\n        else {\n            this.parent.right = null;\n        }\n        return true;\n    };\n    BinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n        var child;\n        if (this.left && !this.right) {\n            child = this.left;\n        }\n        if (!this.left && this.right) {\n            child = this.right;\n        }\n        if (!child) {\n            return false;\n        }\n        // Root\n        if (!this.parent) {\n            this.key = child.key;\n            this.value = child.value;\n            this.left = null;\n            if (child.left) {\n                this.left = child.left;\n                child.left.parent = this;\n            }\n            this.right = null;\n            if (child.right) {\n                this.right = child.right;\n                child.right.parent = this;\n            }\n            return true;\n        }\n        if (this.parent.left === this) {\n            this.parent.left = child;\n            child.parent = this.parent;\n        }\n        else {\n            this.parent.right = child;\n            child.parent = this.parent;\n        }\n        return true;\n    };\n    BinarySearchTree.prototype.delete = function (key, value) {\n        var _this = this;\n        var newValues = [];\n        var replaceWith;\n        if (!this.hasOwnProperty('key')) {\n            return;\n        }\n        if (this.compareKeys(key, this.key) < 0) {\n            if (this.left) {\n                this.left.delete(key, value);\n            }\n            return;\n        }\n        if (this.compareKeys(key, this.key) > 0) {\n            if (this.right) {\n                this.right.delete(key, value);\n            }\n            return;\n        }\n        if (!(this.compareKeys(key, this.key) === 0)) {\n            return;\n        }\n        // Delete only a value\n        if (this.value.length > 1 && value !== undefined) {\n            this.value.forEach(function (d) {\n                if (!_this.compareValues(d, value)) {\n                    newValues.push(d);\n                }\n            });\n            this.value = newValues;\n            return;\n        }\n        // Delete the whole node\n        if (this.deleteIfLeaf()) {\n            return;\n        }\n        if (this.deleteIfOnlyOneChild()) {\n            return;\n        }\n        // We are in the case where the node to delete has two children\n        if (Math.random() >= 0.5) { // Randomize replacement to avoid unbalancing the tree too much\n            // Use the in-order predecessor\n            replaceWith = this.left.getMaxKeyDescendant();\n            this.key = replaceWith.key;\n            this.value = replaceWith.value;\n            if (this === replaceWith.parent) { // Special case\n                this.left = replaceWith.left;\n                if (replaceWith.left) {\n                    replaceWith.left.parent = replaceWith.parent;\n                }\n            }\n            else {\n                replaceWith.parent.right = replaceWith.left;\n                if (replaceWith.left) {\n                    replaceWith.left.parent = replaceWith.parent;\n                }\n            }\n        }\n        else {\n            // Use the in-order successor\n            replaceWith = this.right.getMinKeyDescendant();\n            this.key = replaceWith.key;\n            this.value = replaceWith.value;\n            if (this === replaceWith.parent) { // Special case\n                this.right = replaceWith.right;\n                if (replaceWith.right) {\n                    replaceWith.right.parent = replaceWith.parent;\n                }\n            }\n            else {\n                replaceWith.parent.left = replaceWith.right;\n                if (replaceWith.right) {\n                    replaceWith.right.parent = replaceWith.parent;\n                }\n            }\n        }\n    };\n    BinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n        if (this.left) {\n            this.left.executeOnEveryNode(fn);\n        }\n        fn(this);\n        if (this.right) {\n            this.right.executeOnEveryNode(fn);\n        }\n    };\n    BinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n        spacing = spacing || \"\";\n        console.log(spacing + \"* \" + this.key);\n        if (printData) {\n            console.log(spacing + \"* \" + this.value);\n        }\n        if (!this.left && !this.right) {\n            return;\n        }\n        if (this.left) {\n            this.left.prettyPrint(printData, spacing + \"  \");\n        }\n        else {\n            console.log(spacing + \"  *\");\n        }\n        if (this.right) {\n            this.right.prettyPrint(printData, spacing + \"  \");\n        }\n        else {\n            console.log(spacing + \"  *\");\n        }\n    };\n    return BinarySearchTree;\n}());\nexport { BinarySearchTree };\n//# sourceMappingURL=bst.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BinarySearchTree } from \"./bst\";\nvar AVLTree = /** @class */ (function () {\n    function AVLTree(options) {\n        this.tree = new _AVLTree(options);\n    }\n    AVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n    AVLTree.prototype.insert = function (key, value) {\n        var newTree = this.tree.insert(key, value);\n        // If newTree is undefined, that means its structure was not modified\n        if (newTree) {\n            this.tree = newTree;\n        }\n    };\n    AVLTree.prototype.delete = function (key, value) {\n        var newTree = this.tree.delete(key, value);\n        // If newTree is undefined, that means its structure was not modified\n        if (newTree) {\n            this.tree = newTree;\n        }\n    };\n    AVLTree.prototype.deleteFirst = function (key) {\n        var newTree = this.tree.deleteFirst(key);\n        // If newTree is undefined, that means its structure was not modified\n        if (newTree) {\n            this.tree = newTree;\n        }\n    };\n    AVLTree.prototype.getNumberOfKeys = function () {\n        return this.tree.getNumberOfKeys();\n    };\n    AVLTree.prototype.search = function (key) {\n        return this.tree.search(key);\n    };\n    AVLTree.prototype.betweenBounds = function (query) {\n        return this.tree.betweenBounds(query);\n    };\n    AVLTree.prototype.betweenBoundsFirst = function (query) {\n        return this.tree.betweenBoundsFirst(query);\n    };\n    AVLTree.prototype.prettyPrint = function (printData, spacing) {\n        this.tree.prettyPrint(printData, spacing);\n    };\n    AVLTree.prototype.executeOnEveryNode = function (fn) {\n        this.tree.executeOnEveryNode(fn);\n    };\n    return AVLTree;\n}());\nexport { AVLTree };\nvar _AVLTree = /** @class */ (function (_super) {\n    __extends(_AVLTree, _super);\n    function _AVLTree(options) {\n        var _this = _super.call(this, options) || this;\n        _this.leftRotation = function () {\n            var p = this;\n            var q = this.right;\n            var b;\n            var ah, bh, ch;\n            if (!q) {\n                return this;\n            } // No change\n            b = q.left;\n            // Alter tree structure\n            if (p.parent) {\n                q.parent = p.parent;\n                if (p.parent.left === p) {\n                    p.parent.left = q;\n                }\n                else {\n                    p.parent.right = q;\n                }\n            }\n            else {\n                q.parent = null;\n            }\n            q.left = p;\n            p.parent = q;\n            p.right = b;\n            if (b) {\n                b.parent = p;\n            }\n            // Update heights\n            ah = p.left ? p.left.height : 0;\n            bh = b ? b.height : 0;\n            ch = q.right ? q.right.height : 0;\n            p.height = Math.max(ah, bh) + 1;\n            q.height = Math.max(ch, p.height) + 1;\n            return q;\n        };\n        return _this;\n    }\n    _AVLTree.prototype.checkHeightCorrect = function () {\n        var leftH;\n        var rightH;\n        if (!this.hasOwnProperty('key')) {\n            return;\n        } // Empty tree\n        if (this.left && this.left.height === undefined) {\n            throw new Error(\"Undefined height for node \" + this.left.key);\n        }\n        if (this.right && this.right.height === undefined) {\n            throw new Error(\"Undefined height for node \" + this.right.key);\n        }\n        if (this.height === undefined) {\n            throw new Error(\"Undefined height for node \" + this.key);\n        }\n        leftH = this.left ? this.left.height : 0;\n        rightH = this.right ? this.right.height : 0;\n        if (this.height !== 1 + Math.max(leftH, rightH)) {\n            throw new Error(\"Height constraint failed for node \" + this.key);\n        }\n        if (this.left) {\n            this.left.checkHeightCorrect();\n        }\n        if (this.right) {\n            this.right.checkHeightCorrect();\n        }\n    };\n    _AVLTree.prototype.balanceFactor = function () {\n        var leftH = this.left ? this.left.height : 0;\n        var rightH = this.right ? this.right.height : 0;\n        return leftH - rightH;\n    };\n    _AVLTree.prototype.checkBalanceFactors = function () {\n        if (Math.abs(this.balanceFactor()) > 1) {\n            throw new Error('Tree is unbalanced at node ' + this.key);\n        }\n        if (this.left) {\n            this.left.checkBalanceFactors();\n        }\n        if (this.right) {\n            this.right.checkBalanceFactors();\n        }\n    };\n    _AVLTree.prototype.checkIsAVLT = function () {\n        _super.prototype.checkIsBST.call(this);\n        this.checkHeightCorrect();\n        this.checkBalanceFactors();\n    };\n    _AVLTree.prototype.rightRotation = function () {\n        var q = this;\n        var p = this.left;\n        var b, ah, bh, ch;\n        if (!p) {\n            return this;\n        }\n        b = p.right;\n        // Alter tree structure\n        if (q.parent) {\n            p.parent = q.parent;\n            if (q.parent.left === q) {\n                q.parent.left = p;\n            }\n            else {\n                q.parent.right = p;\n            }\n        }\n        else {\n            p.parent = null;\n        }\n        p.right = q;\n        q.parent = p;\n        q.left = b;\n        if (b) {\n            b.parent = q;\n        }\n        // Update heights\n        ah = p.left ? p.left.height : 0;\n        bh = b ? b.height : 0;\n        ch = q.right ? q.right.height : 0;\n        q.height = Math.max(bh, ch) + 1;\n        p.height = Math.max(ah, q.height) + 1;\n        return p;\n    };\n    _AVLTree.prototype.rightTooSmall = function () {\n        if (this.balanceFactor() <= 1) {\n            return this;\n        } // Right is not too small, don't change\n        if (this.left.balanceFactor() < 0) {\n            this.left.leftRotation();\n        }\n        return this.rightRotation();\n    };\n    _AVLTree.prototype.leftTooSmall = function () {\n        if (this.balanceFactor() >= -1) {\n            return this;\n        } // Left is not too small, don't change\n        if (this.right.balanceFactor() > 0) {\n            this.right.rightRotation();\n        }\n        return this.leftRotation();\n    };\n    _AVLTree.prototype.rebalanceAlongPath = function (path) {\n        var newRoot = this;\n        var rotated;\n        var i;\n        if (!this.hasOwnProperty('key')) {\n            delete this.height;\n            return this;\n        } // Empty tree\n        // Rebalance the tree and update all heights\n        for (i = path.length - 1; i >= 0; i -= 1) {\n            path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n            if (path[i].balanceFactor() > 1) {\n                rotated = path[i].rightTooSmall();\n                if (i === 0) {\n                    newRoot = rotated;\n                }\n            }\n            if (path[i].balanceFactor() < -1) {\n                rotated = path[i].leftTooSmall();\n                if (i === 0) {\n                    newRoot = rotated;\n                }\n            }\n        }\n        return newRoot;\n    };\n    _AVLTree.prototype.insert = function (key, value) {\n        var insertPath = [];\n        var currentNode = this;\n        // Empty tree, insert as root\n        if (!this.hasOwnProperty('key')) {\n            this.key = key;\n            this.value.push(value);\n            this.height = 1;\n            return this;\n        }\n        // Insert new leaf at the right place\n        while (true) {\n            // Same key: no change in the tree structure\n            if (currentNode.compareKeys(currentNode.key, key) === 0) {\n                if (currentNode.unique) {\n                    var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n                    throw err;\n                }\n                else {\n                    currentNode.value.push(value);\n                }\n                return this;\n            }\n            insertPath.push(currentNode);\n            if (currentNode.compareKeys(key, currentNode.key) < 0) {\n                if (!currentNode.left) {\n                    insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n                    break;\n                }\n                else {\n                    currentNode = currentNode.left;\n                }\n            }\n            else {\n                if (!currentNode.right) {\n                    insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n                    break;\n                }\n                else {\n                    currentNode = currentNode.right;\n                }\n            }\n        }\n        return this.rebalanceAlongPath(insertPath);\n    };\n    _AVLTree.prototype.createSimilar = function (options) {\n        options = options || {};\n        options.unique = this.unique;\n        options.compareKeys = this.compareKeys;\n        return new _AVLTree(options);\n    };\n    _AVLTree.prototype.delete = function (key, value) {\n        var newData = [];\n        var replaceWith;\n        var currentNode = this;\n        var deletePath = [];\n        if (!this.hasOwnProperty('key')) {\n            return this;\n        } // Empty tree\n        // Either no match is found and the function will return from within the loop\n        // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n        while (true) {\n            if (currentNode.compareKeys(key, currentNode.key) === 0) {\n                break;\n            }\n            deletePath.push(currentNode);\n            if (currentNode.compareKeys(key, currentNode.key) < 0) {\n                if (currentNode.left) {\n                    currentNode = currentNode.left;\n                }\n                else {\n                    return this; // Key not found, no modification\n                }\n            }\n            else {\n                // currentNode.compareKeys(key, currentNode.key) is > 0\n                if (currentNode.right) {\n                    currentNode = currentNode.right;\n                }\n                else {\n                    return this; // Key not found, no modification\n                }\n            }\n        }\n        // Delete only a value (no tree modification)\n        if (currentNode.value.length > 1 && value !== undefined) {\n            currentNode.value.forEach(function (d) {\n                if (!currentNode.compareValues(d, value)) {\n                    newData.push(d);\n                }\n            });\n            currentNode.value = newData;\n            return this;\n        }\n        // Delete a whole node\n        // Leaf\n        if (!currentNode.left && !currentNode.right) {\n            if (currentNode === this) { // This leaf is also the root\n                delete currentNode.key;\n                currentNode.value = [];\n                delete currentNode.height;\n                return this;\n            }\n            else {\n                if (currentNode.parent.left === currentNode) {\n                    currentNode.parent.left = null;\n                }\n                else {\n                    currentNode.parent.right = null;\n                }\n                return this.rebalanceAlongPath(deletePath);\n            }\n        }\n        // Node with only one child\n        if (!currentNode.left || !currentNode.right) {\n            replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n            if (currentNode === this) { // This node is also the root\n                replaceWith.parent = null;\n                return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n            }\n            else {\n                if (currentNode.parent.left === currentNode) {\n                    currentNode.parent.left = replaceWith;\n                    replaceWith.parent = currentNode.parent;\n                }\n                else {\n                    currentNode.parent.right = replaceWith;\n                    replaceWith.parent = currentNode.parent;\n                }\n                return this.rebalanceAlongPath(deletePath);\n            }\n        }\n        // Node with two children\n        // Use the in-order predecessor (no need to randomize since we actively rebalance)\n        deletePath.push(currentNode);\n        replaceWith = currentNode.left;\n        // Special case: the in-order predecessor is right below the node to delete\n        if (!replaceWith.right) {\n            currentNode.key = replaceWith.key;\n            currentNode.value = replaceWith.value;\n            currentNode.left = replaceWith.left;\n            if (replaceWith.left) {\n                replaceWith.left.parent = currentNode;\n            }\n            return this.rebalanceAlongPath(deletePath);\n        }\n        // After this loop, replaceWith is the right-most leaf in the left subtree\n        // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n        while (true) {\n            if (replaceWith.right) {\n                deletePath.push(replaceWith);\n                replaceWith = replaceWith.right;\n            }\n            else {\n                break;\n            }\n        }\n        currentNode.key = replaceWith.key;\n        currentNode.value = replaceWith.value;\n        replaceWith.parent.right = replaceWith.left;\n        if (replaceWith.left) {\n            replaceWith.left.parent = replaceWith.parent;\n        }\n        return this.rebalanceAlongPath(deletePath);\n    };\n    _AVLTree.prototype.deleteFirst = function (key) {\n        var replaceWith;\n        var currentNode = this;\n        var deletePath = [];\n        if (!this.hasOwnProperty('key')) {\n            return this;\n        } // Empty tree\n        // Either no match is found and the function will return from within the loop\n        // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n        while (true) {\n            if (currentNode.compareKeys(key, currentNode.key) === 0) {\n                break;\n            }\n            deletePath.push(currentNode);\n            if (currentNode.compareKeys(key, currentNode.key) < 0) {\n                if (currentNode.left) {\n                    currentNode = currentNode.left;\n                }\n                else {\n                    return this; // Key not found, no modification\n                }\n            }\n            else {\n                // currentNode.compareKeys(key, currentNode.key) is > 0\n                if (currentNode.right) {\n                    currentNode = currentNode.right;\n                }\n                else {\n                    return this; // Key not found, no modification\n                }\n            }\n        }\n        // Delete only a value (no tree modification)\n        if (currentNode.value.length > 1) {\n            currentNode.value = currentNode.value.slice(1);\n            return this;\n        }\n        // Delete a whole node\n        // Leaf\n        if (!currentNode.left && !currentNode.right) {\n            if (currentNode === this) { // This leaf is also the root\n                delete currentNode.key;\n                currentNode.value = [];\n                delete currentNode.height;\n                return this;\n            }\n            else {\n                if (currentNode.parent.left === currentNode) {\n                    currentNode.parent.left = null;\n                }\n                else {\n                    currentNode.parent.right = null;\n                }\n                return this.rebalanceAlongPath(deletePath);\n            }\n        }\n        // Node with only one child\n        if (!currentNode.left || !currentNode.right) {\n            replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n            if (currentNode === this) { // This node is also the root\n                replaceWith.parent = null;\n                return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n            }\n            else {\n                if (currentNode.parent.left === currentNode) {\n                    currentNode.parent.left = replaceWith;\n                    replaceWith.parent = currentNode.parent;\n                }\n                else {\n                    currentNode.parent.right = replaceWith;\n                    replaceWith.parent = currentNode.parent;\n                }\n                return this.rebalanceAlongPath(deletePath);\n            }\n        }\n        // Node with two children\n        // Use the in-order predecessor (no need to randomize since we actively rebalance)\n        deletePath.push(currentNode);\n        replaceWith = currentNode.left;\n        // Special case: the in-order predecessor is right below the node to delete\n        if (!replaceWith.right) {\n            currentNode.key = replaceWith.key;\n            currentNode.value = replaceWith.value;\n            currentNode.left = replaceWith.left;\n            if (replaceWith.left) {\n                replaceWith.left.parent = currentNode;\n            }\n            return this.rebalanceAlongPath(deletePath);\n        }\n        // After this loop, replaceWith is the right-most leaf in the left subtree\n        // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n        while (true) {\n            if (replaceWith.right) {\n                deletePath.push(replaceWith);\n                replaceWith = replaceWith.right;\n            }\n            else {\n                break;\n            }\n        }\n        currentNode.key = replaceWith.key;\n        currentNode.value = replaceWith.value;\n        replaceWith.parent.right = replaceWith.left;\n        if (replaceWith.left) {\n            replaceWith.left.parent = replaceWith.parent;\n        }\n        return this.rebalanceAlongPath(deletePath);\n    };\n    return _AVLTree;\n}(BinarySearchTree));\n//# sourceMappingURL=avl.js.map","export function primeFactors(num) {\n    return primeFactorsCompute(num);\n}\nexport function primeFactorsCompute(inputNum, result, repeat) {\n    if (result === void 0) { result = []; }\n    if (repeat === void 0) { repeat = true; }\n    if (!Number.isInteger(inputNum))\n        return result;\n    var num = Math.abs(inputNum);\n    if (num < 2)\n        return result;\n    var sqrt = Math.sqrt(num);\n    var x = 2;\n    if (num % x) {\n        x = 3;\n        if (num % x) {\n            x = 5;\n            var add = 2;\n            while ((num % x) && (x < sqrt)) {\n                // search numbers: 5, 7, 11, 13, 17, 19, 23...\n                x += add;\n                // add each time: 2, 4, 2, 4, 2, 4, 2...\n                add = 6 - add;\n            }\n        }\n    }\n    x = (x <= sqrt) ? x : num;\n    if (!repeat) {\n        var index = result.indexOf(x);\n        if (index < 0)\n            result.push(x);\n    }\n    else\n        result.push(x);\n    return (x === num) ? result : primeFactorsCompute(num / x, result, repeat);\n}\n//# sourceMappingURL=math.js.map","import { AVLTree } from \"../../util/avl\";\nimport { primeFactors } from \"../../util/math\";\nvar GPUMemoryAllocator = /** @class */ (function () {\n    function GPUMemoryAllocator(regl, maxSizeFactor) {\n        this.tree = new AVLTree({\n            compareValues: function (a, b) { return a.id === b.id; }\n        });\n        this.regl = regl;\n        this.entryId = 0;\n        this.maxSizeFactor = maxSizeFactor || 2;\n    }\n    GPUMemoryAllocator.prototype.allocate = function (size) {\n        var upperBound = size * this.maxSizeFactor;\n        var texSize = Math.ceil(size / 4) * 4;\n        if (texSize < upperBound) {\n            upperBound = texSize;\n        }\n        var results = this.tree.betweenBoundsFirst({ gte: size, lte: upperBound });\n        if (results.length === 0) {\n            var textureSize = Math.ceil(size / 4);\n            var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n            var framebuffer = this.regl.framebuffer({\n                width: width,\n                height: height,\n                depthStencil: false,\n                colorFormat: 'rgba',\n                colorType: 'float'\n            });\n            var memoryEntry = {\n                width: width,\n                height: height,\n                size: width * height * 4,\n                frameBuffer: framebuffer,\n                id: this.entryId++\n            };\n            return memoryEntry;\n        }\n        else {\n            var first = results[0];\n            this.tree.deleteFirst(first.key);\n            return first.value;\n        }\n    };\n    GPUMemoryAllocator.prototype.deallocate = function (entry) {\n        this.tree.insert(entry.size, entry);\n    };\n    GPUMemoryAllocator.prototype.allocateTexture = function (values) {\n        var textureSize = Math.ceil(values.length / 4);\n        var _a = this.getTextureDims(textureSize), width = _a.width, height = _a.height;\n        var arraySize = width * height * 4;\n        var vals = new Float32Array(arraySize);\n        for (var i = 0; i < values.length; i++) {\n            vals[i] = values[i];\n        }\n        for (var i = values.length; i < arraySize; i++) {\n            vals[i] = 0;\n        }\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: 'float',\n            data: vals,\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false\n        });\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateOfDimensions = function (width, height) {\n        var arraySize = width * height * 4;\n        var texture = this.regl.texture({\n            width: width,\n            height: height,\n            format: 'rgba',\n            type: 'float',\n        });\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: width,\n            height: height,\n            depthStencil: false\n        });\n        return {\n            width: width,\n            height: height,\n            size: arraySize,\n            frameBuffer: framebuffer,\n            id: this.entryId++\n        };\n    };\n    GPUMemoryAllocator.prototype.allocateFramebuffer = function (texture) {\n        var framebuffer = this.regl.framebuffer({\n            color: texture,\n            width: texture.width,\n            height: texture.height,\n            depthStencil: false\n        });\n        return {\n            width: texture.width,\n            height: texture.height,\n            size: texture.width * texture.height * 4,\n            frameBuffer: framebuffer,\n            id: this.entryId++\n        };\n    };\n    GPUMemoryAllocator.prototype.getTextureDims = function (size) {\n        var factors = primeFactors(size);\n        var width = 1;\n        var height = 1;\n        for (var i = 0; i < factors.length; i += 2) {\n            width *= factors[i];\n            if (i + 1 < factors.length) {\n                height *= factors[i + 1];\n            }\n        }\n        return { width: width, height: height };\n    };\n    return GPUMemoryAllocator;\n}());\nexport { GPUMemoryAllocator };\n//# sourceMappingURL=memory.js.map","import REGL from 'regl';\nimport { GPUMemoryAllocator } from './memory';\nvar canvas = document.createElement(\"canvas\");\nexport var glContext;\nexport var gl;\nexport var defaultAllocator;\nfunction setup() {\n    glContext = canvas.getContext(\"webgl\", {\n        failIfMajorPerformanceCaveat: false\n    });\n    gl = REGL({\n        gl: glContext,\n        extensions: ['OES_texture_float', 'WEBGL_color_buffer_float']\n    });\n    defaultAllocator = new GPUMemoryAllocator(gl);\n}\nsetup();\n//# sourceMappingURL=gl.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defaultAllocator, gl } from \"../../tensor/gpu/gl\";\nimport { GPUTensor } from \"../../tensor/gpu/tensor\";\nimport { getSize, computeStrides } from \"../../util/shape\";\nexport var maxRank = 10;\nexport var maxIterations = 10000000;\nexport function pad(arr, len) {\n    if (len === void 0) { len = maxRank; }\n    while (arr.length < len) {\n        arr.push(-1);\n    }\n    return arr;\n}\nexport function copyPad(arr, len) {\n    if (len === void 0) { len = maxRank; }\n    var result = Array.from(arr);\n    while (result.length < len) {\n        result.push(-1);\n    }\n    return result;\n}\nexport var utilFunctions = \"\\nint fromFloat(float f) {\\n  return int(floor(f+0.5));\\n}\\n\\nint coordinateToPos(vec2 coordinate, int textureWidth, int textureHeight) {\\n  int x = (fromFloat(coordinate.x*float(textureWidth*2))-1)/2;\\n  int y = (fromFloat(coordinate.y*float(textureHeight*2))-1)/2;\\n\\n  int pos = x + y*textureWidth;\\n\\n  return pos*4;\\n}\\n\\nvec2 posToCoordinate(int pos, int textureWidth, int textureHeight) {\\n  // 4 positions map to the same coordinate\\n  pos = pos/4;\\n\\n  int y = pos/textureWidth;\\n  int x = pos - y*textureWidth;\\n\\n  return vec2(float(x*2+1)/float(textureWidth*2), float(y*2+1)/float(textureHeight*2));\\n}\\n\\nint indexToPos(int index[\" + maxRank + \"], int strides[\" + maxRank + \"]) {\\n  int pos = 0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (strides[i] == -1) {\\n      break;\\n    }\\n    pos += index[i]*strides[i];\\n  }\\n  return pos;\\n}\\n\\nfloat getValueAtPos(int pos, int textureWidth, int textureHeight, sampler2D tex) {\\n  vec2 coord = posToCoordinate(pos, textureWidth, textureHeight);\\n  int res = pos - (pos/4)*4;\\n  vec4 val = texture2D(tex, coord);\\n  if (res == 0) {\\n    return val.r;\\n  } else if (res == 1) {\\n    return val.g;\\n  } else if (res == 2) {\\n    return val.b;\\n  } else {\\n    return val.a;\\n  }\\n}\\n\\nfloat getValueAt(int index[\" + maxRank + \"], int strides[\" + maxRank + \"], int textureWidth, int textureHeight, sampler2D tex) {\\n  int pos = indexToPos(index, strides);\\n  return getValueAtPos(pos, textureWidth, textureHeight, tex);\\n}\";\nvar copyCounter = 0;\nexport function posToIndex(strides, result, pos) {\n    var name = pos + \"_\" + copyCounter++;\n    return \"\\n  int \" + name + \" = \" + pos + \";\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (\" + strides + \"[i] == -1) {\\n      \" + result + \"[i] = -1;\\n    } else {\\n      if (\" + strides + \"[i] == 0) {\\n        \" + result + \"[i] = 0;\\n      } else {\\n        \" + result + \"[i] = \" + name + \"/\" + strides + \"[i];\\n        \" + name + \" = \" + name + \" - \" + strides + \"[i]*\" + result + \"[i]; // Stupid modulo hack\\n      }\\n    }\\n  }\";\n}\nexport function initIndex(index, rank) {\n    if (rank === undefined) {\n        return \"\\n      for (int i = 0; i < \" + maxRank + \"; i++) {\\n        \" + index + \"[i] = -1;\\n      }\";\n    }\n    else {\n        return \"\\n      for (int i = 0; i < \" + maxRank + \"; i++) {\\n        if (i < \" + rank + \") {\\n          \" + index + \"[i] = 0;\\n        } else {\\n          \" + index + \"[i] = -1;\\n        }\\n      }\";\n    }\n}\nexport function incrementIndex(index, shape) {\n    return \"\\n  for (int i = \" + maxRank + \" - 1; i >= 0; i--) {\\n    if (\" + shape + \"[i] != -1) {\\n      \" + index + \"[i] += 1;\\n      if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n        \" + index + \"[i] = 0;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  \";\n}\nexport function incrementConditional(index, shape, cond) {\n    return \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (\" + cond + \"[i] == 1) {\\n      \" + index + \"[i] += 1;\\n      if (\" + index + \"[i] >= \" + shape + \"[i]) {\\n        \" + index + \"[i] = 0;\\n      } else {\\n        break;\\n      }\\n    } else if (\" + cond + \"[i] == -1) {\\n      break;\\n    }\\n  }\\n  \";\n}\nexport var defaultMain = \"\\nvoid main() {\\n  int pos = coordinateToPos(uv, widthOutput, heightOutput);\\n\\n  vec4 result = vec4(0,0,0,0);\\n\\n  if (pos < sizeOutput) {\\n    int index[\" + maxRank + \"];\\n    \" + posToIndex('stridesOutput', 'index', 'pos') + \"\\n    result.r = process(index);\\n\\n    pos += 1;\\n\\n    if (pos < sizeOutput) {\\n      \" + posToIndex('stridesOutput', 'index', 'pos') + \"\\n      result.g = process(index);\\n\\n      pos += 1;\\n\\n      if (pos < sizeOutput) {\\n        \" + posToIndex('stridesOutput', 'index', 'pos') + \"\\n        result.b = process(index);\\n\\n        pos += 1;\\n\\n        if (pos < sizeOutput) {\\n          \" + posToIndex('stridesOutput', 'index', 'pos') + \"\\n          result.a = process(index);\\n        }\\n      }\\n    }\\n  }\\n\\n  gl_FragColor = result;\\n}\";\nfunction buildCompleteFragmentShader(fragmentShader, inputTextures) {\n    return \"\\n  precision highp float;\\n  \" + inputTextures.map(function (x) {\n        return \"\\n    uniform sampler2D \" + x + \";\\n    uniform int size\" + x + \";\\n    uniform int width\" + x + \";\\n    uniform int height\" + x + \";\\n    uniform int strides\" + x + \"[\" + maxRank + \"];\\n    uniform int shape\" + x + \"[\" + maxRank + \"];\\n    uniform int rank\" + x + \";\\n    \";\n    }).join('\\n') + \"\\n  uniform int sizeOutput;\\n  uniform int widthOutput;\\n  uniform int heightOutput;\\n  uniform int stridesOutput[\" + maxRank + \"];\\n  uniform int shapeOutput[\" + maxRank + \"];\\n  uniform int rankOutput;\\n  varying vec2 uv;\\n\\n  \" + utilFunctions + \"\\n\\n  \" + inputTextures.map(function (x) {\n        return \"\\n    float _\" + x + \"(int indices[\" + maxRank + \"]) {\\n      return getValueAt(indices, strides\" + x + \", width\" + x + \", height\" + x + \", \" + x + \");\\n    }\\n    \";\n    }).join('\\n') + \"\\n\\n  \" + fragmentShader + \"\\n  \";\n}\nexport function buildComp(inputTextures, fragmentShader, uniform_attrs) {\n    if (uniform_attrs === undefined) {\n        uniform_attrs = [];\n    }\n    var uniforms = {};\n    for (var _i = 0, inputTextures_1 = inputTextures; _i < inputTextures_1.length; _i++) {\n        var inputTexture = inputTextures_1[_i];\n        uniforms[inputTexture] = gl.prop(inputTexture);\n        uniform_attrs.push({ name: \"size\" + inputTexture });\n        uniform_attrs.push({ name: \"width\" + inputTexture });\n        uniform_attrs.push({ name: \"height\" + inputTexture });\n        uniform_attrs.push({ name: \"strides\" + inputTexture, length: maxRank });\n        uniform_attrs.push({ name: \"shape\" + inputTexture, length: maxRank });\n        uniform_attrs.push({ name: \"rank\" + inputTexture });\n    }\n    uniform_attrs.push({ name: \"sizeOutput\" });\n    uniform_attrs.push({ name: \"widthOutput\" });\n    uniform_attrs.push({ name: \"heightOutput\" });\n    uniform_attrs.push({ name: \"stridesOutput\", length: maxRank });\n    uniform_attrs.push({ name: \"shapeOutput\", length: maxRank });\n    uniform_attrs.push({ name: \"rankOutput\" });\n    for (var _a = 0, uniform_attrs_1 = uniform_attrs; _a < uniform_attrs_1.length; _a++) {\n        var uniform_attr = uniform_attrs_1[_a];\n        if (uniform_attr.length !== undefined) {\n            for (var i = 0; i < uniform_attr.length; i++) {\n                var name_1 = uniform_attr.name + \"[\" + i + \"]\";\n                uniforms[name_1] = gl.prop(name_1);\n            }\n        }\n        else {\n            uniforms[uniform_attr.name] = gl.prop(uniform_attr.name);\n        }\n    }\n    var result = gl({\n        frag: buildCompleteFragmentShader(fragmentShader, inputTextures),\n        vert: \"\\n      precision highp float;\\n      attribute vec2 position;\\n      varying vec2 uv;\\n      void main() {\\n        uv = 0.5 * (position + 1.0);\\n        gl_Position = vec4(position, 0, 1);\\n      }\",\n        attributes: {\n            position: [-4, -4, 4, -4, 0, 4]\n        },\n        uniforms: uniforms,\n        framebuffer: gl.prop('framebuffer'),\n        depth: {\n            enable: false\n        },\n        count: 3\n    });\n    return result;\n}\nexport function compute(op, resultShape, inputTensors, inputs) {\n    var resultSize = getSize(resultShape);\n    var result = defaultAllocator.allocate(resultSize);\n    var inputTextures = {};\n    for (var name_2 in inputTensors) {\n        inputTextures[name_2] = inputTensors[name_2].memory.frameBuffer;\n    }\n    if (inputs === undefined) {\n        inputs = {};\n    }\n    for (var name_3 in inputTensors) {\n        inputs[\"size\" + name_3] = inputTensors[name_3].size;\n        inputs[\"width\" + name_3] = inputTensors[name_3].memory.width;\n        inputs[\"height\" + name_3] = inputTensors[name_3].memory.height;\n        inputs[\"strides\" + name_3] = pad(computeStrides(inputTensors[name_3].getShape()));\n        inputs[\"shape\" + name_3] = copyPad(inputTensors[name_3].getShape());\n        inputs[\"rank\" + name_3] = inputTensors[name_3].getShape().length;\n    }\n    inputs['sizeOutput'] = resultSize;\n    inputs['widthOutput'] = result.width;\n    inputs['heightOutput'] = result.height;\n    inputs['stridesOutput'] = pad(computeStrides(resultShape));\n    inputs['shapeOutput'] = copyPad(resultShape);\n    inputs['rankOutput'] = resultShape.length;\n    op(__assign(__assign({ framebuffer: result.frameBuffer }, inputTextures), inputs));\n    return new GPUTensor(result, resultShape);\n}\n//# sourceMappingURL=util.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = exp(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function exp(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=exp.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = log(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function log(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=log.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = sqrt(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function sqrt(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=sqrt.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return _inputTensor1(index) + _inputTensor2(index);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader);\n}\nexport function add(tensor1, tensor2, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    });\n}\n//# sourceMappingURL=add.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return _inputTensor1(index) - _inputTensor2(index);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader);\n}\nexport function subtract(tensor1, tensor2, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    });\n}\n//# sourceMappingURL=subtract.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return _inputTensor1(index) * _inputTensor2(index);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader);\n}\nexport function multiply(tensor1, tensor2, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    });\n}\n//# sourceMappingURL=multiply.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return _inputTensor1(index) / _inputTensor2(index);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader);\n}\nexport function divide(tensor1, tensor2, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    });\n}\n//# sourceMappingURL=divide.js.map","import { buildComp, compute, maxRank, defaultMain, initIndex, maxIterations } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int k;\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int ix1[\" + maxRank + \"];\\n  \" + initIndex('ix1') + \"\\n  ix1[0] = index[0];\\n\\n  int ix2[\" + maxRank + \"];\\n  \" + initIndex('ix2') + \"\\n  ix2[1] = index[1];\\n\\n  float res = 0.0;\\n\\n  for (int i = 0; i < \" + maxIterations + \"; i++) {\\n    if (i >= k) {\\n      break;\\n    }\\n    ix1[1] = i;\\n    ix2[0] = i;\\n\\n    float v1 = _input1(ix1);\\n    float v2 = _input2(ix2);\\n    res += v1*v2;\\n  }\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['input1', 'input2'], fragmentShader, [{ name: 'k' }]);\n}\nexport function matmul(tensor1, tensor2) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var outputShape = [tensor1.getShape()[0], tensor2.getShape()[1]];\n    return compute(comp, outputShape, {\n        input1: tensor1,\n        input2: tensor2\n    }, {\n        k: tensor1.getShape()[1]\n    });\n}\n//# sourceMappingURL=matmul.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return a + \" + \" + b; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function sum(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=sum.js.map","import { computeStrides } from \"../../util/shape\";\nimport { poolResultShape } from \"../util/pool\";\nimport { buildComp, compute, maxRank, defaultMain, initIndex, maxIterations, pad, posToIndex, incrementConditional } from \"./util\";\nexport function fragmentShader(update, post, init) {\n    if (post === undefined) {\n        post = function (x) { return ''; };\n    }\n    if (init === undefined) {\n        init = function (x) { return x; };\n    }\n    return \"\\nuniform int mappedInputStrides[\" + maxRank + \"];\\nuniform int sumDims[\" + maxRank + \"];\\nuniform int sumSize;\\n\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n\\n  int inputPos = 0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (mappedInputStrides[i] == -1 || index[i] == -1) {\\n      break;\\n    }\\n    inputPos += mappedInputStrides[i]*index[i];\\n  }\\n\\n  \" + posToIndex('stridesinput1', 'inputIx', 'inputPos') + \"\\n\\n  float res = 0.0;\\n\\n  for (int i = 0; i < \" + maxIterations + \"; i++) {\\n    if (i >= sumSize) {\\n      break;\\n    }\\n    float curr = _input1(inputIx);\\n    if (i == 0) {\\n      res = \" + init('curr') + \";\\n    } else {\\n      res = \" + update('curr', 'res') + \";\\n    }\\n\\n    \" + incrementConditional('inputIx', 'shapeinput1', 'sumDims') + \"\\n  }\\n\\n  \" + post('res') + \"\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\n}\nexport function initComputation(fragShader) {\n    return buildComp(['input1'], fragShader, [\n        { name: 'mappedInputStrides', length: maxRank },\n        { name: 'sumDims', length: maxRank },\n        { name: 'sumSize' },\n    ]);\n}\nexport function performComputation(tensor1, axes, keepDims, comp) {\n    var _a = poolResultShape(tensor1.getShape(), axes, keepDims), outputShape = _a[0], ixMap = _a[1];\n    var inputStrides = computeStrides(tensor1.shape);\n    var mappedInputStrides = [];\n    for (var _i = 0, ixMap_1 = ixMap; _i < ixMap_1.length; _i++) {\n        var i = ixMap_1[_i];\n        mappedInputStrides.push(inputStrides[i]);\n    }\n    var sumSize = 1;\n    var sumDims = new Array(tensor1.shape.length).fill(0);\n    for (var i = 0; i < axes.length; i++) {\n        sumDims[axes[i]] = 1;\n        sumSize *= tensor1.shape[axes[i]];\n    }\n    return compute(comp, outputShape, {\n        input1: tensor1,\n    }, {\n        mappedInputStrides: pad(mappedInputStrides),\n        sumDims: pad(sumDims),\n        sumSize: sumSize\n    });\n}\n//# sourceMappingURL=pool.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return a + \" * \" + b; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function product(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=product.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return \"max(\" + a + \", \" + b + \")\"; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function max(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=max.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return \"min(\" + a + \", \" + b + \")\"; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function min(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=min.js.map","import { getSize } from \"../../util/shape\";\nimport { outputDimsSize } from \"../util/conv\";\nimport { buildComp, compute, maxRank, defaultMain, initIndex, maxIterations, incrementIndex, pad } from \"./util\";\nvar comp;\nvar compWithBias;\nvar updateInputIx = \"\\nfor (int d = 0; d < \" + (maxRank - 2) + \"; d++) {\\n  int stride = strides[d];\\n  int pad = pads[d];\\n  int dilation = dilations[d];\\n  if (stride == -1) {\\n    break;\\n  }\\n\\n  inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d+2]*dilation;\\n  if (inputIx[d+2] < 0 || inputIx[d+2] >= shapex[d+2]) {\\n    skip = true;\\n    break;\\n  }\\n}\\n\";\nvar variables = \"\\nuniform int CG;\\nuniform int kernelSize;\\nuniform int dataRank;\\nuniform int C;\\nuniform int dilations[\" + maxRank + \"];\\nuniform int pads[\" + maxRank + \"];\\nuniform int strides[\" + maxRank + \"];\\n\";\nvar mainBody = \"\\n  int n = index[0];\\n  int m = index[1];\\n\\n  int kernelIx[\" + maxRank + \"];\\n  \" + initIndex('kernelIx') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (i >= dataRank) {\\n      break;\\n    }\\n    kernelIx[i+2] = 0;\\n  }\\n  kernelIx[0] = m;\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n  inputIx[0] = n;\\n\\n  for (int cg = 0; cg < \" + maxIterations + \"; cg++) {\\n    if (cg >= CG) {\\n      break;\\n    }\\n    int c = m * CG + cg;\\n    int d = c/C;\\n    c = c - d*C;\\n    inputIx[1] = c;\\n    kernelIx[1] = cg;\\n    for (int kIx = 0; kIx < \" + maxIterations + \"; kIx++) {\\n      if (kIx >= kernelSize) {\\n        break;\\n      }\\n\\n      bool skip = false;\\n\\n      \" + updateInputIx + \"\\n\\n      if (!skip) {\\n        res += _x(inputIx) * _kernel(kernelIx);\\n      }\\n\\n      \" + incrementIndex('kernelIx', 'shapekernel') + \"\\n    }\\n  }\\n\";\nvar fragmentShaderBias = \"\\n\" + variables + \"\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int biasIndex[\" + maxRank + \"];\\n  \" + initIndex('biasIndex') + \"\\n  biasIndex[0] = index[1];\\n  float res = _bias(biasIndex);\\n\\n  \" + mainBody + \"\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nvar fragmentShader = \"\\n\" + variables + \"\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  float res = 0.0;\\n\\n  \" + mainBody + \"\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    var args = [\n        { name: 'CG' },\n        { name: 'kernelSize' },\n        { name: 'dataRank' },\n        { name: 'C' },\n        { name: 'dilations', length: maxRank },\n        { name: 'pads', length: maxRank },\n        { name: 'strides', length: maxRank }\n    ];\n    compWithBias = buildComp(['x', 'kernel', 'bias'], fragmentShaderBias, args);\n    comp = buildComp(['x', 'kernel'], fragmentShader, args);\n}\nexport function conv(x, kernel, dilations, group, pads, strides, bias) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var W = kernel.shape.slice(2);\n    var M = kernel.shape[0];\n    var CG = kernel.shape[1];\n    var kernelSize = getSize(W);\n    var R = outputDimsSize(D, W, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), dilations, strides);\n    var outputShape = [N, M];\n    outputShape = outputShape.concat(R);\n    var input = { x: x, kernel: kernel };\n    if (bias) {\n        input.bias = bias;\n    }\n    return compute(bias ? compWithBias : comp, outputShape, input, {\n        kernelSize: kernelSize,\n        CG: CG,\n        dataRank: D.length,\n        C: C,\n        dilations: pad(dilations),\n        pads: pad(pads.slice(0, pads.length / 2)),\n        strides: pad(strides)\n    });\n}\n//# sourceMappingURL=conv.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int axis;\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  float res = 0.0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (i == axis) {\\n      if (index[i] >= shapeinputTensor1[i]) {\\n        index[i] = index[i] - shapeinputTensor1[i];\\n        res += _inputTensor2(index);\\n      } else {\\n        res += _inputTensor1(index);\\n      }\\n      break;\\n    }\\n  }\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader, [{ name: 'axis' }]);\n}\nexport function concat(tensor1, tensor2, axis) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var outputShape = __spreadArrays(tensor1.shape);\n    outputShape[axis] += tensor2.shape[axis];\n    return compute(comp, outputShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    }, {\n        axis: axis\n    });\n}\n//# sourceMappingURL=concat.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, maxRank, defaultMain, initIndex, maxIterations } from \"./util\";\nvar comp;\nvar compWithC;\nvar variables = \"\\nuniform int M;\\nuniform int N;\\nuniform int O;\\nuniform int rank;\\nuniform int aTranspose;\\nuniform int bTranspose;\\nuniform float alpha;\\nuniform float beta;\\n\";\nvar body = \"\\nint ixA[\" + maxRank + \"];\\n  \" + initIndex('ixA') + \"\\n  int ixB[\" + maxRank + \"];\\n  \" + initIndex('ixA') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (i >= rank - 2) {\\n      break;\\n    }\\n    ixA[i] = index[i];\\n    ixB[i] = index[i];\\n  }\\n\\n  int m = 0;\\n  int o = 0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (i == rank-2) {\\n      m = index[i];\\n      o = index[i+1];\\n\\n      if (aTranspose == 0) {\\n        ixA[i] = m;\\n      } else {\\n        ixA[i+1] = m;\\n      }\\n\\n      if (bTranspose == 0) {\\n        ixB[i+1] = o;\\n      } else {\\n        ixB[i] = o;\\n      }\\n\\n      break;\\n    }\\n  }\\n\\n  float res = 0.0;\\n\\n  for (int n = 0; n < \" + maxIterations + \"; n++) {\\n    if (n >= N) {\\n      break;\\n    }\\n    for (int i = 0; i < \" + maxRank + \"; i++) {\\n      if (i == rank-2) {\\n        if (aTranspose == 0) {\\n          ixA[i+1] = n;\\n        } else {\\n          ixA[i] = n;\\n        }\\n\\n        if (bTranspose == 0) {\\n          ixB[i] = n;\\n        } else {\\n          ixB[i+1] = n;\\n        }\\n\\n        break;\\n      }\\n    }\\n    res += _a(ixA) * _b(ixB);\\n  }\\n\\n  res = res*alpha;\\n\";\nvar fragmentShader = \"\\n\" + variables + \"\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  \" + body + \"\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nvar fragmentShaderWithC = \"\\n\" + variables + \"\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  \" + body + \"\\n\\n  res += beta*_c(index);\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    var uniforms = [\n        { name: 'M' }, { name: 'N' }, { name: 'O' }, { name: 'rank' },\n        { name: 'aTranspose' }, { name: 'bTranspose' }, { name: 'alpha' }, { name: 'beta' }\n    ];\n    comp = buildComp(['a', 'b'], fragmentShader, uniforms);\n    compWithC = buildComp(['a', 'b', 'c'], fragmentShaderWithC, uniforms);\n}\nexport function gemm(a, b, aTranspose, bTranspose, alpha, beta, c) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var rank = a.shape.length;\n    var M = aTranspose ? a.shape[rank - 1] : a.shape[rank - 2];\n    var N = aTranspose ? a.shape[rank - 2] : a.shape[rank - 1];\n    var O = bTranspose ? b.shape[rank - 2] : b.shape[rank - 1];\n    var batchShape = a.shape.slice(0, rank - 2);\n    var resultShape = __spreadArrays(batchShape, [M, O]);\n    var uniforms = {\n        M: M, N: N, O: O, rank: rank,\n        aTranspose: aTranspose ? 1 : 0,\n        bTranspose: bTranspose ? 1 : 0,\n        alpha: alpha, beta: beta\n    };\n    if (c !== undefined) {\n        return compute(compWithC, resultShape, {\n            a: a, b: b, c: c\n        }, uniforms);\n    }\n    else {\n        return compute(comp, resultShape, {\n            a: a, b: b\n        }, uniforms);\n    }\n}\n//# sourceMappingURL=gemm.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = abs(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function abs(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=abs.js.map","import { computeStrides } from \"../../util/shape\";\nimport { buildComp, compute, defaultMain, maxRank, pad } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int mappedStrides[\" + maxRank + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  return getValueAt(index, mappedStrides, widthx, heightx, x);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader, [{ name: 'mappedStrides', length: maxRank }]);\n}\nexport function transpose(tensor, permutation) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var rank = tensor.shape.length;\n    var outputShape = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = tensor.shape[permutation[i]];\n    }\n    var inputStrides = computeStrides(tensor.shape);\n    var mappedStrides = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        mappedStrides[i] = inputStrides[permutation[i]];\n    }\n    return compute(comp, outputShape, {\n        x: tensor\n    }, {\n        mappedStrides: pad(mappedStrides)\n    });\n}\n//# sourceMappingURL=transpose.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return pow(_inputTensor1(index), _inputTensor2(index));\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['inputTensor1', 'inputTensor2'], fragmentShader);\n}\nexport function power(tensor1, tensor2, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        inputTensor1: tensor1,\n        inputTensor2: tensor2\n    });\n}\n//# sourceMappingURL=power.js.map","import { getSize } from \"../../util/shape\";\nimport { outputDimsSize } from \"../util/conv\";\nimport { buildComp, compute, maxRank, defaultMain, initIndex, maxIterations, incrementIndex, pad } from \"./util\";\nvar comp;\nvar updateInputIx = \"\\nfor (int d = 0; d < \" + (maxRank - 2) + \"; d++) {\\n  int stride = strides[d];\\n  int pad = pads[d];\\n  if (stride == -1) {\\n    break;\\n  }\\n\\n  inputIx[d+2] = index[d+2]*stride - pad + kernelIx[d];\\n  if (inputIx[d+2] < 0 || inputIx[d+2] >= shapex[d+2]) {\\n    skip = true;\\n    break;\\n  }\\n}\\n\";\nvar variables = \"\\nuniform int kernelSize;\\nuniform int dataRank;\\nuniform int includePad;\\nuniform int kernelShape[\" + maxRank + \"];\\nuniform int pads[\" + maxRank + \"];\\nuniform int strides[\" + maxRank + \"];\\n\";\nvar fragmentShader = \"\\n\" + variables + \"\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  float res = 0.0;\\n  int count = 0;\\n\\n  int n = index[0];\\n  int c = index[1];\\n\\n  int kernelIx[\" + maxRank + \"];\\n  \" + initIndex('kernelIx') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (i >= dataRank) {\\n      break;\\n    }\\n    kernelIx[i] = 0;\\n  }\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n  inputIx[0] = n;\\n  inputIx[1] = c;\\n\\n  for (int kIx = 0; kIx < \" + maxIterations + \"; kIx++) {\\n    if (kIx >= kernelSize) {\\n      break;\\n    }\\n\\n    bool skip = false;\\n\\n    \" + updateInputIx + \"\\n\\n    if (!skip) {\\n      res += _x(inputIx);\\n    }\\n\\n    if (!skip || includePad == 1) {\\n      count += 1;\\n    }\\n\\n    \" + incrementIndex('kernelIx', 'kernelShape') + \"\\n  }\\n\\n  res = res / float(count);\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    var args = [\n        { name: 'kernelSize' },\n        { name: 'dataRank' },\n        { name: 'includePad' },\n        { name: 'pads', length: maxRank },\n        { name: 'strides', length: maxRank },\n        { name: 'kernelShape', length: maxRank }\n    ];\n    comp = buildComp(['x'], fragmentShader, args);\n}\nexport function averagePool(x, kernelShape, pads, strides, includePad) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var dataRank = x.shape.length - 2;\n    var N = x.shape[0];\n    var C = x.shape[1];\n    var D = x.shape.slice(2);\n    var kernelSize = getSize(kernelShape);\n    var R = outputDimsSize(D, kernelShape, pads.slice(0, pads.length / 2), pads.slice(pads.length / 2), new Array(dataRank).fill(1), strides);\n    var outputShape = [N, C];\n    outputShape = outputShape.concat(R);\n    return compute(comp, outputShape, { x: x }, {\n        kernelSize: kernelSize,\n        kernelShape: pad(kernelShape),\n        dataRank: D.length,\n        pads: pad(pads.slice(0, pads.length / 2)),\n        strides: pad(strides),\n        includePad: includePad ? 1 : 0\n    });\n}\n//# sourceMappingURL=averagePool.js.map","import { buildComp, compute } from \"./util\";\nvar compMinMax;\nvar compMin;\nvar compMax;\nvar fragmentShaderMinMax = \"\\nuniform float minVal;\\nuniform float maxVal;\\n\\nvoid main() {\\n  vec4 maxVec = vec4(maxVal,maxVal,maxVal,maxVal);\\n  vec4 minVec = vec4(minVal,minVal,minVal,minVal);\\n\\n  gl_FragColor = min(maxVec, max(minVec, texture2D(inputTensor, uv)));\\n}\";\nvar fragmentShaderMin = \"\\nuniform float minVal;\\n\\nvoid main() {\\n  vec4 minVec = vec4(minVal,minVal,minVal,minVal);\\n\\n  gl_FragColor = max(minVec, texture2D(inputTensor, uv));\\n}\";\nvar fragmentShaderMax = \"\\nuniform float maxVal;\\n\\nvoid main() {\\n  vec4 maxVec = vec4(maxVal,maxVal,maxVal,maxVal);\\n\\n  gl_FragColor = min(maxVec, texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    compMinMax = buildComp(['inputTensor'], fragmentShaderMinMax, [{ name: 'minVal' }, { name: 'maxVal' }]);\n    compMin = buildComp(['inputTensor'], fragmentShaderMin, [{ name: 'minVal' }]);\n    compMax = buildComp(['inputTensor'], fragmentShaderMax, [{ name: 'maxVal' }]);\n}\nexport function clip(tensor, min, max) {\n    if (compMinMax === undefined) {\n        initComp();\n    }\n    if (min !== undefined && max !== undefined) {\n        return compute(compMinMax, tensor.getShape(), {\n            inputTensor: tensor\n        }, { minVal: min, maxVal: max });\n    }\n    else if (min !== undefined) {\n        return compute(compMin, tensor.getShape(), {\n            inputTensor: tensor\n        }, { minVal: min });\n    }\n    else if (max !== undefined) {\n        return compute(compMax, tensor.getShape(), {\n            inputTensor: tensor\n        }, { maxVal: max });\n    }\n    return tensor.copy();\n}\n//# sourceMappingURL=clip.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return a + \" + \" + b; }, function (res) { return res + \" = \" + res + \"/float(sumSize);\"; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function reduceMean(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=reduceMean.js.map","import { buildComp, compute, copyPad, defaultMain, initIndex, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int repeats[\" + maxRank + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inIndex[\" + maxRank + \"];\\n  \" + initIndex('inIndex') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (repeats[i] == -1) {\\n      break;\\n    }\\n    int d = index[i] / shapex[i];\\n    inIndex[i] = index[i] - d*shapex[i];\\n  }\\n\\n  return _x(inIndex);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader, [{ name: 'repeats', length: maxRank }]);\n}\nexport function repeat(tensor, repeats) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var rank = tensor.shape.length;\n    var outputShape = new Array(rank);\n    for (var i = 0; i < rank; i++) {\n        outputShape[i] = tensor.shape[i] * repeats[i];\n    }\n    return compute(comp, outputShape, {\n        x: tensor\n    }, {\n        repeats: copyPad(repeats)\n    });\n}\n//# sourceMappingURL=repeat.js.map","import { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nfloat process(int index[\" + maxRank + \"]) {\\n  return _x(index);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader);\n}\nexport function expand(tensor, resultShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, resultShape, {\n        x: tensor,\n    });\n}\n//# sourceMappingURL=expand.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = texture2D(inputTensor, uv);\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function copy(tensor, newShape) {\n    if (comp === undefined) {\n        initComp();\n    }\n    if (newShape === undefined) {\n        newShape = __spreadArrays(tensor.getShape());\n    }\n    return compute(comp, newShape, {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=copy.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return \"(\" + a + \"*\" + a + \") + \" + b; }, function (res) { return res + \" = \" + res + \"/float(sumSize);\"; }, function (res) { return res + \"*\" + res; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function reduceMeanSquare(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=reduceMeanSquare.js.map","import { fragmentShader, initComputation, performComputation } from './pool';\nvar comp;\nvar fragShader = fragmentShader(function (a, b) { return \"(\" + a + \"*\" + a + \") + \" + b; }, undefined, function (res) { return res + \"*\" + res; });\nfunction initComp() {\n    comp = initComputation(fragShader);\n}\nexport function sumSquare(tensor1, axes, keepDims) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return performComputation(tensor1, axes, keepDims, comp);\n}\n//# sourceMappingURL=sumSquare.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, copyPad, defaultMain, initIndex, maxRank } from \"./util\";\nvar compConst;\nvar compReflect;\nvar compEdge;\nvar fragmentShaderConst = \"\\nuniform int pads[\" + maxRank * 2 + \"];\\nuniform float value;\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  float res = value;\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n  int outOfBounds = 0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n    inputIx[i] = index[i] - pads[i];\\n    if (inputIx[i] < 0 || inputIx[i] >= shapex[i]) {\\n      outOfBounds = 1;\\n      break;\\n    }\\n  }\\n\\n  if (outOfBounds == 0) {\\n    res = _x(inputIx);\\n  }\\n\\n  return res;\\n}\\n\\n\" + defaultMain + \"\\n\";\nvar fragmentShaderReflect = \"\\nuniform int pads[\" + maxRank * 2 + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n    inputIx[i] = index[i] - pads[i];\\n    if (inputIx[i] < 0) {\\n      inputIx[i] = -inputIx[i];\\n    } else if (inputIx[i] >= shapex[i]) {\\n      inputIx[i] = 2*shapex[i] - inputIx[i] - 2;\\n    }\\n  }\\n\\n  return _x(inputIx);\\n}\\n\\n\" + defaultMain + \"\\n\";\nvar fragmentShaderEdge = \"\\nuniform int pads[\" + maxRank * 2 + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inputIx[\" + maxRank + \"];\\n  \" + initIndex('inputIx') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n    inputIx[i] = index[i] - pads[i];\\n    if (inputIx[i] < 0) {\\n      inputIx[i] = 0;\\n    } else if (inputIx[i] >= shapex[i]) {\\n      inputIx[i] = shapex[i] - 1;\\n    }\\n  }\\n\\n  return _x(inputIx);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    compConst = buildComp(['x'], fragmentShaderConst, [{ name: 'pads', length: 2 * maxRank }, { name: 'value' }]);\n    compReflect = buildComp(['x'], fragmentShaderReflect, [{ name: 'pads', length: 2 * maxRank }]);\n    compEdge = buildComp(['x'], fragmentShaderEdge, [{ name: 'pads', length: 2 * maxRank }]);\n}\nexport function padOp(tensor, pads, mode, value) {\n    if (compConst === undefined) {\n        initComp();\n    }\n    var rank = tensor.shape.length;\n    var resultShape = __spreadArrays(tensor.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] += pads[i] + pads[i + rank];\n    }\n    if (mode === 'constant') {\n        return compute(compConst, resultShape, {\n            x: tensor,\n        }, {\n            pads: copyPad(pads, maxRank * 2),\n            value: value\n        });\n    }\n    else if (mode === 'reflect') {\n        return compute(compReflect, resultShape, {\n            x: tensor,\n        }, {\n            pads: copyPad(pads, maxRank * 2)\n        });\n    }\n    else {\n        return compute(compEdge, resultShape, {\n            x: tensor,\n        }, {\n            pads: copyPad(pads, maxRank * 2)\n        });\n    }\n}\n//# sourceMappingURL=pad.js.map","import { computeStrides } from \"../../util/shape\";\nimport { buildComp, compute, defaultMain, maxRank, pad } from \"./util\";\nvar comp;\nvar gatherMaxIxSize = 10;\nvar fragmentShader = \"\\nuniform int axis;\\nuniform int indexValues[\" + gatherMaxIxSize + \"];\\n\\nuniform int mappedIndexStrides[\" + maxRank + \"];\\nuniform int mappedInputStrides[\" + maxRank + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inputPos = 0;\\n  int indexPos = 0;\\n\\n  int strideAxis = 0;\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n    if (i == axis) {\\n      strideAxis = stridesx[i];\\n    }\\n    inputPos += mappedInputStrides[i]*index[i];\\n    indexPos += mappedIndexStrides[i]*index[i];\\n  }\\n\\n  for (int i = 0; i < \" + gatherMaxIxSize + \"; i++) {\\n    if (i == indexPos) {\\n      inputPos += indexValues[i]*strideAxis;\\n      break;\\n    }\\n  }\\n\\n  return getValueAtPos(inputPos, widthx, heightx, x);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader, [\n        { name: 'axis' },\n        { name: 'indexValues', length: gatherMaxIxSize },\n        { name: 'mappedInputStrides', length: maxRank },\n        { name: 'mappedIndexStrides', length: maxRank }\n    ]);\n}\nexport function gather(x, axis, indices) {\n    if (indices.size > gatherMaxIxSize) {\n        throw new Error(\"Gather on GPU can deal with at most \" + gatherMaxIxSize + \" indices, input had \" + indices.size);\n    }\n    if (comp === undefined) {\n        initComp();\n    }\n    var r = x.shape.length;\n    var q = indices.shape.length;\n    var inputStrides = computeStrides(x.shape);\n    var indexStrides = computeStrides(indices.shape);\n    var resultRank = r + q - 1;\n    var resultShape = new Array(resultRank);\n    var mappedInputStrides = new Array(resultRank).fill(0);\n    var mappedIndexStrides = new Array(resultRank).fill(0);\n    for (var i = 0; i < axis; i++) {\n        resultShape[i] = x.shape[i];\n        mappedInputStrides[i] = inputStrides[i];\n        mappedIndexStrides[i] = 0;\n    }\n    for (var i = 0; i < q; i++) {\n        resultShape[i + axis] = indices.shape[i];\n        mappedIndexStrides[i + axis] = indexStrides[i];\n        mappedInputStrides[i + axis] = 0;\n    }\n    for (var i = axis + 1; i < r; i++) {\n        resultShape[i + q - 1] = x.shape[i];\n        mappedInputStrides[i + q - 1] = inputStrides[i];\n        mappedIndexStrides[i + q - 1] = 0;\n    }\n    return compute(comp, resultShape, {\n        x: x\n    }, {\n        axis: axis,\n        indexValues: pad(Array.from(indices.values), gatherMaxIxSize),\n        mappedInputStrides: pad(mappedInputStrides),\n        mappedIndexStrides: pad(mappedIndexStrides)\n    });\n}\n//# sourceMappingURL=gather.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = floor(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function floor(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=floor.js.map","import { buildComp, compute } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nvoid main() {\\n  gl_FragColor = ceil(texture2D(inputTensor, uv));\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader);\n}\nexport function ceil(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(comp, tensor.getShape(), {\n        inputTensor: tensor\n    });\n}\n//# sourceMappingURL=ceil.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, defaultMain, initIndex, maxRank, pad } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int offsets[\" + maxRank + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inIx[\" + maxRank + \"];\\n  \" + initIndex('inIx') + \"\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n\\n    inIx[i] = index[i] + offsets[i];\\n  }\\n\\n  return _x(inIx);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader, [\n        { name: 'offsets', length: maxRank },\n    ]);\n}\nexport function slice(x, starts, ends, axes) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    var offsets = new Array(rank).fill(0);\n    var axIx = 0;\n    for (var i = 0; i < rank && axIx < axes.length; i++) {\n        if (i == axes[axIx]) {\n            resultShape[i] = ends[axIx] - starts[axIx];\n            offsets[i] = starts[axIx];\n            axIx++;\n        }\n    }\n    return compute(comp, resultShape, {\n        x: x\n    }, {\n        offsets: pad(offsets)\n    });\n}\n//# sourceMappingURL=slice.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, copyPad, defaultMain, initIndex, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform float scales[\" + maxRank + \"];\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  int inIx[\" + maxRank + \"];\\n  \" + initIndex('inIx') + \"\\n\\n  for (int i = 0; i < \" + maxRank + \"; i++) {\\n    if (index[i] == -1) {\\n      break;\\n    }\\n\\n    inIx[i] = int(floor(float(index[i]) / scales[i]));\\n  }\\n\\n  return _x(inIx);\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x'], fragmentShader, [\n        { name: 'scales', length: maxRank },\n    ]);\n}\nexport function upsample(x, scales) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var rank = x.shape.length;\n    var resultShape = __spreadArrays(x.shape);\n    for (var i = 0; i < rank; i++) {\n        resultShape[i] = Math.floor(resultShape[i] * scales[i]);\n    }\n    return compute(comp, resultShape, {\n        x: x\n    }, {\n        scales: copyPad(scales)\n    });\n}\n//# sourceMappingURL=upsample.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defaultAllocator } from \"../../tensor/gpu/gl\";\nimport { GPUTensor } from \"../../tensor/gpu/tensor\";\nimport { computeStrides } from \"../../util/shape\";\nimport { buildComp, copyPad, initIndex, maxRank, pad } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform int nChannels;\\nvoid main() {\\n  int x = (fromFloat(uv.x*float(widthOutput*2))-1)/2;\\n  int y = (fromFloat(uv.y*float(heightOutput*2))-1)/2;\\n\\n  int inIx[\" + maxRank + \"];\\n  \" + initIndex('inIx') + \"\\n\\n  inIx[0] = y;\\n  inIx[1] = x;\\n  inIx[2] = 0;\\n\\n  float a = _inputTensor(inIx);\\n  float b = 0.0;\\n  float c = 0.0;\\n  float d = 255.0;\\n\\n  if (nChannels >= 2) {\\n    inIx[2] = 1;\\n    b = _inputTensor(inIx);\\n  }\\n  if (nChannels >= 3) {\\n    inIx[2] = 2;\\n    c = _inputTensor(inIx);\\n  }\\n  if (nChannels >= 4) {\\n    inIx[2] = 3;\\n    d = _inputTensor(inIx);\\n  }\\n\\n  gl_FragColor = vec4(a,b,c,d);\\n}\";\nfunction initComp() {\n    comp = buildComp(['inputTensor'], fragmentShader, [{ name: 'nChannels' }]);\n}\nexport function toTexture(tensor) {\n    if (comp === undefined) {\n        initComp();\n    }\n    return compute(tensor);\n}\nexport function compute(input) {\n    var result = defaultAllocator.allocateOfDimensions(input.shape[1], input.shape[0]);\n    var inputs = {};\n    inputs[\"sizeinputTensor\"] = input.size;\n    inputs[\"widthinputTensor\"] = input.memory.width;\n    inputs[\"heightinputTensor\"] = input.memory.height;\n    inputs[\"stridesinputTensor\"] = pad(computeStrides(input.shape));\n    inputs[\"shapeinputTensor\"] = copyPad(input.shape);\n    inputs[\"rankinputTensor\"] = input.shape.length;\n    var resultShape = [input.shape[0], input.shape[1], 4];\n    inputs['sizeOutput'] = result.size;\n    inputs['widthOutput'] = result.width;\n    inputs['heightOutput'] = result.height;\n    inputs['stridesOutput'] = pad(computeStrides(resultShape));\n    inputs['shapeOutput'] = copyPad(resultShape);\n    inputs['rankOutput'] = resultShape.length;\n    comp(__assign({ framebuffer: result.frameBuffer, inputTensor: input.memory.frameBuffer, nChannels: input.shape[2] }, inputs));\n    return new GPUTensor(result, resultShape);\n}\n//# sourceMappingURL=toTexture.js.map","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { buildComp, compute, defaultMain, maxRank } from \"./util\";\nvar comp;\nvar fragmentShader = \"\\nuniform float epsilon;\\n\\nfloat process(int index[\" + maxRank + \"]) {\\n  float result = _x(index) - _mean(index);\\n  result = result / sqrt(_variance(index) + epsilon);\\n  result = result * _scale(index) + _bias(index);\\n  return result;\\n}\\n\\n\" + defaultMain + \"\\n\";\nfunction initComp() {\n    comp = buildComp(['x', 'mean', 'variance', 'scale', 'bias'], fragmentShader, [{ name: 'epsilon' }]);\n}\nexport function normalize(x, mean, variance, epsilon, scale, bias) {\n    if (comp === undefined) {\n        initComp();\n    }\n    var resultShape = __spreadArrays(x.shape);\n    return compute(comp, resultShape, {\n        x: x, mean: mean, variance: variance, scale: scale, bias: bias\n    }, {\n        epsilon: epsilon\n    });\n}\n//# sourceMappingURL=normalize.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes } from '../../util/shape';\nvar WASMT;\nexport var wasmLoaded = new Promise(function (resolve, reject) {\n    import('../../wasm/rust_wasm_tensor').then(function (x) {\n        WASMT = x.Tensor;\n        resolve();\n    });\n});\nvar WASMTensor = /** @class */ (function (_super) {\n    __extends(WASMTensor, _super);\n    function WASMTensor(values, shape) {\n        var _this = _super.call(this) || this;\n        if (values instanceof Float32Array) {\n            if (shape === undefined) {\n                throw new Error('Need the shape when creating a Wasm tensor from values');\n            }\n            _this.wasmTensor = WASMT.create(shape, values);\n        }\n        else {\n            _this.wasmTensor = values;\n        }\n        return _this;\n    }\n    WASMTensor.prototype.getValues = function () {\n        return Promise.resolve(this.wasmTensor.get_vals());\n    };\n    WASMTensor.prototype.getShape = function () {\n        return Array.from(this.wasmTensor.get_shape());\n    };\n    WASMTensor.prototype.wasm = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    WASMTensor.prototype.delete = function () {\n        this.wasmTensor.free();\n        this.wasmTensor = undefined;\n    };\n    WASMTensor.prototype.copy = function () {\n        return new WASMTensor(this.wasmTensor.copy());\n    };\n    WASMTensor.prototype.exp = function () {\n        return new WASMTensor(this.wasmTensor.exp());\n    };\n    WASMTensor.prototype.log = function () {\n        return new WASMTensor(this.wasmTensor.log());\n    };\n    WASMTensor.prototype.sqrt = function () {\n        return new WASMTensor(this.wasmTensor.sqrt());\n    };\n    WASMTensor.prototype.abs = function () {\n        return new WASMTensor(this.wasmTensor.abs());\n    };\n    WASMTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.addition(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only subtract WASM tensor from WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.subtraction(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only multiply WASM tensor with WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.multiply(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only divide WASM tensor by WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.divide(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof WASMTensor) || !(th instanceof WASMTensor)) {\n            throw new Error('Can only take WASM tensor to power of WASM tensor');\n        }\n        return new WASMTensor(th.wasmTensor.power(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only add WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.matmul(tensor.wasmTensor));\n    };\n    WASMTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof WASMTensor && (c === undefined || c instanceof WASMTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        if (c !== undefined) {\n            return new WASMTensor(this.wasmTensor.gemm_with_c(b.wasmTensor, aTranspose, bTranspose, alpha, c.wasmTensor, beta));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.gemm(b.wasmTensor, aTranspose, bTranspose, alpha));\n        }\n    };\n    WASMTensor.prototype.sum_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.sum_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.product_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.product(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.max_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.max(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.min_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.min(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return new WASMTensor(this.wasmTensor.reduce_mean_square(new Uint32Array(axes), keepDims));\n    };\n    WASMTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias) {\n        if (!(kernel instanceof WASMTensor) || (bias !== undefined && !(bias instanceof WASMTensor))) {\n            throw new Error('Can only do convolution of CPU tensor with CPU tensor');\n        }\n        if (bias !== undefined) {\n            return new WASMTensor(this.wasmTensor.conv_with_bias(kernel.wasmTensor, bias.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides)));\n        }\n        else {\n            return new WASMTensor(this.wasmTensor.conv(kernel.wasmTensor, new Uint32Array(dilations), group, new Uint32Array(pads), new Uint32Array(strides)));\n        }\n    };\n    WASMTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return new WASMTensor(this.wasmTensor.average_pool(new Uint32Array(kernelShape), new Uint32Array(pads), new Uint32Array(strides), includePad));\n    };\n    WASMTensor.prototype.reshape_impl = function (shape) {\n        var sh = new Uint32Array(shape);\n        return new WASMTensor(this.wasmTensor.reshape(sh), sh);\n    };\n    WASMTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof WASMTensor)) {\n            throw new Error('Can only concat WASM tensor to WASM tensor');\n        }\n        return new WASMTensor(this.wasmTensor.concat(tensor.wasmTensor, axis));\n    };\n    WASMTensor.prototype.transpose_impl = function (permutation) {\n        return new WASMTensor(this.wasmTensor.transpose(new Uint32Array(permutation)));\n    };\n    WASMTensor.prototype.clip = function (min, max) {\n        if (min !== undefined && max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip(min, max));\n        }\n        else if (min !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_min(min));\n        }\n        else if (max !== undefined) {\n            return new WASMTensor(this.wasmTensor.clip_max(max));\n        }\n        return this.copy();\n    };\n    WASMTensor.prototype.repeat = function (repeats) {\n        return new WASMTensor(this.wasmTensor.repeat(new Uint32Array(repeats)));\n    };\n    WASMTensor.prototype.expand = function (shape) {\n        var thisShape = this.getShape();\n        var _a = this.alignShapes(thisShape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(thisShape, resultShape)) {\n            return this.copy();\n        }\n        var reshaped = this.reshape(_shape, false);\n        return new WASMTensor(reshaped.wasmTensor.expand(new Uint32Array(resultShape)));\n    };\n    WASMTensor.prototype.pad_impl = function (pads, mode, value) {\n        return new WASMTensor(this.wasmTensor.pad(new Uint32Array(pads), WASMTensor.padModeToInt[mode], value));\n    };\n    WASMTensor.prototype.gather = function (axis, indices) {\n        return new WASMTensor(this.wasmTensor.gather(axis, indices.values, new Uint32Array(indices.shape)));\n    };\n    WASMTensor.prototype.floor = function () {\n        return new WASMTensor(this.wasmTensor.floor());\n    };\n    WASMTensor.prototype.ceil = function () {\n        return new WASMTensor(this.wasmTensor.ceil());\n    };\n    WASMTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return new WASMTensor(this.wasmTensor.slice(new Uint32Array(starts), new Uint32Array(ends), new Uint32Array(axes)));\n    };\n    WASMTensor.prototype.upsample = function (scales) {\n        return new WASMTensor(this.wasmTensor.upsample(new Float32Array(scales)));\n    };\n    WASMTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof WASMTensor) || !(variance instanceof WASMTensor) || !(scale instanceof WASMTensor) || !(bias instanceof WASMTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return new WASMTensor(this.wasmTensor.normalize(mean.wasmTensor, variance.wasmTensor, epsilon, scale.wasmTensor, bias.wasmTensor));\n    };\n    WASMTensor.padModeToInt = {\n        'constant': 0,\n        'reflect': 1,\n        'edge': 2\n    };\n    return WASMTensor;\n}(Tensor));\nexport { WASMTensor };\n//# sourceMappingURL=tensor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Tensor from '../../types';\nimport { compareShapes, getSize } from '../../util/shape';\nimport { exp } from '../../ops/gpu/exp';\nimport { log } from '../../ops/gpu/log';\nimport { sqrt } from '../../ops/gpu/sqrt';\nimport { add } from '../../ops/gpu/add';\nimport { subtract } from '../../ops/gpu/subtract';\nimport { multiply } from '../../ops/gpu/multiply';\nimport { divide } from '../../ops/gpu/divide';\nimport { matmul } from '../../ops/gpu/matmul';\nimport { sum } from '../../ops/gpu/sum';\nimport { product } from '../../ops/gpu/product';\nimport { max } from '../../ops/gpu/max';\nimport { min } from '../../ops/gpu/min';\nimport { defaultAllocator, gl } from './gl';\nimport { conv } from '../../ops/gpu/conv';\nimport { concat } from '../../ops/gpu/concat';\nimport { gemm } from '../../ops/gpu/gemm';\nimport { abs } from '../../ops/gpu/abs';\nimport { transpose } from '../../ops/gpu/transpose';\nimport { power } from '../../ops/gpu/power';\nimport { averagePool } from '../../ops/gpu/averagePool';\nimport { clip } from '../../ops/gpu/clip';\nimport { reduceMean } from '../../ops/gpu/reduceMean';\nimport { repeat } from '../../ops/gpu/repeat';\nimport { expand } from '../../ops/gpu/expand';\nimport { copy } from '../../ops/gpu/copy';\nimport { reduceMeanSquare } from '../../ops/gpu/reduceMeanSquare';\nimport { sumSquare } from '../../ops/gpu/sumSquare';\nimport { padOp } from '../../ops/gpu/pad';\nimport { gather } from '../../ops/gpu/gather';\nimport { floor } from '../../ops/gpu/floor';\nimport { ceil } from '../../ops/gpu/ceil';\nimport { slice } from '../../ops/gpu/slice';\nimport { upsample } from '../../ops/gpu/upsample';\nimport { toTexture } from '../../ops/gpu/toTexture';\nimport { normalize } from '../../ops/gpu/normalize';\nvar GPUTensor = /** @class */ (function (_super) {\n    __extends(GPUTensor, _super);\n    function GPUTensor(values, shape) {\n        var _this = _super.call(this) || this;\n        _this.deleted = false;\n        _this.size = getSize(shape);\n        _this.shape = shape;\n        if (values instanceof Float32Array) {\n            _this.memory = defaultAllocator.allocateTexture(values);\n        }\n        else {\n            _this.memory = values;\n        }\n        return _this;\n    }\n    GPUTensor.fromData = function (data) {\n        var texture = gl.texture({\n            data: data,\n            format: \"rgba\",\n            type: \"float\"\n        });\n        var memory = defaultAllocator.allocateFramebuffer(texture);\n        var width = texture.width;\n        var height = texture.height;\n        return new GPUTensor(memory, [height, width, 4]);\n    };\n    GPUTensor.prototype.toTexture = function () {\n        return toTexture(this);\n    };\n    GPUTensor.prototype.getValues = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            gl({ framebuffer: _this.memory.frameBuffer })(function () {\n                var result = new Float32Array(_this.memory.size);\n                result = gl.read(result);\n                resolve(result.subarray(0, _this.size));\n            });\n        });\n    };\n    GPUTensor.prototype.getShape = function () {\n        return this.shape;\n    };\n    GPUTensor.prototype.gpu = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this];\n            });\n        });\n    };\n    GPUTensor.prototype.delete = function () {\n        this.deleted = true;\n        defaultAllocator.deallocate(this.memory);\n        this.memory = undefined;\n    };\n    GPUTensor.prototype.copy = function () {\n        return copy(this);\n    };\n    GPUTensor.prototype.exp = function () {\n        return exp(this);\n    };\n    GPUTensor.prototype.log = function () {\n        return log(this);\n    };\n    GPUTensor.prototype.sqrt = function () {\n        return sqrt(this);\n    };\n    GPUTensor.prototype.abs = function () {\n        return abs(this);\n    };\n    GPUTensor.prototype.floor = function () {\n        return floor(this);\n    };\n    GPUTensor.prototype.ceil = function () {\n        return ceil(this);\n    };\n    GPUTensor.prototype.add_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only add GPU tensor to GPU tensor');\n        }\n        return add(th, tensor, resultShape);\n    };\n    GPUTensor.prototype.subtract_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only subtract GPU tensor from GPU tensor');\n        }\n        return subtract(th, tensor, resultShape);\n    };\n    GPUTensor.prototype.multiply_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only multiply GPU tensor with GPU tensor');\n        }\n        return multiply(th, tensor, resultShape);\n    };\n    GPUTensor.prototype.divide_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only divide GPU tensor by GPU tensor');\n        }\n        return divide(th, tensor, resultShape);\n    };\n    GPUTensor.prototype.power_impl = function (th, tensor, resultShape) {\n        if (!(tensor instanceof GPUTensor) || !(th instanceof GPUTensor)) {\n            throw new Error('Can only take GPU tensor to power of GPU tensor');\n        }\n        return power(th, tensor, resultShape);\n    };\n    GPUTensor.prototype.matMul = function (tensor) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only matrix multiply GPU tensor to GPU tensor');\n        }\n        return matmul(this, tensor);\n    };\n    GPUTensor.prototype.gemm_impl = function (b, aTranspose, bTranspose, alpha, beta, c) {\n        if (!(b instanceof GPUTensor && (c === undefined || c instanceof GPUTensor))) {\n            throw new Error('Can only do gemm with CPU tensors');\n        }\n        return gemm(this, b, aTranspose, bTranspose, alpha, beta, c);\n    };\n    GPUTensor.prototype.sum_impl = function (axes, keepDims) {\n        return sum(this, axes, keepDims);\n    };\n    GPUTensor.prototype.sumSquare_impl = function (axes, keepDims) {\n        return sumSquare(this, axes, keepDims);\n    };\n    GPUTensor.prototype.reduceMean_impl = function (axes, keepDims) {\n        return reduceMean(this, axes, keepDims);\n    };\n    GPUTensor.prototype.reduceMeanSquare_impl = function (axes, keepDims) {\n        return reduceMeanSquare(this, axes, keepDims);\n    };\n    GPUTensor.prototype.product_impl = function (axes, keepDims) {\n        return product(this, axes, keepDims);\n    };\n    GPUTensor.prototype.max_impl = function (axes, keepDims) {\n        return max(this, axes, keepDims);\n    };\n    GPUTensor.prototype.min_impl = function (axes, keepDims) {\n        return min(this, axes, keepDims);\n    };\n    GPUTensor.prototype.conv_impl = function (kernel, dilations, group, pads, strides, bias) {\n        if (!(kernel instanceof GPUTensor) || (bias !== undefined && !(bias instanceof GPUTensor))) {\n            throw new Error('Can only do convolution of GPU tensor with GPU tensor');\n        }\n        return conv(this, kernel, dilations, group, pads, strides, bias);\n    };\n    GPUTensor.prototype.averagePool_impl = function (kernelShape, pads, strides, includePad) {\n        return averagePool(this, kernelShape, pads, strides, includePad);\n    };\n    GPUTensor.prototype.reshape_impl = function (shape, _copy) {\n        if (_copy) {\n            return copy(this, shape);\n        }\n        else {\n            return new GPUTensor(this.memory, shape);\n        }\n    };\n    GPUTensor.prototype.concat = function (tensor, axis) {\n        if (!(tensor instanceof GPUTensor)) {\n            throw new Error('Can only concat GPU tensor to GPU tensor');\n        }\n        return concat(this, tensor, axis);\n    };\n    GPUTensor.prototype.transpose_impl = function (permutation) {\n        return transpose(this, permutation);\n    };\n    GPUTensor.prototype.clip = function (min, max) {\n        return clip(this, min, max);\n    };\n    GPUTensor.prototype.repeat = function (repeats) {\n        return repeat(this, repeats);\n    };\n    GPUTensor.prototype.expand = function (shape) {\n        var _a = this.alignShapes(this.shape, shape), _shape = _a[0], goal = _a[1], resultShape = _a[2];\n        if (compareShapes(this.shape, resultShape)) {\n            return this.copy();\n        }\n        return expand(this.reshape(_shape, false), resultShape);\n    };\n    GPUTensor.prototype.pad_impl = function (pads, mode, value) {\n        return padOp(this, pads, mode, value);\n    };\n    GPUTensor.prototype.gather = function (axis, indices) {\n        return gather(this, axis, indices);\n    };\n    GPUTensor.prototype.slice_impl = function (starts, ends, axes) {\n        return slice(this, starts, ends, axes);\n    };\n    GPUTensor.prototype.upsample = function (scales) {\n        return upsample(this, scales);\n    };\n    GPUTensor.prototype.normalize = function (mean, variance, epsilon, scale, bias) {\n        if (!(mean instanceof GPUTensor) || !(variance instanceof GPUTensor) || !(scale instanceof GPUTensor) || !(bias instanceof GPUTensor)) {\n            throw new Error('Can only normalize with CPU tensors');\n        }\n        return normalize(this, mean, variance, epsilon, scale, bias);\n    };\n    return GPUTensor;\n}(Tensor));\nexport { GPUTensor };\n//# sourceMappingURL=tensor.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../tensor/cpu/tensor\";\nimport { GPUTensor } from \"../tensor/gpu/tensor\";\nimport { WASMTensor } from \"../tensor/wasm/tensor\";\nexport function toCPU(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof CPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    return [2 /*return*/, new CPUTensor(tensor.getShape(), values)];\n            }\n        });\n    });\n}\nexport function toWASM(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof WASMTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new WASMTensor(values, new Uint32Array(tensor.getShape()))];\n            }\n        });\n    });\n}\nexport function toGPU(tensor) {\n    return __awaiter(this, void 0, void 0, function () {\n        var values;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (tensor instanceof GPUTensor) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [4 /*yield*/, tensor.getValues()];\n                case 1:\n                    values = _a.sent();\n                    if (tensor instanceof CPUTensor && values instanceof Int32Array) {\n                        return [2 /*return*/, tensor];\n                    }\n                    return [2 /*return*/, new GPUTensor(values, tensor.getShape())];\n            }\n        });\n    });\n}\n//# sourceMappingURL=convert.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport Long from \"long\";\nvar OnnxNode = /** @class */ (function () {\n    function OnnxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        this.attributes = {};\n        for (var i = 0; i < attributes.length; i++) {\n            this.attributes[attributes[i].name] = attributes[i];\n        }\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.onnxVersion = onnxVersion;\n        this.variableInputs = 0;\n        for (var i = 0; i < this.inputs.length; i++) {\n            if (constants[this.inputs[i]] === undefined) {\n                this.variableInputs++;\n            }\n        }\n    }\n    OnnxNode.prototype.initialize = function (resolveConstant) { };\n    OnnxNode.prototype.getAttribute = function (name) {\n        return this.attributes[name];\n    };\n    OnnxNode.prototype.getAttributeString = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var str = attr.s;\n            if (str !== undefined) {\n                return new TextDecoder(\"utf-8\").decode(str);\n            }\n            return undefined;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInts = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = this.attributes[name].ints;\n            for (var i = 0; i < result.length; i++) {\n                if (Long.isLong(result[i])) {\n                    result[i] = result[i].toNumber();\n                }\n            }\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeInt = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.i;\n            if (Long.isLong(result)) {\n                result = result.toNumber();\n            }\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeFloat = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.f;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.getAttributeTensor = function (name) {\n        var attr = this.attributes[name];\n        if (attr !== undefined) {\n            var result = attr.t;\n            return result;\n        }\n        return undefined;\n    };\n    OnnxNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    OnnxNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    OnnxNode.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    return OnnxNode;\n}());\nexport { OnnxNode };\n//# sourceMappingURL=node.js.map","import { CPUTensor } from \"../tensor/cpu/tensor\";\nimport { TENSOR_FLOAT, TENSOR_INT64 } from './definitions';\nimport Long from 'long';\nimport { getSize } from '../util/shape';\nexport function createTensor(tensorProto) {\n    if (tensorProto.segment !== undefined && tensorProto.segment !== null) {\n        throw new Error('Handling of tensor proto segment not yet implemented');\n    }\n    var shape = tensorProto.dims;\n    if (shape === undefined || shape === null) {\n        throw new Error('Tensor shape must be specified');\n    }\n    for (var i = 0; i < shape.length; i++) {\n        if (Long.isLong(shape[i])) {\n            shape[i] = shape[i].toNumber();\n        }\n    }\n    if (shape.length === 0) {\n        shape = [1];\n    }\n    var size = getSize(shape);\n    if (tensorProto.dataType === TENSOR_FLOAT) {\n        if (tensorProto.floatData && tensorProto.floatData.length > 0) {\n            return new CPUTensor(shape, tensorProto.floatData);\n        }\n        else if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var buffer = tensorProto.rawData.buffer.slice(tensorProto.rawData.byteOffset, tensorProto.rawData.byteOffset + tensorProto.rawData.byteLength);\n            var values = new Float32Array(buffer);\n            return new CPUTensor(shape, values);\n        }\n        else if (size === 0) {\n            return new CPUTensor(shape);\n        }\n        else {\n            throw new Error('Cant process float tensor without float or raw data');\n        }\n    }\n    else if (tensorProto.dataType === TENSOR_INT64) {\n        if (tensorProto.rawData && tensorProto.rawData.length > 0) {\n            var values = new Int32Array(tensorProto.rawData.length / 8);\n            for (var i = 0; i < tensorProto.rawData.length; i += 8) {\n                var value = Long.fromBytesLE(Array.from(tensorProto.rawData.slice(i, i + 8))).toNumber();\n                values[i / 8] = value;\n            }\n            return new CPUTensor(shape, values, \"int\");\n        }\n        else {\n            throw new Error('Cant process int64 tensor without raw data');\n        }\n    }\n    else {\n        throw new Error(\"Handling of tensor type \" + tensorProto.dataType + \" not yet implemented\");\n    }\n}\n//# sourceMappingURL=util.js.map","// Attribute types\nexport var ATTRIBUTE_UNDEFINED = 0;\nexport var ATTRIBUTE_FLOAT = 1; // Float32\nexport var ATTRIBUTE_INT = 2; // Int64\nexport var ATTRIBUTE_STRING = 3;\nexport var ATTRIBUTE_TENSOR = 4;\nexport var ATTRIBUTE_GRAPH = 5;\nexport var ATTRIBUTE_SPARSE_TENSOR = 11;\nexport var ATTRIBUTE_FLOATS = 6;\nexport var ATTRIBUTE_INTS = 7;\nexport var ATTRIBUTE_STRINGS = 8;\nexport var ATTRIBUTE_TENSORS = 9;\nexport var ATTRIBUTE_GRAPHS = 10;\nexport var ATTRIBUTE_SPARSE_TENSORS = 12;\n// Tensor types\nexport var TENSOR_FLOAT = 1; // float  (32 bits)\nexport var TENSOR_UINT8 = 2; // uint8_t\nexport var TENSOR_INT8 = 3; // int8_t\nexport var TENSOR_UINT16 = 4; // uint16_t\nexport var TENSOR_INT16 = 5; // int16_t\nexport var TENSOR_INT32 = 6; // int32_t\nexport var TENSOR_INT64 = 7; // int64_t\nexport var TENSOR_STRING = 8; // string\nexport var TENSOR_BOOL = 9; // bool\nexport var TENSOR_FLOAT16 = 10;\nexport var TENSOR_DOUBLE = 11;\nexport var TENSOR_UINT32 = 12;\nexport var TENSOR_UINT64 = 13;\nexport var TENSOR_COMPLEX64 = 14; // complex with float32 real and imaginary components\nexport var TENSOR_COMPLEX128 = 15; // complex with float64 real and imaginary components\n// Non-IEEE floating-point format based on IEEE754 single-precision\n// floating-point number truncated to 16 bits.\n// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.\nexport var TENSOR_BFLOAT16 = 16;\n//# sourceMappingURL=definitions.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { toCPU, toGPU, toWASM } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nimport { createTensor } from \"../util\";\nvar ConstantNode = /** @class */ (function (_super) {\n    __extends(ConstantNode, _super);\n    function ConstantNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor(\"value\");\n            _this.tensor = createTensor(tensor);\n        }\n        return _this;\n    }\n    ConstantNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [this.tensor]];\n                }\n                throw new Error('Constant with onnx version >= 11 not yet implemented');\n            });\n        });\n    };\n    ConstantNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ConstantNode.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.tensor)];\n                    case 1:\n                        _a.tensor = _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return ConstantNode;\n}(OnnxNode));\nexport { ConstantNode };\n//# sourceMappingURL=constant.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar AddNode = /** @class */ (function (_super) {\n    __extends(AddNode, _super);\n    function AddNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    AddNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [a.add(b)]];\n                }\n                throw new Error(\"Add not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return AddNode;\n}(OnnxNode));\nexport { AddNode };\n//# sourceMappingURL=add.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { toCPU, toGPU, toWASM } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nvar BatchNormalizationNode = /** @class */ (function (_super) {\n    __extends(BatchNormalizationNode, _super);\n    function BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-05;\n        _this.momentum = _this.getAttributeFloat('momentum') || 0.9;\n        _this.epsTensor = new CPUTensor([1], [_this.epsilon]);\n        return _this;\n        //TODO: Handle lower onnxversions here\n    }\n    BatchNormalizationNode.prototype.initialize = function (resolveConstant) {\n        var scale = resolveConstant(this.inputs[1]);\n        var B = resolveConstant(this.inputs[2]);\n        var mean = resolveConstant(this.inputs[3]);\n        var variance = resolveConstant(this.inputs[4]);\n        if (scale !== undefined && B !== undefined && mean !== undefined && variance !== undefined) {\n            var varSqrt = variance.add(this.epsTensor).sqrt();\n            this.scale = scale.divide(varSqrt);\n            this.bias = B.subtract(mean.multiply(this.scale));\n            varSqrt.delete();\n        }\n    };\n    BatchNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scaled, result, scale, B, mean, variance, C, newShape, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.scale !== undefined) {\n                    scaled = x.multiply(this.scale);\n                    result = scaled.add(this.bias);\n                    scaled.delete();\n                    return [2 /*return*/, [result]];\n                }\n                else {\n                    scale = inputs[1];\n                    B = inputs[2];\n                    mean = inputs[3];\n                    variance = inputs[4];\n                    C = scale.getShape()[0];\n                    newShape = __spreadArrays([1, C], new Array(x.getShape().length - 2).fill(1));\n                    scale = scale.reshape(newShape, false);\n                    B = B.reshape(newShape, false);\n                    mean = mean.reshape(newShape, false);\n                    variance = variance.reshape(newShape, false);\n                    result = x.normalize(mean, variance, this.epsilon, scale, B);\n                    return [2 /*return*/, [result]];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.scale !== undefined)) return [3 /*break*/, 3];\n                        _a = this;\n                        return [4 /*yield*/, toCPU(this.scale)];\n                    case 1:\n                        _a.scale = _c.sent();\n                        _b = this;\n                        return [4 /*yield*/, toCPU(this.bias)];\n                    case 2:\n                        _b.bias = _c.sent();\n                        _c.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.scale !== undefined)) return [3 /*break*/, 3];\n                        _a = this;\n                        return [4 /*yield*/, toWASM(this.scale)];\n                    case 1:\n                        _a.scale = _c.sent();\n                        _b = this;\n                        return [4 /*yield*/, toWASM(this.bias)];\n                    case 2:\n                        _b.bias = _c.sent();\n                        _c.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BatchNormalizationNode.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.scale !== undefined)) return [3 /*break*/, 3];\n                        _a = this;\n                        return [4 /*yield*/, toGPU(this.scale)];\n                    case 1:\n                        _a.scale = _c.sent();\n                        _b = this;\n                        return [4 /*yield*/, toGPU(this.bias)];\n                    case 2:\n                        _b.bias = _c.sent();\n                        _c.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return BatchNormalizationNode;\n}(OnnxNode));\nexport { BatchNormalizationNode };\n//# sourceMappingURL=batchNormalization.js.map","import { CPUTensor } from \"../../tensor/cpu/tensor\";\nexport function cast(a, to) {\n    if (a.type === to) {\n        return a;\n    }\n    else if (to === \"float\") {\n        var arr = new Float32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n    else {\n        var arr = new Int32Array(a.size);\n        for (var i = 0; i < a.size; i++) {\n            arr[i] = a.get(i);\n        }\n        return new CPUTensor(a.shape, arr, to);\n    }\n}\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { cast } from \"../../ops/cpu/cast\";\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar CastNode = /** @class */ (function (_super) {\n    __extends(CastNode, _super);\n    function CastNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.to = _this.getAttributeString(\"to\");\n        return _this;\n    }\n    CastNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (x instanceof CPUTensor) {\n                    return [2 /*return*/, [cast(x, this.to)]];\n                }\n                throw new Error(\"Can only cast CPU tensors right now\");\n            });\n        });\n    };\n    return CastNode;\n}(OnnxNode));\nexport { CastNode };\n//# sourceMappingURL=cast.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar CeilNode = /** @class */ (function (_super) {\n    __extends(CeilNode, _super);\n    function CeilNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    CeilNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.ceil()]];\n            });\n        });\n    };\n    return CeilNode;\n}(OnnxNode));\nexport { CeilNode };\n//# sourceMappingURL=ceil.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ClipNode = /** @class */ (function (_super) {\n    __extends(ClipNode, _super);\n    function ClipNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            _this.min = _this.getAttributeFloat('min');\n            _this.max = _this.getAttributeFloat('max');\n        }\n        return _this;\n    }\n    ClipNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, min, max;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [x.clip(this.min, this.max)]];\n                }\n                else {\n                    min = inputs.length > 1 ? inputs[1] : undefined;\n                    max = inputs.length > 2 ? inputs[2] : undefined;\n                    if (min === undefined && max === undefined) {\n                        return [2 /*return*/, [x.copy()]];\n                    }\n                    throw new Error('Clip with onnx version >= 11 not yet implemented');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    return ClipNode;\n}(OnnxNode));\nexport { ClipNode };\n//# sourceMappingURL=clip.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ConcatNode = /** @class */ (function (_super) {\n    __extends(ConcatNode, _super);\n    function ConcatNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.axis = _this.getAttributeInt(\"axis\");\n        }\n        return _this;\n    }\n    ConcatNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, i, newRes;\n            return __generator(this, function (_a) {\n                if (inputs.length > 2) {\n                    console.warn(\"Concat with more than 2 tensors is currently slow. Doing concat with \" + inputs.length + \" tensors\");\n                }\n                result = inputs[0];\n                for (i = 1; i < inputs.length; i++) {\n                    newRes = result.concat(inputs[i], this.axis);\n                    if (i > 1) {\n                        result.delete();\n                    }\n                    result = newRes;\n                }\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    return ConcatNode;\n}(OnnxNode));\nexport { ConcatNode };\n//# sourceMappingURL=concat.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { getSize } from \"../../util/shape\";\nimport { OnnxNode } from \"../node\";\nimport { createTensor } from \"../util\";\nvar ConstantOfShapeNode = /** @class */ (function (_super) {\n    __extends(ConstantOfShapeNode, _super);\n    function ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 11) {\n            var tensor = _this.getAttributeTensor(\"value\");\n            _this.tensor = createTensor(tensor);\n        }\n        return _this;\n    }\n    ConstantOfShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _shape, shape, i, size, values;\n            return __generator(this, function (_a) {\n                _shape = inputs[0];\n                if (!(_shape instanceof CPUTensor)) {\n                    throw new Error(\"ConstantOfShape needs cpu tensor as shape tensor\");\n                }\n                shape = new Array(_shape.size);\n                for (i = 0; i < _shape.size; i++) {\n                    shape[i] = _shape.get(i);\n                }\n                size = getSize(shape);\n                values = new Float32Array(size).fill(this.tensor.get(0));\n                return [2 /*return*/, [new CPUTensor(shape, values, this.tensor.type)]];\n            });\n        });\n    };\n    return ConstantOfShapeNode;\n}(OnnxNode));\nexport { ConstantOfShapeNode };\n//# sourceMappingURL=constantOfShape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ConvNode = /** @class */ (function (_super) {\n    __extends(ConvNode, _super);\n    function ConvNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        var autoPad = _this.getAttributeString('autoPad');\n        if (autoPad !== undefined) {\n            throw new Error('Autopad in conv not supported yet');\n        }\n        _this.group = _this.getAttributeInt('group') || 1;\n        _this.dilations = _this.getAttributeInts('dilations');\n        _this.pads = _this.getAttributeInts('pads');\n        _this.strides = _this.getAttributeInts('strides');\n        return _this;\n    }\n    ConvNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, w, b;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                w = inputs[1];\n                b = inputs.length > 2 ? inputs[2] : undefined;\n                return [2 /*return*/, [x.conv(w, b, this.dilations, this.group, this.pads, this.strides)]];\n            });\n        });\n    };\n    return ConvNode;\n}(OnnxNode));\nexport { ConvNode };\n//# sourceMappingURL=conv.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar DivNode = /** @class */ (function (_super) {\n    __extends(DivNode, _super);\n    function DivNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    DivNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [a.divide(b)]];\n                }\n                throw new Error(\"Add not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return DivNode;\n}(OnnxNode));\nexport { DivNode };\n//# sourceMappingURL=div.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ExpNode = /** @class */ (function (_super) {\n    __extends(ExpNode, _super);\n    function ExpNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ExpNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                return [2 /*return*/, [x.exp()]];\n            });\n        });\n    };\n    return ExpNode;\n}(OnnxNode));\nexport { ExpNode };\n//# sourceMappingURL=exp.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ExpandNode = /** @class */ (function (_super) {\n    __extends(ExpandNode, _super);\n    function ExpandNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ExpandNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tensor, _shape, shape, i;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    tensor = inputs[0];\n                    _shape = inputs[1];\n                    if (!(_shape instanceof CPUTensor)) {\n                        throw new Error(\"Expand needs cpu tensor as shape tensor\");\n                    }\n                    shape = new Array(_shape.size);\n                    for (i = 0; i < _shape.size; i++) {\n                        shape[i] = _shape.get(i);\n                    }\n                    return [2 /*return*/, [tensor.expand(shape)]];\n                }\n                throw new Error('Expand not yet implemented');\n            });\n        });\n    };\n    return ExpandNode;\n}(OnnxNode));\nexport { ExpandNode };\n//# sourceMappingURL=expand.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar FloorNode = /** @class */ (function (_super) {\n    __extends(FloorNode, _super);\n    function FloorNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    FloorNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.floor()]];\n            });\n        });\n    };\n    return FloorNode;\n}(OnnxNode));\nexport { FloorNode };\n//# sourceMappingURL=floor.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar GatherNode = /** @class */ (function (_super) {\n    __extends(GatherNode, _super);\n    function GatherNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axis = _this.getAttributeInt(\"axis\") || 0;\n        return _this;\n    }\n    GatherNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, indices;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                indices = inputs[1];\n                if (!(indices instanceof CPUTensor)) {\n                    throw new Error(\"Gather requires CPU tensor for the indices\");\n                }\n                return [2 /*return*/, [x.gather(this.axis, indices)]];\n            });\n        });\n    };\n    return GatherNode;\n}(OnnxNode));\nexport { GatherNode };\n//# sourceMappingURL=gather.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar GemmNode = /** @class */ (function (_super) {\n    __extends(GemmNode, _super);\n    function GemmNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.alpha = _this.getAttributeFloat(\"alpha\") || 1.0;\n        _this.beta = _this.getAttributeFloat(\"beta\") || 1.0;\n        var transA = _this.getAttributeInt(\"transA\");\n        var transB = _this.getAttributeInt(\"transB\");\n        _this.transA = transA === 1;\n        _this.transB = transB === 1;\n        return _this;\n    }\n    GemmNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b, c;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion >= 9 && this.onnxVersion < 11) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    c = inputs[2];\n                    return [2 /*return*/, [a.gemm(b, this.transA, this.transB, this.alpha, c, this.beta)]];\n                }\n                throw new Error(\"Gemm is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return GemmNode;\n}(OnnxNode));\nexport { GemmNode };\n//# sourceMappingURL=gemm.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { glContext } from \"../../tensor/gpu/gl\";\nimport { OnnxNode } from \"../node\";\nvar InstanceNormalizationNode = /** @class */ (function (_super) {\n    __extends(InstanceNormalizationNode, _super);\n    function InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.epsilon = _this.getAttributeFloat('epsilon') || 1e-05;\n        return _this;\n        //TODO: Handle onnx versions < 6 here\n    }\n    InstanceNormalizationNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, B, dataRank, C, newShape, reduceAxes, i, mean, diff, variance, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                scale = inputs[1];\n                B = inputs[2];\n                dataRank = x.getShape().length - 2;\n                C = scale.getShape()[0];\n                newShape = __spreadArrays([1, C], new Array(dataRank).fill(1));\n                scale = scale.reshape(newShape, false);\n                B = B.reshape(newShape, false);\n                reduceAxes = new Array(x.getShape().length - 2);\n                for (i = 0; i < dataRank; i++) {\n                    reduceAxes[i] = i + 2;\n                }\n                mean = x.reduceMean(reduceAxes, true);\n                glContext.flush();\n                diff = x.subtract(mean);\n                glContext.flush();\n                variance = diff.reduceMeanSquare(reduceAxes, true);\n                glContext.flush();\n                result = x.normalize(mean, variance, this.epsilon, scale, B);\n                mean.delete();\n                diff.delete();\n                variance.delete();\n                return [2 /*return*/, [result]];\n            });\n        });\n    };\n    return InstanceNormalizationNode;\n}(OnnxNode));\nexport { InstanceNormalizationNode };\n//# sourceMappingURL=instanceNormalization.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar MatMulNode = /** @class */ (function (_super) {\n    __extends(MatMulNode, _super);\n    function MatMulNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    MatMulNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var A, B, result;\n            return __generator(this, function (_a) {\n                A = inputs[0];\n                B = inputs[1];\n                if (this.onnxVersion < 13 && this.onnxVersion >= 9) {\n                    if (A.getShape().length !== B.getShape().length) {\n                        throw new Error(\"Automatic broadcasting in MatMul not supported yet\");\n                    }\n                    result = A.gemm(B);\n                    return [2 /*return*/, [result]];\n                }\n                throw new Error(\"Matmul with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    return MatMulNode;\n}(OnnxNode));\nexport { MatMulNode };\n//# sourceMappingURL=matMul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar MulNode = /** @class */ (function (_super) {\n    __extends(MulNode, _super);\n    function MulNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    MulNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [a.multiply(b)]];\n                }\n                throw new Error(\"Add not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return MulNode;\n}(OnnxNode));\nexport { MulNode };\n//# sourceMappingURL=mul.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar PadNode = /** @class */ (function (_super) {\n    __extends(PadNode, _super);\n    function PadNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.mode = (_this.getAttributeString('mode') || 'constant');\n        _this.pads = _this.getAttributeInts('pads');\n        _this.value = _this.getAttributeFloat(\"value\");\n        return _this;\n    }\n    PadNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].pad(this.pads, this.mode, this.value)]];\n                }\n                throw new Error(\"Pad not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return PadNode;\n}(OnnxNode));\nexport { PadNode };\n//# sourceMappingURL=pad.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ReduceMaxNode = /** @class */ (function (_super) {\n    __extends(ReduceMaxNode, _super);\n    function ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        var keep = _this.getAttributeInt(\"keepdims\");\n        _this.keepDims = keep === 1 || keep === undefined;\n        return _this;\n    }\n    ReduceMaxNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].max(this.axes, this.keepDims)]];\n                }\n                throw new Error(\"Reduce max is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return ReduceMaxNode;\n}(OnnxNode));\nexport { ReduceMaxNode };\n//# sourceMappingURL=reduceMax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ReduceMeanNode = /** @class */ (function (_super) {\n    __extends(ReduceMeanNode, _super);\n    function ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        var keep = _this.getAttributeInt(\"keepdims\");\n        _this.keepDims = keep === 1 || keep === undefined;\n        return _this;\n    }\n    ReduceMeanNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].reduceMean(this.axes, this.keepDims)]];\n                }\n                throw new Error(\"Reduce mean is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return ReduceMeanNode;\n}(OnnxNode));\nexport { ReduceMeanNode };\n//# sourceMappingURL=reduceMean.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ReduceSumNode = /** @class */ (function (_super) {\n    __extends(ReduceSumNode, _super);\n    function ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        var keep = _this.getAttributeInt(\"keepdims\");\n        _this.keepDims = keep === 1 || keep === undefined;\n        return _this;\n    }\n    ReduceSumNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].sum(this.axes, this.keepDims)]];\n                }\n                throw new Error(\"Reduce mean is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return ReduceSumNode;\n}(OnnxNode));\nexport { ReduceSumNode };\n//# sourceMappingURL=reduceSum.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ReduceSumSquareNode = /** @class */ (function (_super) {\n    __extends(ReduceSumSquareNode, _super);\n    function ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        var keep = _this.getAttributeInt(\"keepdims\");\n        _this.keepDims = keep === 1 || keep === undefined;\n        return _this;\n    }\n    ReduceSumSquareNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    return [2 /*return*/, [inputs[0].sumSquare(this.axes, this.keepDims)]];\n                }\n                throw new Error(\"Reduce mean is not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return ReduceSumSquareNode;\n}(OnnxNode));\nexport { ReduceSumSquareNode };\n//# sourceMappingURL=reduceSumSquare.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar ReluNode = /** @class */ (function (_super) {\n    __extends(ReluNode, _super);\n    function ReluNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ReluNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.clip(0)]];\n            });\n        });\n    };\n    return ReluNode;\n}(OnnxNode));\nexport { ReluNode };\n//# sourceMappingURL=relu.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ReshapeNode = /** @class */ (function (_super) {\n    __extends(ReshapeNode, _super);\n    function ReshapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.shape = _this.getAttributeInts(\"shape\");\n        }\n        return _this;\n    }\n    ReshapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shape, _shape, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shape = inputs[1];\n                if (!(shape instanceof CPUTensor)) {\n                    throw new Error('Reshape only works with CPU tensor as shape tensor');\n                }\n                if (this.onnxVersion < 13) {\n                    _shape = new Array(shape.size);\n                    for (i = 0; i < shape.size; i++) {\n                        _shape[i] = shape.get(i);\n                    }\n                    return [2 /*return*/, [x.reshape(_shape)]];\n                }\n                throw new Error(\"Reshape with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    return ReshapeNode;\n}(OnnxNode));\nexport { ReshapeNode };\n//# sourceMappingURL=reshape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar ShapeNode = /** @class */ (function (_super) {\n    __extends(ShapeNode, _super);\n    function ShapeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    ShapeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, shape;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13) {\n                    a = inputs[0];\n                    shape = a.getShape();\n                    return [2 /*return*/, [new CPUTensor([shape.length], __spreadArrays(shape), \"int\")]];\n                }\n                throw new Error(\"Shape not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return ShapeNode;\n}(OnnxNode));\nexport { ShapeNode };\n//# sourceMappingURL=shape.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar SliceNode = /** @class */ (function (_super) {\n    __extends(SliceNode, _super);\n    function SliceNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axes = _this.getAttributeInts(\"axes\");\n        _this.starts = _this.getAttributeInts(\"starts\");\n        _this.ends = _this.getAttributeInts(\"ends\");\n        return _this;\n    }\n    SliceNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 11) {\n                    a = inputs[0];\n                    return [2 /*return*/, [a.slice(this.starts, this.ends, this.axes)]];\n                }\n                throw new Error(\"Slice not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return SliceNode;\n}(OnnxNode));\nexport { SliceNode };\n//# sourceMappingURL=slice.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar SoftmaxNode = /** @class */ (function (_super) {\n    __extends(SoftmaxNode, _super);\n    function SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.axis = _this.getAttributeInt(\"axis\");\n        return _this;\n    }\n    SoftmaxNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, shapeX, ax, sh1, reshaped, max, normalized, exp, sum, result;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                shapeX = x.getShape();\n                ax = this.axis;\n                if (ax === undefined) {\n                    if (this.onnxVersion < 13) {\n                        ax = 1;\n                    }\n                    else {\n                        ax = shapeX.length - 1;\n                    }\n                }\n                sh1 = shapeX.slice(0, ax).reduce(function (x, y) { return x * y; }, 1);\n                reshaped = x.reshape([sh1, -1], false);\n                max = reshaped.max(1, true);\n                normalized = reshaped.subtract(max);\n                exp = normalized.exp();\n                sum = exp.sum(1, true);\n                result = exp.divide(sum);\n                max.delete();\n                normalized.delete();\n                exp.delete();\n                sum.delete();\n                return [2 /*return*/, [result.reshape(shapeX, false)]];\n            });\n        });\n    };\n    return SoftmaxNode;\n}(OnnxNode));\nexport { SoftmaxNode };\n//# sourceMappingURL=softmax.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar SubNode = /** @class */ (function (_super) {\n    __extends(SubNode, _super);\n    function SubNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    SubNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a, b;\n            return __generator(this, function (_a) {\n                if (this.onnxVersion < 13 && this.onnxVersion >= 7) {\n                    a = inputs[0];\n                    b = inputs[1];\n                    return [2 /*return*/, [a.subtract(b)]];\n                }\n                throw new Error(\"Add not implemented for onnx version \" + this.onnxVersion);\n            });\n        });\n    };\n    return SubNode;\n}(OnnxNode));\nexport { SubNode };\n//# sourceMappingURL=sub.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { OnnxNode } from \"../node\";\nvar TileNode = /** @class */ (function (_super) {\n    __extends(TileNode, _super);\n    function TileNode(attributes, inputs, outputs, constants, onnxVersion) {\n        return _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n    }\n    TileNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, repeats, _repeats, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                repeats = inputs[1];\n                if (!(repeats instanceof CPUTensor)) {\n                    throw new Error('Tile only works with CPU tensor as repeats');\n                }\n                if (this.onnxVersion < 13 && this.onnxVersion >= 6) {\n                    _repeats = new Array(repeats.size);\n                    for (i = 0; i < repeats.size; i++) {\n                        _repeats[i] = repeats.get(i);\n                    }\n                    return [2 /*return*/, [x.repeat(_repeats)]];\n                }\n                throw new Error(\"Tile with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    return TileNode;\n}(OnnxNode));\nexport { TileNode };\n//# sourceMappingURL=tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar TransposeNode = /** @class */ (function (_super) {\n    __extends(TransposeNode, _super);\n    function TransposeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.permutation = _this.getAttributeInts(\"perm\");\n        return _this;\n    }\n    TransposeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var a;\n            return __generator(this, function (_a) {\n                a = inputs[0];\n                return [2 /*return*/, [a.transpose(this.permutation)]];\n            });\n        });\n    };\n    return TransposeNode;\n}(OnnxNode));\nexport { TransposeNode };\n//# sourceMappingURL=transpose.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { OnnxNode } from \"../node\";\nvar UnsqueezeNode = /** @class */ (function (_super) {\n    __extends(UnsqueezeNode, _super);\n    function UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        if (onnxVersion < 13) {\n            _this.axes = _this.getAttributeInts(\"axes\");\n        }\n        return _this;\n    }\n    UnsqueezeNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, currShape, newShape, axIx, i;\n            return __generator(this, function (_a) {\n                x = inputs[0];\n                if (this.onnxVersion < 13) {\n                    currShape = x.getShape();\n                    newShape = [];\n                    axIx = 0;\n                    for (i = 0; i < currShape.length; i++) {\n                        if (axIx < this.axes.length && this.axes[axIx] === i) {\n                            newShape.push(1);\n                            axIx++;\n                        }\n                        newShape.push(currShape[i]);\n                    }\n                    if (this.axes[this.axes.length - 1] === currShape.length) {\n                        newShape.push(1);\n                    }\n                    return [2 /*return*/, [x.reshape(newShape)]];\n                }\n                throw new Error(\"Unsqueeze with onnx version \" + this.onnxVersion + \" not yet implemented\");\n            });\n        });\n    };\n    return UnsqueezeNode;\n}(OnnxNode));\nexport { UnsqueezeNode };\n//# sourceMappingURL=unsqueeze.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { CPUTensor } from \"../../tensor/cpu/tensor\";\nimport { toCPU } from \"../../util/convert\";\nimport { OnnxNode } from \"../node\";\nvar UpsampleNode = /** @class */ (function (_super) {\n    __extends(UpsampleNode, _super);\n    function UpsampleNode(attributes, inputs, outputs, constants, onnxVersion) {\n        var _this = _super.call(this, attributes, inputs, outputs, constants, onnxVersion) || this;\n        _this.mode = _this.getAttributeString(\"mode\");\n        if (_this.mode !== \"nearest\") {\n            throw new Error(\"Upsampling only supported with nearest neighbor sampling\");\n        }\n        return _this;\n    }\n    UpsampleNode.prototype.forward = function (inputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, scale, sc, scales, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        x = inputs[0];\n                        scale = inputs[1];\n                        if (!!(scale instanceof CPUTensor)) return [3 /*break*/, 2];\n                        console.warn(\"Scales tensor for upsample not on CPU, need to transfer!\");\n                        return [4 /*yield*/, toCPU(scale)];\n                    case 1:\n                        scale = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        sc = scale;\n                        scales = new Array(sc.size);\n                        for (i = 0; i < sc.size; i++) {\n                            scales[i] = sc.get(i);\n                        }\n                        return [2 /*return*/, [x.upsample(scales)]];\n                }\n            });\n        });\n    };\n    return UpsampleNode;\n}(OnnxNode));\nexport { UpsampleNode };\n//# sourceMappingURL=upsample.js.map","import { AddNode } from \"./nodes/add\";\nimport { BatchNormalizationNode } from \"./nodes/batchNormalization\";\nimport { CastNode } from \"./nodes/cast\";\nimport { CeilNode } from \"./nodes/ceil\";\nimport { ClipNode } from \"./nodes/clip\";\nimport { ConcatNode } from \"./nodes/concat\";\nimport { ConstantNode } from \"./nodes/constant\";\nimport { ConstantOfShapeNode } from \"./nodes/constantOfShape\";\nimport { ConvNode } from \"./nodes/conv\";\nimport { DivNode } from \"./nodes/div\";\nimport { ExpNode } from \"./nodes/exp\";\nimport { ExpandNode } from \"./nodes/expand\";\nimport { FloorNode } from \"./nodes/floor\";\nimport { GatherNode } from \"./nodes/gather\";\nimport { GemmNode } from \"./nodes/gemm\";\nimport { InstanceNormalizationNode } from \"./nodes/instanceNormalization\";\nimport { MatMulNode } from \"./nodes/matMul\";\nimport { MulNode } from \"./nodes/mul\";\nimport { PadNode } from \"./nodes/pad\";\nimport { ReduceMaxNode } from \"./nodes/reduceMax\";\nimport { ReduceMeanNode } from \"./nodes/reduceMean\";\nimport { ReduceSumNode } from \"./nodes/reduceSum\";\nimport { ReduceSumSquareNode } from \"./nodes/reduceSumSquare\";\nimport { ReluNode } from \"./nodes/relu\";\nimport { ReshapeNode } from \"./nodes/reshape\";\nimport { ShapeNode } from \"./nodes/shape\";\nimport { SliceNode } from \"./nodes/slice\";\nimport { SoftmaxNode } from \"./nodes/softmax\";\nimport { SubNode } from \"./nodes/sub\";\nimport { TileNode } from \"./nodes/tile\";\nimport { TransposeNode } from \"./nodes/transpose\";\nimport { UnsqueezeNode } from \"./nodes/unsqueeze\";\nimport { UpsampleNode } from \"./nodes/upsample\";\nexport var nodeResolve = {\n    'Conv': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConvNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'BatchNormalization': function (attributes, inputs, outputs, constants, onnxVersion) { return new BatchNormalizationNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Clip': function (attributes, inputs, outputs, constants, onnxVersion) { return new ClipNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Add': function (attributes, inputs, outputs, constants, onnxVersion) { return new AddNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceMean': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceMeanNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Gemm': function (attributes, inputs, outputs, constants, onnxVersion) { return new GemmNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Constant': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConstantNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Reshape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReshapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Tile': function (attributes, inputs, outputs, constants, onnxVersion) { return new TileNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'MatMul': function (attributes, inputs, outputs, constants, onnxVersion) { return new MatMulNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Exp': function (attributes, inputs, outputs, constants, onnxVersion) { return new ExpNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceSum': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceSumNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceMax': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceMaxNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ReduceSumSquare': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReduceSumSquareNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Sub': function (attributes, inputs, outputs, constants, onnxVersion) { return new SubNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Mul': function (attributes, inputs, outputs, constants, onnxVersion) { return new MulNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Div': function (attributes, inputs, outputs, constants, onnxVersion) { return new DivNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Unsqueeze': function (attributes, inputs, outputs, constants, onnxVersion) { return new UnsqueezeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Concat': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConcatNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'ConstantOfShape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ConstantOfShapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Expand': function (attributes, inputs, outputs, constants, onnxVersion) { return new ExpandNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'InstanceNormalization': function (attributes, inputs, outputs, constants, onnxVersion) { return new InstanceNormalizationNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Pad': function (attributes, inputs, outputs, constants, onnxVersion) { return new PadNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Relu': function (attributes, inputs, outputs, constants, onnxVersion) { return new ReluNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Shape': function (attributes, inputs, outputs, constants, onnxVersion) { return new ShapeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Gather': function (attributes, inputs, outputs, constants, onnxVersion) { return new GatherNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Cast': function (attributes, inputs, outputs, constants, onnxVersion) { return new CastNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Floor': function (attributes, inputs, outputs, constants, onnxVersion) { return new FloorNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Ceil': function (attributes, inputs, outputs, constants, onnxVersion) { return new CeilNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Slice': function (attributes, inputs, outputs, constants, onnxVersion) { return new SliceNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Upsample': function (attributes, inputs, outputs, constants, onnxVersion) { return new UpsampleNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Transpose': function (attributes, inputs, outputs, constants, onnxVersion) { return new TransposeNode(attributes, inputs, outputs, constants, onnxVersion); },\n    'Softmax': function (attributes, inputs, outputs, constants, onnxVersion) { return new SoftmaxNode(attributes, inputs, outputs, constants, onnxVersion); },\n};\n//# sourceMappingURL=resolve.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport Long from 'long';\nimport { onnx } from 'onnx-proto';\nimport { glContext } from '../tensor/gpu/gl';\nimport { toCPU, toGPU, toWASM } from '../util/convert';\nimport { ConstantNode } from './nodes/constant';\nimport { nodeResolve } from './resolve';\nimport { createTensor } from './util';\nvar OnnxModel = /** @class */ (function () {\n    function OnnxModel(buffer, args) {\n        this.inputSet = new Set();\n        this.nodes = {};\n        this.nodeIds = [];\n        this.defaultReady = [];\n        this.intermediaries = {};\n        this.constants = {};\n        var arr;\n        if (buffer instanceof ArrayBuffer) {\n            arr = new Uint8Array(buffer);\n        }\n        else {\n            arr = buffer;\n        }\n        var modelProto = onnx.ModelProto.decode(arr);\n        var ver = modelProto.opsetImport[0].version;\n        if (Long.isLong(ver)) {\n            ver = ver.toNumber();\n        }\n        this.version = ver;\n        this.inputs = modelProto.graph.input;\n        for (var i = 0; i < this.inputs.length; i++) {\n            this.inputSet.add(this.inputs[i].name);\n        }\n        this.outputs = modelProto.graph.output.map(function (x) { return x.name; });\n        this.initializer(modelProto.graph.initializer);\n        this.initNodes(modelProto);\n        if (args === undefined) {\n            args = {};\n        }\n        this.noConvertConstants = new Set(args.noConvertConstants !== undefined ? args.noConvertConstants : []);\n        this.noConvertNodes = new Set(args.noConvertNodes !== undefined ? args.noConvertNodes : []);\n    }\n    OnnxModel.prototype.initNodes = function (modelProto) {\n        var _this = this;\n        for (var i = 0; i < modelProto.graph.node.length; i++) {\n            var nodeData = modelProto.graph.node[i];\n            var cls = nodeResolve[nodeData.opType];\n            if (cls === undefined) {\n                throw new Error(\"Node operator \" + nodeData.opType + \" can not be resolved\");\n            }\n            var attributes = nodeData.attribute || [];\n            var inputs = nodeData.input || [];\n            var outputs = nodeData.output || [];\n            var node = cls(attributes, inputs, outputs, this.constants, this.version);\n            this.nodes[i] = node;\n            this.nodeIds.push(i);\n            for (var j = 0; j < inputs.length; j++) {\n                var input = inputs[j];\n                if (this.intermediaries[input] === undefined) {\n                    this.intermediaries[input] = {\n                        to: [],\n                        deletable: true\n                    };\n                }\n                this.intermediaries[input].to.push(i);\n            }\n            if (node.variableInputs === 0) {\n                this.defaultReady.push(i);\n            }\n            if (nodeData.opType === 'Constant') {\n                if (this.intermediaries[nodeData.output[0]] === undefined) {\n                    this.intermediaries[nodeData.output[0]] = {\n                        to: [],\n                        deletable: false\n                    };\n                }\n                else {\n                    this.intermediaries[nodeData.output[0]].deletable = false;\n                }\n            }\n        }\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var nodeId = _a[_i];\n            this.nodes[nodeId].initialize(function (name) { return _this.resolveConstant(name); });\n        }\n    };\n    OnnxModel.prototype.initializer = function (initializer) {\n        for (var i = 0; i < initializer.length; i++) {\n            var tensorProto = initializer[i];\n            var tensor = createTensor(tensorProto);\n            this.constants[tensorProto.name] = tensor;\n        }\n    };\n    OnnxModel.prototype.forward = function (inputs, wait) {\n        return __awaiter(this, void 0, void 0, function () {\n            var intermediaryRes, nodes, _i, _a, i, nodesReady, i, inter, j, id, toDelete, nodeId, node, inputs_1, i, input, inter, outputs_1, e_1, i, output, inter, j, id, i, inter, outputs, i;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        intermediaryRes = {};\n                        nodes = {};\n                        for (_i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n                            i = _a[_i];\n                            nodes[i] = {\n                                variableInputs: 0\n                            };\n                        }\n                        nodesReady = __spreadArrays(this.defaultReady);\n                        for (i = 0; i < inputs.length; i++) {\n                            intermediaryRes[this.inputs[i].name] = {\n                                value: inputs[i],\n                                used: 0\n                            };\n                            inter = this.intermediaries[this.inputs[i].name];\n                            for (j = 0; j < inter.to.length; j++) {\n                                id = inter.to[j];\n                                nodes[id].variableInputs++;\n                                if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                                    nodesReady.push(id);\n                                    delete nodes[id];\n                                }\n                            }\n                        }\n                        _b.label = 1;\n                    case 1:\n                        if (!(nodesReady.length > 0)) return [3 /*break*/, 8];\n                        toDelete = [];\n                        nodeId = nodesReady.shift();\n                        node = this.nodes[nodeId];\n                        inputs_1 = [];\n                        for (i = 0; i < node.inputs.length; i++) {\n                            input = node.inputs[i];\n                            if (this.constants[input] !== undefined) {\n                                inputs_1.push(this.constants[input]);\n                            }\n                            else {\n                                inter = intermediaryRes[input];\n                                inter.used++;\n                                if (inter.used === this.intermediaries[input].to.length && this.intermediaries[input].deletable) {\n                                    toDelete.push(input);\n                                }\n                                inputs_1.push(inter.value);\n                            }\n                        }\n                        outputs_1 = void 0;\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, node.forward(inputs_1)];\n                    case 3:\n                        outputs_1 = _b.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _b.sent();\n                        console.error(\"Error occurred in node \" + nodeId + \" with inputs \" + node.inputs + \" from nodes \" + node.inputs.map(function (x) { return _this.getNodeWithOutput(x); }));\n                        throw e_1;\n                    case 5:\n                        glContext.flush();\n                        for (i = 0; i < node.outputs.length; i++) {\n                            output = node.outputs[i];\n                            intermediaryRes[output] = {\n                                value: outputs_1[i],\n                                used: 0\n                            };\n                            inter = this.intermediaries[output];\n                            if (inter !== undefined) {\n                                for (j = 0; j < inter.to.length; j++) {\n                                    id = inter.to[j];\n                                    nodes[id].variableInputs++;\n                                    if (nodes[id].variableInputs === this.nodes[id].variableInputs) {\n                                        nodesReady.push(id);\n                                        delete nodes[id];\n                                    }\n                                }\n                            }\n                        }\n                        for (i = 0; i < toDelete.length; i++) {\n                            if (!this.inputSet.has(toDelete[i])) {\n                                inter = intermediaryRes[toDelete[i]];\n                                inter.value.delete();\n                                delete intermediaryRes[toDelete[i]];\n                            }\n                        }\n                        if (!(wait !== undefined)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, new Promise(function (resolve, _) {\n                                setTimeout(resolve, wait);\n                            })];\n                    case 6:\n                        _b.sent();\n                        _b.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8:\n                        outputs = [];\n                        for (i = 0; i < this.outputs.length; i++) {\n                            outputs.push(intermediaryRes[this.outputs[i]].value);\n                        }\n                        return [2 /*return*/, outputs];\n                }\n            });\n        });\n    };\n    OnnxModel.prototype.getNodeWithOutput = function (output) {\n        for (var _i = 0, _a = this.nodeIds; _i < _a.length; _i++) {\n            var id = _a[_i];\n            if (this.nodes[id].outputs.findIndex(function (x) { return x === output; }) !== -1) {\n                return id;\n            }\n        }\n    };\n    OnnxModel.prototype.resolveConstant = function (name) {\n        if (this.constants[name] !== undefined) {\n            return this.constants[name];\n        }\n        var nodeIdOut = this.getNodeWithOutput(name);\n        var nodeOut = this.nodes[nodeIdOut];\n        if (nodeOut instanceof ConstantNode) {\n            return nodeOut.tensor;\n        }\n        return undefined;\n    };\n    OnnxModel.prototype.toCPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toCPU(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toCPU()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    OnnxModel.prototype.toWASM = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toWASM(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toWASM()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    OnnxModel.prototype.toGPU = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _i, i, _c, _d, _e, _f, i;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        _a = [];\n                        for (_b in this.constants)\n                            _a.push(_b);\n                        _i = 0;\n                        _g.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        i = _a[_i];\n                        if (!!this.noConvertConstants.has(i)) return [3 /*break*/, 3];\n                        _c = this.constants;\n                        _d = i;\n                        return [4 /*yield*/, toGPU(this.constants[i])];\n                    case 2:\n                        _c[_d] = _g.sent();\n                        _g.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        _e = 0, _f = this.nodeIds;\n                        _g.label = 5;\n                    case 5:\n                        if (!(_e < _f.length)) return [3 /*break*/, 8];\n                        i = _f[_e];\n                        if (!!this.noConvertNodes.has(i)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.nodes[i].toGPU()];\n                    case 6:\n                        _g.sent();\n                        _g.label = 7;\n                    case 7:\n                        _e++;\n                        return [3 /*break*/, 5];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return OnnxModel;\n}());\nexport { OnnxModel };\n//# sourceMappingURL=model.js.map","import * as tjs from '@hoff97/tensor-js';\n\n\nexport async function loadModel(name: string) {\n    const res = await fetch(`models/${name}.onnx`);\n    const buffer = await res.arrayBuffer();\n\n    const model = new tjs.onnx.model.OnnxModel(buffer, {\n        noConvertNodes: [69, 98]\n    });\n    await model.toGPU();\n\n    return model;\n}","import React from 'react';\nimport './App.css';\nimport { loadModel } from './inference';\n\nimport * as tjs from '@hoff97/tensor-js';\n\ninterface AppState {\n  img: any;\n  scale: number;\n  croppedSize: number;\n  showResult: boolean;\n  model: string;\n}\n\nconst models = [\n  \"mosaic\",\n  \"candy\",\n  \"pointilism\",\n  \"udnie\",\n  \"rain-princess\"\n];\n\nclass App extends React.Component<{}, AppState> {\n  private model?: tjs.onnx.model.OnnxModel = undefined;\n\n  private scale = new tjs.tensor.gpu.GPUTensor(new Float32Array([255]), [1]);\n\n  constructor(props: {}) {\n    super(props);\n\n    loadModel('mosaic').then(x => {\n      this.model = x;\n    });\n\n    this.setState({\n      scale: 50,\n      model: 'mosaic'\n    });\n  }\n\n  getImageData() {\n    const el = document.getElementById(\"img\") as HTMLImageElement;\n\n    console.log('Reading pixels');\n    const tensor = tjs.tensor.gpu.GPUTensor.fromData(el);\n\n    let [height, width] = tensor.shape.slice(0,2);\n\n    const cropSize = Math.min(width, height);\n    const halfSize = Math.floor(cropSize/2);\n\n    const widthSliceStart = Math.floor(width/2) - halfSize;\n    const heightSliceStart = Math.floor(height/2) - halfSize;\n\n    const sliced = tensor.slice([heightSliceStart, widthSliceStart,0], [heightSliceStart + cropSize,widthSliceStart + cropSize,3], [0,1,2]);\n    tensor.delete();\n\n    const showWidth = this.getImageWidth(this.state.scale);\n    const scale = showWidth/width;\n    const scaled = sliced.upsample([scale,scale,1]);\n    sliced.delete();\n\n    const croppedSize = scaled.getShape()[0];\n\n    this.setState({\n      ...this.state,\n      croppedSize: croppedSize,\n    });\n\n    const transposed = scaled.transpose([2, 0, 1]);\n    scaled.delete();\n    const multiplied = transposed.multiply(this.scale)\n    transposed.delete();\n    const reshaped = multiplied.reshape([1,3,croppedSize,croppedSize], false);\n\n    console.log('Doing forward pass');\n    this.model?.forward([reshaped], 100).then(result => this.handleResult(result[0]));\n  }\n\n  handleResult(tensor: tjs.Tensor) {\n    console.log('Got result', tensor);\n\n    this.setState({\n      ...this.state,\n      showResult: true\n    })\n\n    const sh = tensor.getShape();\n\n    tensor = tensor.reshape(sh.slice(1), false);\n    const transposed = tensor.transpose([1,2,0]);\n    tensor.delete();\n\n    const t = (transposed as tjs.tensor.gpu.GPUTensor).toTexture();\n    transposed.delete();\n\n    t.getValues().then(x => {\n      const canv = document.getElementById(\"canvas\") as HTMLCanvasElement;\n      const context = canv.getContext(\"2d\");\n\n      if (context) {\n        var id = context.createImageData(t.shape[0],t.shape[1]);\n        var d  = id.data;\n\n        for (let i = 0; i < x.length; i++) {\n          d[i] = Math.round(x[i]);\n        }\n        context.putImageData(id, 0, 0);\n      }\n\n      t.delete();\n    });\n  }\n\n  fileSelected(ev: React.ChangeEvent<HTMLInputElement>) {\n    //@ts-ignore\n    this.setState({\n      ...this.state,\n      scale: 50,\n      //@ts-ignore\n      img: URL.createObjectURL(ev.target.files[0]),\n      showResult: false\n    });\n  }\n\n  getImageWidth(scale: number) {\n    const width = Math.round(400*(scale/50) + 50);\n\n    return Math.floor(width/32)*32;\n  }\n\n  async setModel(name: string) {\n    this.setState({\n      ...this.state,\n      model: name\n    })\n    this.model = await loadModel(name);\n  }\n\n  render() {\n    let img;\n    let scale = 50;\n    let croppedSize = 50;\n    let showResult = false;\n    if (this.state) {\n      img = this.state.img;\n      scale = this.state.scale || 50;\n      croppedSize = this.state.croppedSize;\n      showResult = this.state.showResult;\n    }\n\n    const width = this.getImageWidth(scale);\n\n    return (\n      <div className=\"App\">\n        <h1>Style transfer</h1>\n        <label htmlFor=\"model\">Choose a style:</label> <select id=\"model\" onChange={x => this.setModel(x.target.value)}>\n          {\n            models.map(x => (\n              <option value={x} key={x}>{x}</option>\n            ))\n          }\n        </select><br/>\n        <label htmlFor=\"file\">Choose an image:</label> <input type='file' id=\"file\" onChange={x => this.fileSelected(x)}/><br/>\n        { img !== undefined ? (<>\n            <div className=\"slidecontainer\">\n              Scale: <input type=\"range\" min=\"1\" max=\"100\" defaultValue={scale}\n                className=\"slider\" id=\"myRange\"\n                //@ts-ignore\n                onChange={ev => this.setState({...this.state, showResult: false, scale: parseInt(ev.currentTarget.value)})}/>\n            </div>\n            <img id=\"img\" src={this.state.img} alt=\"Your upload\" width={width}/><br/>\n\n            <button onClick={() => this.getImageData()}>Run</button><br/>\n\n            {\n              showResult ? (\n                <canvas id=\"canvas\" width={croppedSize} height={croppedSize}></canvas>\n              ) : (<></>)\n            }\n          </>) : (<></>)}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}